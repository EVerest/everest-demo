diff --git a/iso15118/evcc/asn1/__init__.py b/iso15118/evcc/asn1/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/iso15118/evcc/asn1/archived/edp_asn1_main.py b/iso15118/evcc/asn1/archived/edp_asn1_main.py
new file mode 100644
index 0000000..6c77523
--- /dev/null
+++ b/iso15118/evcc/asn1/archived/edp_asn1_main.py
@@ -0,0 +1,166 @@
+import esdp_asn1
+from pyasn1.type import univ, constraint
+from pyasn1.codec.der.encoder import encode
+from pyasn1.codec.der.decoder import decode
+from hexdump import hexdump
+
+# map extensionID value to class type for decoding
+# IDs 1-6 are based on draft of ISO15118-200
+# IDs > 6 are not defined in the document but are extrapolated from document section headers 
+extension_ID_map = {
+    1: esdp_asn1.ChargingInterface(), 
+    2: esdp_asn1.BasicSignaling(), 
+    3: esdp_asn1.IPv6Socket(),
+    4: esdp_asn1.HighLevelCommunication(), 
+    5: esdp_asn1.EMSPIdentifiers(),
+    6: esdp_asn1.DCChargingLimits(),
+    7: esdp_asn1.ConductiveChargingInterfaceLimitations(),
+    8: esdp_asn1.EVCharacteristics(),
+    9: esdp_asn1.ChargingStationCharacteristics()
+    }
+
+# Decodes top level Extensions object and then each Standard extensions payload and prints to console
+def full_decode(extensions_bin_rep):
+    ext_obj_decode, rest = decode(extensions_bin_rep,asn1Spec=esdp_asn1.Extensions())
+    print("Top level Extensions decode:")
+    print(ext_obj_decode.prettyPrint())
+
+    #print(ext_obj_decode['standardized'][0].prettyPrint())
+
+    print("Individual Std Ext Decode:")
+    for index in range(len(ext_obj_decode['standardized'])):
+        print(ext_obj_decode['standardized'][index].prettyPrint())
+        ext_id = ext_obj_decode['standardized'][index]['extensionID']
+        std_ext_value_decode, rest = decode(ext_obj_decode['standardized'][index]['extensionValue'],asn1Spec=extension_ID_map[ext_id])
+        indent = '\t'
+        print(indent + type(std_ext_value_decode).__name__)
+        print(indent + str(std_ext_value_decode).replace('\n','\n' + indent))
+        print("\n")
+
+
+
+# Initialized Standard extensions with object and extensionID
+chg_interface_ext = esdp_asn1.StandardizedExtension()
+chg_interface_ext['extensionID'] = 1
+basic_signal_ext = esdp_asn1.StandardizedExtension()
+basic_signal_ext['extensionID'] = 2
+ipv6_sock_ext = esdp_asn1.StandardizedExtension()
+ipv6_sock_ext['extensionID'] = 3
+hlc_ext = esdp_asn1.StandardizedExtension()
+hlc_ext['extensionID'] = 4
+emsp_ids_ext = esdp_asn1.StandardizedExtension()
+emsp_ids_ext['extensionID'] = 5
+dc_chg_limits_ext = esdp_asn1.StandardizedExtension()
+dc_chg_limits_ext['extensionID'] = 6
+
+# IDS aren't defined, utilizing section numbers
+con_chg_int_limits_ext = esdp_asn1.StandardizedExtension()
+con_chg_int_limits_ext['extensionID'] = 7
+ev_chars_ext = esdp_asn1.StandardizedExtension()
+ev_chars_ext['extensionID'] = 8
+evse_chars_ext = esdp_asn1.StandardizedExtension()
+evse_chars_ext['extensionID'] = 9
+
+
+### Set sample data for each extension and encode to OctetString ### 
+
+# Charging Interface Extension
+chg_interface = esdp_asn1.ChargingInterface(1)
+chg_interface_ext['extensionValue'] = univ.OctetString(encode(chg_interface))
+
+# Basic Signaling Extension
+basic_signal_proto = esdp_asn1.BasicSignalingProtocol(3) # 'iec61851-23-ED2'
+basic_signal = esdp_asn1.BasicSignaling()
+basic_signal.append(basic_signal_proto)
+basic_signal_ext['extensionValue'] = univ.OctetString(encode(basic_signal))
+
+# IPv6 socket Extension
+
+ipv6_sock = esdp_asn1.IPv6Socket()
+ipv6_sock['ipv6Address'] = univ.OctetString(hexValue="0000000000000000000000000000fe00").subtype(subtypeSpec=constraint.ValueSizeConstraint(16, 16))
+ipv6_sock['tcpPort'] = univ.OctetString(hexValue="00008080").subtype(subtypeSpec=constraint.ValueSizeConstraint(4, 4))
+ipv6_sock_ext['extensionValue'] = univ.OctetString(encode(ipv6_sock))
+
+# HLC Extension
+hlc_seq = esdp_asn1.HighLevelCommunication()
+hlc_tup1 = esdp_asn1.HighLevelCommunicationTuple()
+hlc_tup1['hlcProtocol'] = 1
+sec_prof_tuple = esdp_asn1.SecurityProfileTuple()
+sec_prof_tuple['securityProfile'] = 0
+auth_method = esdp_asn1.AuthorizationMethod(0) # eim
+energy_transfer = esdp_asn1.EnergyTransferMode(0)
+sec_prof_tuple['authorizationMethod'].append(auth_method)
+sec_prof_tuple['energyTransferMode'].append(energy_transfer)
+hlc_tup1['securityProfileTuple'].append(sec_prof_tuple)
+hlc_seq.append(hlc_tup1)
+hlc_ext['extensionValue'] = univ.OctetString(encode(hlc_seq))
+
+# EMSP Identifiers Extension
+emsp_id1 = esdp_asn1.EMSPIdentifier(hexValue="abcde0101") #adding trailing 0, not desireable
+emsp_id2 = esdp_asn1.EMSPIdentifier(hexValue="abcde0202")
+emsp_ids = esdp_asn1.EMSPIdentifiers()
+emsp_ids.extend([emsp_id1,emsp_id2])
+emsp_ids_ext['extensionValue'] = univ.OctetString(encode(emsp_ids))
+
+# DC charging limits Extension
+dc_chg_limits = esdp_asn1.DCChargingLimits()
+dc_chg_limits['maximumVoltage'] = 920
+dc_chg_limits['minimumVoltage'] = 250
+dc_chg_limits_ext['extensionValue'] = univ.OctetString(encode(dc_chg_limits))
+
+# Conductive charging interface limitations Extensions
+conductive_chg_int_limits = esdp_asn1.ConductiveChargingInterfaceLimitations()
+conductive_chg_int_limits['maximumContactorTemperature'] = 80
+con_chg_int_limits_ext['extensionValue'] = univ.OctetString(encode(conductive_chg_int_limits))
+
+# EV Characteristics Extensions
+ev_chars = esdp_asn1.EVCharacteristics()
+ev_chars['vehicleIdentificationNumber'] = univ.OctetString(hexValue='00112233445566778899aabbccddeeff00').subtype(subtypeSpec=constraint.ValueSizeConstraint(17, 17))
+ev_chars['evccSoftwareVersion'] = "v2.5.6_20241031"
+ev_chars_ext['extensionValue'] = univ.OctetString(encode(ev_chars))
+
+# Charging Station Characteristics Extensions
+chg_stn_char = esdp_asn1.ChargingStationCharacteristics()
+chg_stn_char['seccSoftwareVersion'] = "v3.1.0_beta"
+chg_stn_char['evseID'] = univ.OctetString(hexValue='5A0E').subtype(subtypeSpec=constraint.ValueSizeConstraint(1, esdp_asn1.MAX))
+evse_chars_ext['extensionValue'] = univ.OctetString(encode(chg_stn_char))
+
+### Create top level StandardExtensions and Extensions objects ###
+
+std_extensions = esdp_asn1.StandardizedExtensions()
+std_extensions.extend([chg_interface_ext,basic_signal_ext, ipv6_sock_ext, hlc_ext, emsp_ids_ext, dc_chg_limits_ext, con_chg_int_limits_ext, ev_chars_ext, evse_chars_ext])
+#external_extensions = esdp_asn1.ExternalExtensions()
+
+extensions = esdp_asn1.Extensions()
+extensions['standardized'] = std_extensions
+#print(extensions.prettyPrint())
+
+### Encode top level Extensions object, print to string and save to file ###
+bin_rep = encode(extensions)
+
+print("Hexdump of encoded Extensions:")
+hexdump(bin_rep)
+print(bin_rep)
+#full_decode(bin_rep)
+
+# write bytes to file
+with open("esdp_encoded.dat", "wb") as binary_file:
+    # Write bytes to file
+    binary_file.write(bin_rep)
+
+
+#############################################
+#################   Decode  #################
+#############################################
+
+# Decode from bytes string literal
+bin_rep_str = b'0\x81\xd40\x81\xd10\x08\x02\x01\x01\x04\x03\n\x01\x010\n\x02\x01\x02\x04\x050\x03\n\x01\x030\x1f\x02\x01\x03\x04\x1a0\x18\x04\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x00\x04\x04\x00\x00\x80\x800\x1d\x02\x01\x04\x04\x180\x160\x14\n\x01\x010\x0f0\r\n\x01\x000\x03\n\x01\x000\x03\n\x01\x000\x15\x02\x01\x05\x04\x100\x0e\x04\x05\xab\xcd\xe0\x10\x10\x04\x05\xab\xcd\xe0  0\x0f\x02\x01\x06\x04\n0\x08\x02\x02\x03\x98\x02\x02\x00\xfa0\n\x02\x01\x07\x04\x050\x03\x02\x01P0+\x02\x01\x08\x04&0$\x04\x11\x00\x11"3DUfw\x88\x99\xaa\xbb\xcc\xdd\xee\xff\x00\x0c\x0fv2.5.6_202410310\x18\x02\x01\t\x04\x130\x11\x04\x02Z\x0e\x0c\x0bv3.1.0_beta'
+#full_decode(bin_rep_str)
+
+
+# Decode from binary file
+filename = "C:/Users/ewatt/Box/ChargeX Root Folder/INTERNAL FOLDERS ONLY/Communications Task Force - Internal Folder/ESDP/ASN1 C/ASN1C_full_output.ber"
+
+with open(filename, 'rb') as file:
+    binary_data = file.read()
+    full_decode(binary_data)
\ No newline at end of file
diff --git a/iso15118/evcc/asn1/archived/esdp_asn1.py b/iso15118/evcc/asn1/archived/esdp_asn1.py
new file mode 100644
index 0000000..e176970
--- /dev/null
+++ b/iso15118/evcc/asn1/archived/esdp_asn1.py
@@ -0,0 +1,230 @@
+# Auto-generated by asn1ate v.0.6.1.dev0 from esdp_definitions.asn
+
+# (last modified on 2024-10-30 15:45:03.203826)
+
+
+# ISO15118-200
+from pyasn1.type import univ, char, namedtype, namedval, tag, constraint, useful
+
+MAX = 2^32 -1 # MAX is a defined concept in ASN.1, autogen didn't differentiate as expected to put in the real max value of the parent type (not all parent types have finite maximums defined)
+
+class AuthorizationMethod(univ.Enumerated):
+    pass
+
+
+AuthorizationMethod.namedValues = namedval.NamedValues(
+    ('eim', 0),
+    ('pnc-2', 1),
+    ('pnc-20', 2)
+)
+
+
+class BasicSignalingProtocol(univ.Enumerated):
+    pass
+
+
+BasicSignalingProtocol.namedValues = namedval.NamedValues(
+    ('iec61851-1-ED2', 0),
+    ('iec61851-1-ED3', 1),
+    ('iec61851-23-ED1', 2),
+    ('iec61851-23-ED2', 3)
+)
+
+
+class BasicSignaling(univ.SequenceOf):
+    pass
+
+
+BasicSignaling.componentType = BasicSignalingProtocol()
+BasicSignaling.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class ChargingInterface(univ.Enumerated):
+    pass
+
+
+ChargingInterface.namedValues = namedval.NamedValues(
+    ('nacs', 0),
+    ('ccs1', 1),
+    ('ccs2', 2),
+    ('chademo', 3),
+    ('chaoji', 4),
+    ('type-1', 5),
+    ('type-2', 6),
+    ('mcs', 7)
+)
+
+
+class ChargingStationCharacteristics(univ.Sequence):
+    pass
+
+
+ChargingStationCharacteristics.componentType = namedtype.NamedTypes(
+    namedtype.OptionalNamedType('evseID', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
+    namedtype.OptionalNamedType('seccSoftwareVersion', char.UTF8String().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class ConductiveChargingInterfaceLimitations(univ.Sequence):
+    pass
+
+
+ConductiveChargingInterfaceLimitations.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('maximumContactorTemperature', univ.Integer())
+)
+
+
+class DCChargingLimits(univ.Sequence):
+    pass
+
+
+DCChargingLimits.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('maximumVoltage', univ.Integer()),
+    namedtype.NamedType('minimumVoltage', univ.Integer())
+)
+
+
+class EMSPIdentifier(univ.OctetString):
+    pass
+
+
+EMSPIdentifier.subtypeSpec = constraint.ValueSizeConstraint(1, MAX)
+
+
+class EMSPIdentifiers(univ.SequenceOf):
+    pass
+
+
+EMSPIdentifiers.componentType = EMSPIdentifier()
+EMSPIdentifiers.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class EVCharacteristics(univ.Sequence):
+    pass
+
+
+EVCharacteristics.componentType = namedtype.NamedTypes(
+    namedtype.OptionalNamedType('vehicleIdentificationNumber', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(17, 17))),
+    namedtype.OptionalNamedType('evccSoftwareVersion', char.UTF8String().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class EnergyTransferMode(univ.Enumerated):
+    pass
+
+
+EnergyTransferMode.namedValues = namedval.NamedValues(
+    ('dc', 0),
+    ('dc-bpt', 1),
+    ('ac', 2),
+    ('ac-bpt', 3)
+)
+
+
+class ExternalExtension(univ.Sequence):
+    pass
+
+
+ExternalExtension.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('externalExtensionID', univ.ObjectIdentifier()),
+    namedtype.DefaultedNamedType('critical', univ.Boolean().subtype(value=1)),
+    namedtype.NamedType('extensionValue', univ.OctetString())
+)
+
+
+class ExternalExtensions(univ.SequenceOf):
+    pass
+
+
+ExternalExtensions.componentType = ExternalExtension()
+ExternalExtensions.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class StandardizedExtension(univ.Sequence):
+    pass
+
+
+StandardizedExtension.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('extensionID', univ.Integer()),
+    namedtype.NamedType('extensionValue', univ.OctetString())
+)
+
+
+class StandardizedExtensions(univ.SequenceOf):
+    pass
+
+
+StandardizedExtensions.componentType = StandardizedExtension()
+StandardizedExtensions.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class Extensions(univ.Sequence):
+    pass
+
+
+Extensions.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('standardized', StandardizedExtensions()),
+    namedtype.OptionalNamedType('external', ExternalExtensions())
+)
+
+
+class HLCProtocol(univ.Enumerated):
+    pass
+
+
+HLCProtocol.namedValues = namedval.NamedValues(
+    ('din-spec-70121-2014', 0),
+    ('iso-15118-2-2014', 1),
+    ('iso-15118-20-2022', 2),
+    ('sae-j2847-2-202309', 3)
+)
+
+
+class SecurityProfile(univ.Enumerated):
+    pass
+
+
+SecurityProfile.namedValues = namedval.NamedValues(
+    ('tcpOnly', 0),
+    ('tls12-server', 2),
+    ('tls13-mutual', 20)
+)
+
+
+class SecurityProfileTuple(univ.Sequence):
+    pass
+
+
+SecurityProfileTuple.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('securityProfile', SecurityProfile()),
+    namedtype.NamedType('authorizationMethod', univ.SequenceOf(componentType=AuthorizationMethod()).subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
+    namedtype.NamedType('energyTransferMode', univ.SequenceOf(componentType=EnergyTransferMode()).subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class HighLevelCommunicationTuple(univ.Sequence):
+    pass
+
+
+HighLevelCommunicationTuple.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('hlcProtocol', HLCProtocol()),
+    namedtype.NamedType('securityProfileTuple', univ.SequenceOf(componentType=SecurityProfileTuple()).subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class HighLevelCommunication(univ.SequenceOf):
+    pass
+
+
+HighLevelCommunication.componentType = HighLevelCommunicationTuple()
+HighLevelCommunication.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class IPv6Socket(univ.Sequence):
+    pass
+
+
+IPv6Socket.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('ipv6Address', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(16, 16))),
+    namedtype.NamedType('tcpPort', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(4, 4)))
+)
\ No newline at end of file
diff --git a/iso15118/evcc/asn1/archived/esdp_definitions.asn b/iso15118/evcc/asn1/archived/esdp_definitions.asn
new file mode 100644
index 0000000..1a6937c
--- /dev/null
+++ b/iso15118/evcc/asn1/archived/esdp_definitions.asn
@@ -0,0 +1,55 @@
+ISO15118-200 DEFINITIONS ::=
+BEGIN
+
+
+Extensions ::= SEQUENCE { 
+    standardized StandardizedExtensions, 
+    external ExternalExtensions OPTIONAL 
+
+}
+StandardizedExtensions ::= SEQUENCE (SIZE (1..MAX)) OF StandardizedExtension
+
+StandardizedExtension ::= SEQUENCE { 
+    extensionID INTEGER, 
+    extensionValue OCTET STRING 
+}
+
+ExternalExtensions ::= SEQUENCE (SIZE (1..MAX)) OF ExternalExtension
+
+ExternalExtension ::= SEQUENCE { 
+    externalExtensionID OBJECT IDENTIFIER, 
+    critical BOOLEAN DEFAULT TRUE, 
+    extensionValue OCTET STRING }
+
+-- StandardExtensions --
+
+
+
+ChargingInterface ::= ENUMERATED { nacs (0), ccs1 (1), ccs2 (2), chademo (3), chaoji (4), type-1 (5), type-2 (6), mcs (7) }
+
+BasicSignaling ::= SEQUENCE (SIZE (1..MAX)) OF BasicSignalingProtocol
+BasicSignalingProtocol ::= ENUMERATED { iec61851-1-ED2 (0), iec61851-1-ED3 (1), iec61851-23-ED1 (2), iec61851-23-ED2 (3) }
+
+IPv6Socket ::= SEQUENCE { ipv6Address OCTET STRING (SIZE (16)), tcpPort OCTET STRING (SIZE (4)) }
+
+HighLevelCommunication ::= SEQUENCE (SIZE (1..MAX)) OF HighLevelCommunicationTuple
+HighLevelCommunicationTuple ::= SEQUENCE { hlcProtocol HLCProtocol, securityProfileTuple SEQUENCE(SIZE (1..MAX)) OF SecurityProfileTuple }
+SecurityProfileTuple ::= SEQUENCE { securityProfile SecurityProfile, authorizationMethod SEQUENCE(SIZE (1..MAX)) OF AuthorizationMethod, energyTransferMode SEQUENCE(SIZE (1..MAX)) OF EnergyTransferMode, ... }
+HLCProtocol ::= ENUMERATED { din-spec-70121-2014 (0), iso-15118-2-2014 (1), iso-15118-20-2022 (2), sae-j2847-2-202309 (3) }
+SecurityProfile ::= ENUMERATED { tcpOnly (0), tls12-server (2), tls13-mutual (20) }
+AuthorizationMethod ::= ENUMERATED { eim (0), pnc-2 (1), pnc-20 (2) }
+EnergyTransferMode ::= ENUMERATED { dc (0), dc-bpt (1), ac (2), ac-bpt (3) }
+
+EMSPIdentifiers ::= SEQUENCE (SIZE (1..MAX)) OF EMSPIdentifier
+EMSPIdentifier ::= OCTET STRING (SIZE (1..MAX))
+
+DCChargingLimits ::= SEQUENCE { maximumVoltage INTEGER, minimumVoltage INTEGER, ... }
+
+ConductiveChargingInterfaceLimitations ::= SEQUENCE { maximumContactorTemperature INTEGER, ... }
+
+EVCharacteristics ::= SEQUENCE { vehicleIdentificationNumber OCTET STRING (SIZE (17)) OPTIONAL, evccSoftwareVersion UTF8String (SIZE (1..MAX)) OPTIONAL }
+
+ChargingStationCharacteristics ::= SEQUENCE { evseID OCTET STRING (SIZE (1..MAX)) OPTIONAL, seccSoftwareVersion UTF8String (SIZE (1..MAX)) OPTIONAL }
+
+END
+
diff --git a/iso15118/evcc/asn1/archived/esdp_encoded.dat b/iso15118/evcc/asn1/archived/esdp_encoded.dat
new file mode 100644
index 0000000..14f98aa
Binary files /dev/null and b/iso15118/evcc/asn1/archived/esdp_encoded.dat differ
diff --git a/iso15118/evcc/asn1/archived/requirements.txt b/iso15118/evcc/asn1/archived/requirements.txt
new file mode 100644
index 0000000..d3fa4ac
--- /dev/null
+++ b/iso15118/evcc/asn1/archived/requirements.txt
@@ -0,0 +1,2 @@
+hexdump==3.3
+pyasn1==0.4.8
diff --git a/iso15118/evcc/asn1/esdp_asn1.py b/iso15118/evcc/asn1/esdp_asn1.py
new file mode 100644
index 0000000..e176970
--- /dev/null
+++ b/iso15118/evcc/asn1/esdp_asn1.py
@@ -0,0 +1,230 @@
+# Auto-generated by asn1ate v.0.6.1.dev0 from esdp_definitions.asn
+
+# (last modified on 2024-10-30 15:45:03.203826)
+
+
+# ISO15118-200
+from pyasn1.type import univ, char, namedtype, namedval, tag, constraint, useful
+
+MAX = 2^32 -1 # MAX is a defined concept in ASN.1, autogen didn't differentiate as expected to put in the real max value of the parent type (not all parent types have finite maximums defined)
+
+class AuthorizationMethod(univ.Enumerated):
+    pass
+
+
+AuthorizationMethod.namedValues = namedval.NamedValues(
+    ('eim', 0),
+    ('pnc-2', 1),
+    ('pnc-20', 2)
+)
+
+
+class BasicSignalingProtocol(univ.Enumerated):
+    pass
+
+
+BasicSignalingProtocol.namedValues = namedval.NamedValues(
+    ('iec61851-1-ED2', 0),
+    ('iec61851-1-ED3', 1),
+    ('iec61851-23-ED1', 2),
+    ('iec61851-23-ED2', 3)
+)
+
+
+class BasicSignaling(univ.SequenceOf):
+    pass
+
+
+BasicSignaling.componentType = BasicSignalingProtocol()
+BasicSignaling.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class ChargingInterface(univ.Enumerated):
+    pass
+
+
+ChargingInterface.namedValues = namedval.NamedValues(
+    ('nacs', 0),
+    ('ccs1', 1),
+    ('ccs2', 2),
+    ('chademo', 3),
+    ('chaoji', 4),
+    ('type-1', 5),
+    ('type-2', 6),
+    ('mcs', 7)
+)
+
+
+class ChargingStationCharacteristics(univ.Sequence):
+    pass
+
+
+ChargingStationCharacteristics.componentType = namedtype.NamedTypes(
+    namedtype.OptionalNamedType('evseID', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
+    namedtype.OptionalNamedType('seccSoftwareVersion', char.UTF8String().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class ConductiveChargingInterfaceLimitations(univ.Sequence):
+    pass
+
+
+ConductiveChargingInterfaceLimitations.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('maximumContactorTemperature', univ.Integer())
+)
+
+
+class DCChargingLimits(univ.Sequence):
+    pass
+
+
+DCChargingLimits.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('maximumVoltage', univ.Integer()),
+    namedtype.NamedType('minimumVoltage', univ.Integer())
+)
+
+
+class EMSPIdentifier(univ.OctetString):
+    pass
+
+
+EMSPIdentifier.subtypeSpec = constraint.ValueSizeConstraint(1, MAX)
+
+
+class EMSPIdentifiers(univ.SequenceOf):
+    pass
+
+
+EMSPIdentifiers.componentType = EMSPIdentifier()
+EMSPIdentifiers.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class EVCharacteristics(univ.Sequence):
+    pass
+
+
+EVCharacteristics.componentType = namedtype.NamedTypes(
+    namedtype.OptionalNamedType('vehicleIdentificationNumber', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(17, 17))),
+    namedtype.OptionalNamedType('evccSoftwareVersion', char.UTF8String().subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class EnergyTransferMode(univ.Enumerated):
+    pass
+
+
+EnergyTransferMode.namedValues = namedval.NamedValues(
+    ('dc', 0),
+    ('dc-bpt', 1),
+    ('ac', 2),
+    ('ac-bpt', 3)
+)
+
+
+class ExternalExtension(univ.Sequence):
+    pass
+
+
+ExternalExtension.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('externalExtensionID', univ.ObjectIdentifier()),
+    namedtype.DefaultedNamedType('critical', univ.Boolean().subtype(value=1)),
+    namedtype.NamedType('extensionValue', univ.OctetString())
+)
+
+
+class ExternalExtensions(univ.SequenceOf):
+    pass
+
+
+ExternalExtensions.componentType = ExternalExtension()
+ExternalExtensions.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class StandardizedExtension(univ.Sequence):
+    pass
+
+
+StandardizedExtension.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('extensionID', univ.Integer()),
+    namedtype.NamedType('extensionValue', univ.OctetString())
+)
+
+
+class StandardizedExtensions(univ.SequenceOf):
+    pass
+
+
+StandardizedExtensions.componentType = StandardizedExtension()
+StandardizedExtensions.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class Extensions(univ.Sequence):
+    pass
+
+
+Extensions.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('standardized', StandardizedExtensions()),
+    namedtype.OptionalNamedType('external', ExternalExtensions())
+)
+
+
+class HLCProtocol(univ.Enumerated):
+    pass
+
+
+HLCProtocol.namedValues = namedval.NamedValues(
+    ('din-spec-70121-2014', 0),
+    ('iso-15118-2-2014', 1),
+    ('iso-15118-20-2022', 2),
+    ('sae-j2847-2-202309', 3)
+)
+
+
+class SecurityProfile(univ.Enumerated):
+    pass
+
+
+SecurityProfile.namedValues = namedval.NamedValues(
+    ('tcpOnly', 0),
+    ('tls12-server', 2),
+    ('tls13-mutual', 20)
+)
+
+
+class SecurityProfileTuple(univ.Sequence):
+    pass
+
+
+SecurityProfileTuple.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('securityProfile', SecurityProfile()),
+    namedtype.NamedType('authorizationMethod', univ.SequenceOf(componentType=AuthorizationMethod()).subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX))),
+    namedtype.NamedType('energyTransferMode', univ.SequenceOf(componentType=EnergyTransferMode()).subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class HighLevelCommunicationTuple(univ.Sequence):
+    pass
+
+
+HighLevelCommunicationTuple.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('hlcProtocol', HLCProtocol()),
+    namedtype.NamedType('securityProfileTuple', univ.SequenceOf(componentType=SecurityProfileTuple()).subtype(subtypeSpec=constraint.ValueSizeConstraint(1, MAX)))
+)
+
+
+class HighLevelCommunication(univ.SequenceOf):
+    pass
+
+
+HighLevelCommunication.componentType = HighLevelCommunicationTuple()
+HighLevelCommunication.subtypeSpec=constraint.ValueSizeConstraint(1, MAX)
+
+
+class IPv6Socket(univ.Sequence):
+    pass
+
+
+IPv6Socket.componentType = namedtype.NamedTypes(
+    namedtype.NamedType('ipv6Address', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(16, 16))),
+    namedtype.NamedType('tcpPort', univ.OctetString().subtype(subtypeSpec=constraint.ValueSizeConstraint(4, 4)))
+)
\ No newline at end of file
diff --git a/iso15118/evcc/asn1/esdp_asn1_main.py b/iso15118/evcc/asn1/esdp_asn1_main.py
new file mode 100644
index 0000000..9f99b57
--- /dev/null
+++ b/iso15118/evcc/asn1/esdp_asn1_main.py
@@ -0,0 +1,229 @@
+from iso15118.evcc.asn1 import esdp_asn1
+from pyasn1.type import univ, constraint
+from pyasn1.codec.der.encoder import encode
+from pyasn1.codec.der.decoder import decode
+from hexdump import hexdump
+import os
+import logging
+logger = logging.getLogger(__name__)
+
+def encode_data():
+    # map extensionID value to class type for decoding
+    # IDs 1-6 are based on draft of ISO15118-200
+    # IDs > 6 are not defined in the document but are extrapolated from document section headers 
+    extension_ID_map = {
+        1: esdp_asn1.ChargingInterface(), 
+        2: esdp_asn1.BasicSignaling(), 
+        3: esdp_asn1.IPv6Socket(),
+        4: esdp_asn1.HighLevelCommunication(), 
+        5: esdp_asn1.EMSPIdentifiers(),
+        6: esdp_asn1.DCChargingLimits(),
+        7: esdp_asn1.ConductiveChargingInterfaceLimitations(),
+        8: esdp_asn1.EVCharacteristics(),
+        9: esdp_asn1.ChargingStationCharacteristics()
+        }
+
+
+    # Initialized Standard extensions with object and extensionID
+    chg_interface_ext = esdp_asn1.StandardizedExtension()
+    chg_interface_ext['extensionID'] = 1
+    basic_signal_ext = esdp_asn1.StandardizedExtension()
+    basic_signal_ext['extensionID'] = 2
+    ipv6_sock_ext = esdp_asn1.StandardizedExtension()
+    ipv6_sock_ext['extensionID'] = 3
+    hlc_ext = esdp_asn1.StandardizedExtension()
+    hlc_ext['extensionID'] = 4
+    emsp_ids_ext = esdp_asn1.StandardizedExtension()
+    emsp_ids_ext['extensionID'] = 5
+    dc_chg_limits_ext = esdp_asn1.StandardizedExtension()
+    dc_chg_limits_ext['extensionID'] = 6
+
+    # IDS aren't defined, utilizing section numbers
+    con_chg_int_limits_ext = esdp_asn1.StandardizedExtension()
+    con_chg_int_limits_ext['extensionID'] = 7
+    ev_chars_ext = esdp_asn1.StandardizedExtension()
+    ev_chars_ext['extensionID'] = 8
+    evse_chars_ext = esdp_asn1.StandardizedExtension()
+    evse_chars_ext['extensionID'] = 9
+
+
+    ### Set sample data for each extension and encode to OctetString ### 
+
+    # Charging Interface Extension
+    chg_interface = esdp_asn1.ChargingInterface(1)
+    chg_interface_ext['extensionValue'] = univ.OctetString(encode(chg_interface))
+
+    # Basic Signaling Extension
+    basic_signal_proto = esdp_asn1.BasicSignalingProtocol(3) # 'iec61851-23-ED2'
+    basic_signal = esdp_asn1.BasicSignaling()
+    basic_signal.append(basic_signal_proto)
+    basic_signal_ext['extensionValue'] = univ.OctetString(encode(basic_signal))
+
+    # IPv6 socket Extension
+
+    # Not required for ESDPReq Packet
+    ipv6_sock = esdp_asn1.IPv6Socket()
+    ipv6_sock['ipv6Address'] = univ.OctetString(hexValue="0000000000000000000000000000fe00").subtype(subtypeSpec=constraint.ValueSizeConstraint(16, 16))
+    ipv6_sock['tcpPort'] = univ.OctetString(hexValue="00008080").subtype(subtypeSpec=constraint.ValueSizeConstraint(4, 4))
+    ipv6_sock_ext['extensionValue'] = univ.OctetString(encode(ipv6_sock))
+
+    # HLC Extension
+    hlc_seq = esdp_asn1.HighLevelCommunication()
+    hlc_tup1 = esdp_asn1.HighLevelCommunicationTuple()
+    hlc_tup1['hlcProtocol'] = 1
+    sec_prof_tuple = esdp_asn1.SecurityProfileTuple()
+    sec_prof_tuple['securityProfile'] = 0
+    auth_method = esdp_asn1.AuthorizationMethod(0) # eim
+    energy_transfer = esdp_asn1.EnergyTransferMode(0)
+    sec_prof_tuple['authorizationMethod'].append(auth_method)
+    sec_prof_tuple['energyTransferMode'].append(energy_transfer)
+    hlc_tup1['securityProfileTuple'].append(sec_prof_tuple)
+    hlc_seq.append(hlc_tup1)
+    hlc_ext['extensionValue'] = univ.OctetString(encode(hlc_seq))
+
+    # EMSP Identifiers Extension
+
+    emsp_id1 = esdp_asn1.EMSPIdentifier(hexValue="abcde0101") #adding trailing 0, not desireable
+    emsp_id2 = esdp_asn1.EMSPIdentifier(hexValue="abcde0202")
+    emsp_ids = esdp_asn1.EMSPIdentifiers()
+    emsp_ids.extend([emsp_id1,emsp_id2])
+    emsp_ids_ext['extensionValue'] = univ.OctetString(encode(emsp_ids))
+
+    # DC charging limits Extension
+    dc_chg_limits = esdp_asn1.DCChargingLimits()
+    dc_chg_limits['maximumVoltage'] = 920
+    dc_chg_limits['minimumVoltage'] = 250
+    dc_chg_limits_ext['extensionValue'] = univ.OctetString(encode(dc_chg_limits))
+
+    # Conductive charging interface limitations Extensions
+    conductive_chg_int_limits = esdp_asn1.ConductiveChargingInterfaceLimitations()
+    conductive_chg_int_limits['maximumContactorTemperature'] = 80
+    con_chg_int_limits_ext['extensionValue'] = univ.OctetString(encode(conductive_chg_int_limits))
+
+    # EV Characteristics Extensions
+    ev_chars = esdp_asn1.EVCharacteristics()
+    ev_chars['vehicleIdentificationNumber'] = univ.OctetString(hexValue='00112233445566778899aabbccddeeff00').subtype(subtypeSpec=constraint.ValueSizeConstraint(17, 17))
+    ev_chars['evccSoftwareVersion'] = "v2.5.6_20241031"
+    ev_chars_ext['extensionValue'] = univ.OctetString(encode(ev_chars))
+
+    # Charging Station Characteristics Extensions
+    chg_stn_char = esdp_asn1.ChargingStationCharacteristics()
+    chg_stn_char['seccSoftwareVersion'] = "v3.1.0_beta"
+    chg_stn_char['evseID'] = univ.OctetString(hexValue='5A0E').subtype(subtypeSpec=constraint.ValueSizeConstraint(1, esdp_asn1.MAX))
+    evse_chars_ext['extensionValue'] = univ.OctetString(encode(chg_stn_char))
+
+    ### Create top level StandardExtensions and Extensions objects ###
+
+    std_extensions = esdp_asn1.StandardizedExtensions()
+    #std_extensions.extend([chg_interface_ext,basic_signal_ext, ipv6_sock_ext, hlc_ext, emsp_ids_ext, dc_chg_limits_ext, con_chg_int_limits_ext, ev_chars_ext, evse_chars_ext])
+    std_extensions.extend([chg_interface_ext,basic_signal_ext, hlc_ext, dc_chg_limits_ext, con_chg_int_limits_ext, ev_chars_ext])
+    #external_extensions = esdp_asn1.ExternalExtensions()
+
+    extensions = esdp_asn1.Extensions()
+    extensions['standardized'] = std_extensions
+    #print(extensions.prettyPrint())
+
+    ### Encode top level Extensions object, print to string and save to file ###
+    bin_rep = encode(extensions)
+
+    #print("Hexdump of encoded Extensions:")
+    #hexdump(bin_rep)
+    #print(bin_rep)
+    #full_decode(bin_rep)
+
+    # write bytes to file
+    with open("esdp_encoded.dat", "wb") as binary_file:
+        # Write bytes to file
+        binary_file.write(bin_rep)
+    
+    file_size = os.path.getsize(os.getcwd()+"/esdp_encoded.dat")
+
+    logger.info(f'ASN1 file written to esdp_encoded.dat at {os.getcwd()}')
+    logger.info(f'File is of size {file_size}')
+
+
+    return bin_rep, file_size
+
+def decode_data(esdp_extensions):
+
+    extension_ID_map = {
+    1: esdp_asn1.ChargingInterface(), 
+    2: esdp_asn1.BasicSignaling(), 
+    3: esdp_asn1.IPv6Socket(),
+    4: esdp_asn1.HighLevelCommunication(), 
+    5: esdp_asn1.EMSPIdentifiers(),
+    6: esdp_asn1.DCChargingLimits(),
+    7: esdp_asn1.ConductiveChargingInterfaceLimitations(),
+    8: esdp_asn1.EVCharacteristics(),
+    9: esdp_asn1.ChargingStationCharacteristics()
+    }
+
+    #filename = "./esdp_encoded.dat" # remove later
+
+    #with open(filename, 'rb') as file:
+        #esdp_extensions = file.read() # remove later
+
+    ext_obj_decode, rest = decode(esdp_extensions,asn1Spec=esdp_asn1.Extensions())
+
+        # print("Top level Extensions decode:")
+        # print(ext_obj_decode.prettyPrint())
+
+        # print(ext_obj_decode['standardized'][0].prettyPrint())
+
+        # print("Individual Std Ext Decode:")
+    for index in range(len(ext_obj_decode['standardized'])):
+        #print(ext_obj_decode['standardized'][index].prettyPrint())
+        ext_id = ext_obj_decode['standardized'][index]['extensionID']
+        std_ext_value_decode, rest = decode(ext_obj_decode['standardized'][index]['extensionValue'],asn1Spec=extension_ID_map[ext_id])
+        
+        if isinstance(std_ext_value_decode, esdp_asn1.IPv6Socket):
+            ipv6addr = std_ext_value_decode['ipv6Address']
+            # print(bytes(ipv6))
+            prt = std_ext_value_decode['tcpPort']
+            # print(int.from_bytes(bytes(prt),'big'))
+
+        if isinstance(std_ext_value_decode, esdp_asn1.HighLevelCommunication):
+            sec = std_ext_value_decode[0][1][0][0]
+
+        # indent = '\t'
+        # print({indent + type(std_ext_value_decode).__name__})
+        # print(indent + str(std_ext_value_decode).replace('\n','\n' + indent))
+        # print("\n")
+
+    return [prt,ipv6addr,sec]
+"""
+#############################################
+#################   Decode  #################
+#############################################
+
+
+# Decodes top level Extensions object and then each Standard extensions payload and prints to console
+def full_decode(extensions_bin_rep):
+    ext_obj_decode, rest = decode(extensions_bin_rep,asn1Spec=esdp_asn1.Extensions())
+    print("Top level Extensions decode:")
+    print(ext_obj_decode.prettyPrint())
+
+    #print(ext_obj_decode['standardized'][0].prettyPrint())
+
+    print("Individual Std Ext Decode:")
+    for index in range(len(ext_obj_decode['standardized'])):
+        print(ext_obj_decode['standardized'][index].prettyPrint())
+        ext_id = ext_obj_decode['standardized'][index]['extensionID']
+        std_ext_value_decode, rest = decode(ext_obj_decode['standardized'][index]['extensionValue'],asn1Spec=extension_ID_map[ext_id])
+        indent = '\t'
+        print(indent + type(std_ext_value_decode).__name__)
+        print(indent + str(std_ext_value_decode).replace('\n','\n' + indent))
+        print("\n")
+
+# Decode from bytes string literal
+bin_rep_str = b'0\x81\xd40\x81\xd10\x08\x02\x01\x01\x04\x03\n\x01\x010\n\x02\x01\x02\x04\x050\x03\n\x01\x030\x1f\x02\x01\x03\x04\x1a0\x18\x04\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x00\x04\x04\x00\x00\x80\x800\x1d\x02\x01\x04\x04\x180\x160\x14\n\x01\x010\x0f0\r\n\x01\x000\x03\n\x01\x000\x03\n\x01\x000\x15\x02\x01\x05\x04\x100\x0e\x04\x05\xab\xcd\xe0\x10\x10\x04\x05\xab\xcd\xe0  0\x0f\x02\x01\x06\x04\n0\x08\x02\x02\x03\x98\x02\x02\x00\xfa0\n\x02\x01\x07\x04\x050\x03\x02\x01P0+\x02\x01\x08\x04&0$\x04\x11\x00\x11"3DUfw\x88\x99\xaa\xbb\xcc\xdd\xee\xff\x00\x0c\x0fv2.5.6_202410310\x18\x02\x01\t\x04\x130\x11\x04\x02Z\x0e\x0c\x0bv3.1.0_beta'
+#full_decode(bin_rep_str)
+
+
+# Decode from binary file
+filename = "C:/Users/ewatt/Box/ChargeX Root Folder/INTERNAL FOLDERS ONLY/Communications Task Force - Internal Folder/ESDP/ASN1 C/ASN1C_full_output.ber"
+
+with open(filename, 'rb') as file:
+    binary_data = file.read()
+    full_decode(binary_data)
+"""
\ No newline at end of file
diff --git a/iso15118/evcc/asn1/esdp_definitions.asn b/iso15118/evcc/asn1/esdp_definitions.asn
new file mode 100644
index 0000000..1a6937c
--- /dev/null
+++ b/iso15118/evcc/asn1/esdp_definitions.asn
@@ -0,0 +1,55 @@
+ISO15118-200 DEFINITIONS ::=
+BEGIN
+
+
+Extensions ::= SEQUENCE { 
+    standardized StandardizedExtensions, 
+    external ExternalExtensions OPTIONAL 
+
+}
+StandardizedExtensions ::= SEQUENCE (SIZE (1..MAX)) OF StandardizedExtension
+
+StandardizedExtension ::= SEQUENCE { 
+    extensionID INTEGER, 
+    extensionValue OCTET STRING 
+}
+
+ExternalExtensions ::= SEQUENCE (SIZE (1..MAX)) OF ExternalExtension
+
+ExternalExtension ::= SEQUENCE { 
+    externalExtensionID OBJECT IDENTIFIER, 
+    critical BOOLEAN DEFAULT TRUE, 
+    extensionValue OCTET STRING }
+
+-- StandardExtensions --
+
+
+
+ChargingInterface ::= ENUMERATED { nacs (0), ccs1 (1), ccs2 (2), chademo (3), chaoji (4), type-1 (5), type-2 (6), mcs (7) }
+
+BasicSignaling ::= SEQUENCE (SIZE (1..MAX)) OF BasicSignalingProtocol
+BasicSignalingProtocol ::= ENUMERATED { iec61851-1-ED2 (0), iec61851-1-ED3 (1), iec61851-23-ED1 (2), iec61851-23-ED2 (3) }
+
+IPv6Socket ::= SEQUENCE { ipv6Address OCTET STRING (SIZE (16)), tcpPort OCTET STRING (SIZE (4)) }
+
+HighLevelCommunication ::= SEQUENCE (SIZE (1..MAX)) OF HighLevelCommunicationTuple
+HighLevelCommunicationTuple ::= SEQUENCE { hlcProtocol HLCProtocol, securityProfileTuple SEQUENCE(SIZE (1..MAX)) OF SecurityProfileTuple }
+SecurityProfileTuple ::= SEQUENCE { securityProfile SecurityProfile, authorizationMethod SEQUENCE(SIZE (1..MAX)) OF AuthorizationMethod, energyTransferMode SEQUENCE(SIZE (1..MAX)) OF EnergyTransferMode, ... }
+HLCProtocol ::= ENUMERATED { din-spec-70121-2014 (0), iso-15118-2-2014 (1), iso-15118-20-2022 (2), sae-j2847-2-202309 (3) }
+SecurityProfile ::= ENUMERATED { tcpOnly (0), tls12-server (2), tls13-mutual (20) }
+AuthorizationMethod ::= ENUMERATED { eim (0), pnc-2 (1), pnc-20 (2) }
+EnergyTransferMode ::= ENUMERATED { dc (0), dc-bpt (1), ac (2), ac-bpt (3) }
+
+EMSPIdentifiers ::= SEQUENCE (SIZE (1..MAX)) OF EMSPIdentifier
+EMSPIdentifier ::= OCTET STRING (SIZE (1..MAX))
+
+DCChargingLimits ::= SEQUENCE { maximumVoltage INTEGER, minimumVoltage INTEGER, ... }
+
+ConductiveChargingInterfaceLimitations ::= SEQUENCE { maximumContactorTemperature INTEGER, ... }
+
+EVCharacteristics ::= SEQUENCE { vehicleIdentificationNumber OCTET STRING (SIZE (17)) OPTIONAL, evccSoftwareVersion UTF8String (SIZE (1..MAX)) OPTIONAL }
+
+ChargingStationCharacteristics ::= SEQUENCE { evseID OCTET STRING (SIZE (1..MAX)) OPTIONAL, seccSoftwareVersion UTF8String (SIZE (1..MAX)) OPTIONAL }
+
+END
+
diff --git a/iso15118/evcc/asn1/esdp_encoded.dat b/iso15118/evcc/asn1/esdp_encoded.dat
new file mode 100644
index 0000000..14f98aa
Binary files /dev/null and b/iso15118/evcc/asn1/esdp_encoded.dat differ
diff --git a/iso15118/evcc/comm_session_handler.py b/iso15118/evcc/comm_session_handler.py
index 0590888..a458900 100644
--- a/iso15118/evcc/comm_session_handler.py
+++ b/iso15118/evcc/comm_session_handler.py
@@ -39,6 +39,7 @@ from iso15118.shared.messages.enums import (
     ISOV20PayloadTypes,
     Namespace,
     Protocol,
+    UINT_32_MAX
 )
 from iso15118.shared.messages.iso15118_2.datatypes import (
     ChargingSession as ChargingSessionV2,
@@ -52,7 +53,7 @@ from iso15118.shared.messages.iso15118_20.common_messages import (
     ScheduleExchangeRes,
 )
 from iso15118.shared.messages.iso15118_20.common_types import Processing
-from iso15118.shared.messages.sdp import SDPRequest, SDPResponse, Security, Transport
+from iso15118.shared.messages.sdp import SDPRequest, SDPResponse, Security, Transport, ESDPRequest, ESDPResponse
 from iso15118.shared.messages.timeouts import Timeouts
 from iso15118.shared.messages.v2gtp import V2GTPMessage
 from iso15118.shared.notifications import (
@@ -62,9 +63,12 @@ from iso15118.shared.notifications import (
 )
 from iso15118.shared.utils import cancel_task, wait_for_tasks
 
+from iso15118.evcc.asn1 import esdp_asn1_main
+
 logger = logging.getLogger(__name__)
 
-SDP_MAX_REQUEST_COUNTER = 50
+ESDP_MAX_REQUEST_COUNTER = 5 # Changed from 50 by PG & MS
+SDP_MAX_REQUEST_COUNTER = 35 # Changed from 50 by PG & MS
 
 
 class EVCCCommunicationSession(V2GCommunicationSession):
@@ -286,8 +290,10 @@ class CommunicationSessionHandler:
         self.config: EVCCConfig = config
         self.iface: str = iface
         self.ev_controller: EVControllerInterface = ev_controller
+        self.esdp_retries_number = ESDP_MAX_REQUEST_COUNTER
         self.sdp_retries_number = SDP_MAX_REQUEST_COUNTER
         self._sdp_retry_cycles = self.config.sdp_retry_cycles
+        self._esdp_retry_cycles = 35 # changed by MS
 
         # Set the selected EXI codec implementation
         EXI().set_exi_codec(codec)
@@ -339,6 +345,30 @@ class CommunicationSessionHandler:
         logger.info(f"Sending SDPRequest: {sdp_request}")
         await self.udp_client.send_and_receive(v2gtp_msg)
 
+    async def send_esdp(self):
+        """
+        Sends an SECC Discovery Protocol Request (SDP Request) via UDP to
+        the SECC to retrieve the IP address and port of the SECC so that we
+        can establish a TCP connection to the SECC's TCP server, given the
+        IP address and port contained in the SDP Response
+        """
+        # the following loop is to allow the synchronization of the udp client
+        # and the task to handle the SDP restart
+        while not self.udp_client.started:
+            await asyncio.sleep(0.1)
+
+        esdp_extensions, file_size = esdp_asn1_main.encode_data()
+
+        logger.info(f"ESDP packet size is {file_size} bytes")
+
+        esdp_request = ESDPRequest(esdp_version=0x0100,max_payload_size=0x0100,esdp_extensions=esdp_extensions) # update this as needed
+        logger.info(f"Sending ESDPRequest: {esdp_request}")
+        v2gtp_msg = V2GTPMessage(
+            Protocol.UNKNOWN, 0x2000, esdp_request.to_payload()
+        )
+        
+        await self.udp_client.send_and_receive_esdp(v2gtp_msg)
+
     async def restart_sdp(self, new_sdp_cycle: bool):
         """
         Initiates a new SECC Discovery Protocol (SDP) request message, which the
@@ -353,7 +383,7 @@ class CommunicationSessionHandler:
 
         The constant SDP_MAX_REQUEST_COUNTER is used to compare the current
         SDP request counter with the maximum allowed number of SDP requests in
-        one go (50).
+        one go (35).
 
         However, once SDP was successful and the ISO 15118 communication
         proceeds, an error can occur later while processing one of the messages.
@@ -379,39 +409,46 @@ class CommunicationSessionHandler:
             SDPFailedError
         """
         shutdown_msg = (
-            "Shutting down high-level communication. Unplug and "
+            "ESDP and SDP failed to setup communication. Shutting down high-level communication. Unplug and "
             "plug in the cable again if you want to start anew."
         )
 
         if new_sdp_cycle:
-            if self._sdp_retry_cycles == 0:
-                raise SDPFailedError(
-                    f"EVCC tried to initiate a V2GCommunicationSession, "
-                    f"but maximum number of SDP retry cycles "
-                    f"({self.config.sdp_retry_cycles}) is now reached. {shutdown_msg}"
-                )
-
-            self._sdp_retry_cycles -= 1
-            self.sdp_retries_number = SDP_MAX_REQUEST_COUNTER
+            if self._esdp_retry_cycles == 0:
+            	raise SDPFailedError(
+            	f"EVCC tried to initiate a V2GCommunicationSession, "
+            	"but maximum number of ESDP retry cycles "
+            	"({self.esdp_retry_cycles}) is now reached. {shutdown_msg}"
+            	)
+
+            self._esdp_retry_cycles -= 1
+            self.esdp_retries_number = ESDP_MAX_REQUEST_COUNTER
             logger.debug(
-                "Initiating new SDP cycle, "
-                f"{self._sdp_retry_cycles} more cycles(s) left"
+                "Initiating new ESDP cycle, "
+                f"{self._esdp_retry_cycles} more cycles(s) left"
             )
 
-        if self.sdp_retries_number > 0:
-            logger.info(f"Remaining SDP requests: {self.sdp_retries_number}")
+        if self.esdp_retries_number > 0:
+            logger.info(f"Remaining ESDP requests: {self.esdp_retries_number}")
             try:
-                await self.send_sdp()
+                await self.send_esdp()
+                logger.info("Sending ESDP Request")
             except InvalidSettingsValueError as exc:
                 logger.error(
                     f"Invalid value for {exc.entity} setting "
                     f"{exc.setting}: {exc.invalid_value}"
                 )
 
-            self.sdp_retries_number -= 1
+            self.esdp_retries_number -= 1
         else:
-            self.sdp_retries_number = SDP_MAX_REQUEST_COUNTER
-            raise SDPFailedError(f"SDPRequest was not successful. " f"{shutdown_msg}")
+            logger.error("Failed ESDP, now re-trying using SDP.")
+            if self.sdp_retries_number > 0:
+                await self.send_sdp()
+                logger.info("Sending regular SDP Request")
+                self.sdp_retries_number-=1
+
+            else:       
+                raise SDPFailedError(f"SDPRequest was not successful. " f"{shutdown_msg}")
 
     async def start_comm_session(self, host: IPv6Address, port: int, is_tls: bool):
         server_type = "TLS" if is_tls else "TCP"
@@ -519,6 +556,56 @@ class CommunicationSessionHandler:
             ip_address_int = int.from_bytes(sdp_response.ip_address, "big")
             host = IPv6Address(ip_address_int)
             port = sdp_response.port
+
+        elif v2gtp_msg.payload_type in [
+            ISOV2PayloadTypes.ESDP_RESPONSE,
+        ]:
+            try:
+                esdp_response = ESDPResponse.from_payload(v2gtp_msg.payload)
+            except InvalidSDPResponseError as exc:
+                logger.error(exc)
+                try:
+                    await self.restart_sdp(True)
+                    return
+                except SDPFailedError as exc:
+
+                    logger.exception(exc)
+                    return  # TODO check if this is correct here
+
+            logger.info(f"ESDPResponse received: {esdp_response}")
+
+            secc_signals_tls = False
+            if esdp_response.security == Security.TLS:
+                secc_signals_tls = True
+
+            # The idea here is to use both the USE_TLS and ENFORCE_TLS setting of the
+            # EVCC. USE_TLS can be used to set the Security byte field of the SDP
+            # request to either 0x00 (TLS) or 0x10 (no NO_TLS). It's basically there
+            # just to test both use cases.
+            #
+            # The ENFORCE_SECURITY setting can be used by the EV OEM to make sure the EV
+            # only accepts TLS-secured communication sessions, if set to True. If set
+            # to False, and USE_TLS is set to True, then the EVCC can also accept an
+            # unsecure communication (triggered by the SECC sending an SDP response with
+            # the Security byte field set to 0x10 (no NO_TLS)).
+            #
+            # The rationale behind this might be that the EV OEM trades convenience
+            # (the EV driver can always charge) over security.
+            if (not secc_signals_tls and self.config.enforce_tls) or (
+                secc_signals_tls and not self.config.use_tls
+            ):
+                logger.error(
+                    "Security mismatch, can't initiate communication session."
+                    f"\nEVCC setting USE_TLS: {self.config.use_tls}"
+                    f"\nEVCC setting ENFORCE_TLS: {self.config.enforce_tls}"
+                    f"\nSDP response signals TLS: {secc_signals_tls}"
+                )
+                return
+
+            ip_address_int = int.from_bytes(esdp_response.ip_address, "big")
+            host = IPv6Address(ip_address_int)
+            port = esdp_response.port
+
         elif v2gtp_msg.payload_type == ISOV20PayloadTypes.SDP_RESPONSE_WIRELESS:
             raise NotImplementedError(
                 "The incoming datagram seems to be a SDPResponse "
diff --git a/iso15118/evcc/evcc_config.py b/iso15118/evcc/evcc_config.py
index e9c7ac4..93cc974 100644
--- a/iso15118/evcc/evcc_config.py
+++ b/iso15118/evcc/evcc_config.py
@@ -21,8 +21,8 @@ logger = logging.getLogger(__name__)
 
 class EVCCConfig(BaseModel):
     _default_protocols = [
-        "DIN_SPEC_70121",
         "ISO_15118_2",
+        "DIN_SPEC_70121",
         "ISO_15118_20_AC",
         "ISO_15118_20_DC",
     ]
diff --git a/iso15118/evcc/transport/udp_client.py b/iso15118/evcc/transport/udp_client.py
index 4bec245..17c98bb 100644
--- a/iso15118/evcc/transport/udp_client.py
+++ b/iso15118/evcc/transport/udp_client.py
@@ -7,7 +7,7 @@ from typing import Optional, Tuple
 
 from iso15118.shared.messages.timeouts import Timeouts
 from iso15118.shared.messages.v2gtp import V2GTPMessage
-from iso15118.shared.network import SDP_MULTICAST_GROUP, SDP_SERVER_PORT
+from iso15118.shared.network import SDP_MULTICAST_GROUP, SDP_SERVER_PORT, ESDP_SERVER_PORT
 from iso15118.shared.notifications import (
     ReceiveTimeoutNotification,
     UDPPacketNotification,
@@ -169,6 +169,14 @@ class UDPClient(DatagramProtocol):
 
         logger.debug(f"Message sent: {message}")
 
+    def send_esdp(self, message: V2GTPMessage):
+        self._transport.sendto(
+            message.to_bytes(), (SDP_MULTICAST_GROUP, ESDP_SERVER_PORT)
+        )
+
+        logger.debug(f"Message sent: {message}")
+
+
     async def receive(self):
         try:
             udp_packet, _ = await asyncio.wait_for(
@@ -186,3 +194,7 @@ class UDPClient(DatagramProtocol):
     async def send_and_receive(self, message: V2GTPMessage):
         self.send(message)
         await self.receive()
+
+    async def send_and_receive_esdp(self, message: V2GTPMessage):
+        self.send_esdp(message)
+        await self.receive()
\ No newline at end of file
diff --git a/iso15118/shared/messages/enums.py b/iso15118/shared/messages/enums.py
index 7bc9502..089279e 100644
--- a/iso15118/shared/messages/enums.py
+++ b/iso15118/shared/messages/enums.py
@@ -173,6 +173,8 @@ class ISOV2PayloadTypes(IntEnum):
     """
 
     EXI_ENCODED = 0x8001
+    ESDP_REQUEST = 0x2000 # Added by PG & MS
+    ESDP_RESPONSE = 0x2000 # Added by PG & MS
     SDP_REQUEST = 0x9000
     SDP_RESPONSE = 0x9001
 
diff --git a/iso15118/shared/messages/sdp.py b/iso15118/shared/messages/sdp.py
index a0d8c9a..7652f90 100644
--- a/iso15118/shared/messages/sdp.py
+++ b/iso15118/shared/messages/sdp.py
@@ -8,8 +8,11 @@ from iso15118.shared.messages.enums import (
     DINPayloadTypes,
     ISOV2PayloadTypes,
     ISOV20PayloadTypes,
+    UINT_32_MAX,
 )
 
+from iso15118.evcc.asn1 import esdp_asn1_main
+
 logger = logging.getLogger(__name__)
 
 MIN_TCP_PORT = 49152
@@ -33,7 +36,7 @@ class Security(IntEnum):
     @classmethod
     def from_byte(cls, byte: bytes) -> "Security":
         if int.from_bytes(byte, "big") == Security.TLS:
-            return Security.TLS
+            return Security.NO_TLS
         if int.from_bytes(byte, "big") == Security.NO_TLS:
             return Security.NO_TLS
 
@@ -69,7 +72,6 @@ class Transport(IntEnum):
         logger.error(f"Invalid byte value for Transport enum: {byte.hex()}")
         raise ValueError
 
-
 class SDPRequest:
     """
     The SECC Discovery Protocol Request message, which the EVCC uses to
@@ -243,7 +245,6 @@ class SDPRequestWireless(SDPRequest):
 class SDPResponseWireless(SDPResponse):
     pass
 
-
 def create_sdp_response(
     sdp_request: Union[SDPRequest, SDPRequestWireless],
     ip_address: bytes,
@@ -278,3 +279,194 @@ def create_sdp_response(
         logger.error("Invalid SDP request, will ignore")
 
     return sdp_response
+
+class ESDPRequest:
+
+    def __init__(self, esdp_version, max_payload_size, esdp_extensions):
+
+        self.payload_type: Union[
+            DINPayloadTypes, ISOV2PayloadTypes, ISOV20PayloadTypes
+        ] = ISOV2PayloadTypes.SDP_REQUEST
+        self.esdp_version = esdp_version                # Per V2G200-52-2
+        self.max_payload_size = max_payload_size        # Should be changed by the maximum size received V2G200-52-3
+        self.esdp_extensions = esdp_extensions
+
+    def to_payload(self) -> bytes:
+        message = self.esdp_version.to_bytes(2  , "big") + \
+        self.max_payload_size.to_bytes(2  , "big") +\
+        self.esdp_extensions
+        #self.esdp_extensions.to_bytes(215  , "big")
+        return bytes(message)
+
+    @staticmethod
+    def from_payload(payload: bytes) -> Union["ESDPRequest"]:
+        if len(payload) < 5:
+            logger.error(
+                "Payload must be of 5 bytes length. "
+                f"Provided: {len(payload)} bytes ({payload.hex()})"
+            )
+            raise InvalidSDPRequestError # Change to ESDPRequestError later
+
+        try:
+            esdp_version = payload[:2]
+            max_payload_size = payload[2:4]
+            esdp_extensions = payload[4:]
+
+            return ESDPRequest(esdp_version,max_payload_size,esdp_extensions)
+        except ValueError as exc:
+            raise InvalidSDPRequestError from exc
+
+    def __len__(self):
+        return 5
+
+    def __repr__(self):
+        return (
+            "["
+            f"esdp_version: {self.esdp_version}"
+            f", max_payload_size: {self.max_payload_size}"
+            f", esdp_extensions: {self.esdp_extensions}"
+            "]"
+        )
+
+class ESDPResponse:
+    """
+    The SECC Discovery Protocol Request message, which the SECC uses to
+    respond to the EVCC's ESDPRequest.
+    """
+
+    def __init__(
+        self,
+        esdp_version: int,
+        max_payload_size: int,
+        ip_address: bytes,
+        port: int,
+        security: Security,
+        transport_protocol: Transport,
+    ):
+
+        if len(ip_address) != 16:
+            logger.error(
+                f"Please provide a valid IPv6 address with 16 bytes. "
+                f"Provided: {len(ip_address)} bytes "
+                f"({ip_address.hex()})"
+            )
+            return
+
+        if port < MIN_TCP_PORT or port > MAX_TCP_PORT:
+            logger.warning(
+                f"The port {port} does not match the mandatory "
+                f"UDP server port 15118."
+            )
+
+        if security not in Security.options():
+            logger.error(
+                f"'{security}' is not a valid value for the "
+                f"field 'security'."
+                f"Allowed: {Security.options()} "
+            )
+            return
+
+        if transport_protocol not in Transport.options():
+            logger.error(
+                f"'{transport_protocol}' is not a valid value for "
+                f"the field 'transport_protocol'."
+                f"Allowed: {Transport.options()} "
+            )
+            return
+
+        self.esdp_version = esdp_version
+        self.max_payload_size = max_payload_size
+        self.ip_address = ip_address
+        self.port = port
+        self.security = security
+        self.transport_protocol = transport_protocol
+        self.payload_type = 0x2000
+
+    def to_payload(self) -> bytes:
+        payload = (
+            self.esdp_version.to_bytes(2, "big")
+            + self.max_payload_size.to_bytes(2, "big")
+            + self.esdp_extensions
+        )
+        return payload
+
+    @staticmethod
+    def from_payload(payload) -> "ESDPResponse":
+        if len(payload) < 5:
+            raise InvalidSDPResponseError(
+                f"Payload must be of 5 bytes length. "
+                f"Provided: {len(payload)} bytes ({payload})"
+            )
+
+        esdp_version = int.from_bytes(payload[:2], "big"),                 # ESDP Version
+        maxpayloadsize = int.from_bytes(payload[2:4], "big"),              # MaxPayload Size
+        [prt,ipv6addr,sec] = esdp_asn1_main.decode_data(payload[4:])        # ESDP Extensions
+
+        logger.info(f'SECC requested Security = {str(sec)}')
+
+        if str(sec)=='tcpOnly': # This is to change the ESDP format back to native SDP format for communicating TCP vs TLS.
+            secint=16 # For TCP
+        else:
+            secint=0 # Anything else than TCP is TLS for native format.
+
+        return ESDPResponse( 
+        int.from_bytes(payload[:2], "big"),                 # ESDP Version
+        int.from_bytes(payload[2:4], "big"),                # MaxPayload Size
+        ipv6addr,                                           # IPv6 address
+        int.from_bytes(bytes(prt), "big"),                  # Port
+        Security(secint),                                   # Security
+        Transport(0),                                       # Transport protocol hard coded to 0x00 or TCP
+        )
+
+    def __len__(self):
+        return 24
+
+    def __repr__(self):
+        ip_address: str = IPv6Address(int.from_bytes(self.ip_address, "big")).compressed
+        return (
+            f"[ ESDP Version: {self.esdp_version}"
+            f", Max Payload Size: {self.max_payload_size}"
+            f", IP address: {ip_address}"
+            f", Port: {str(self.port)} "
+            f", Security: {self.security.name} "
+            f", Transport: {self.transport_protocol.name} ]"
+        )
+
+def create_esdp_response(
+    esdp_request: Union[SDPRequest, SDPRequestWireless, ESDPRequest],
+    esdp_version: int,
+    max_payload_size: int,
+    ip_address: bytes,
+    port: int,
+    tls_enabled: bool,
+) -> Union[SDPResponse, SDPResponseWireless, ESDPResponse]:
+    """
+    Creates an SDP response based on the incoming SDP request
+
+    Args:
+        sdp_request: The SDP request received from the UDP client
+        ip_address: The IP address of the TCP server
+        port: The port of the TCP or TLS server
+        tls_enabled: Indicates if a TLS enabled server is available on SECC
+
+    Returns:
+        An SDPResponse or an SDPResponseWireless, depending on the SDP
+        request type
+    """
+    esdp_response = None
+
+    if tls_enabled:
+        security = Security.TLS
+    else:
+        security = Security.NO_TLS
+
+    if isinstance(sdp_request, SDPRequest):
+        sdp_response = SDPResponse(ip_address, port, security, Transport.TCP)
+    elif isinstance(esdp_request, ESDPRequest):
+        esdp_response = ESDPResponse(esdp_version, max_payload_size, ip_address, port, security, Transport.TCP)
+    elif isinstance(sdp_request, SDPRequestWireless):
+        raise NotImplementedError("SDPRequestWireless is not yet implemented")
+    else:
+        logger.error("Invalid ESDP request, will ignore")
+
+    return esdp_response
diff --git a/iso15118/shared/network.py b/iso15118/shared/network.py
index 9d7fc6e..75c56a6 100644
--- a/iso15118/shared/network.py
+++ b/iso15118/shared/network.py
@@ -17,6 +17,7 @@ logger = logging.getLogger(__name__)
 
 SDP_MULTICAST_GROUP = "FF02::1"
 SDP_SERVER_PORT = 15118
+ESDP_SERVER_PORT = 15200 # Added by MS for ESDP
 
 
 def _get_link_local_addr(nic: str) -> Union[IPv6Address, None]:
diff --git a/requirements.txt b/requirements.txt
index 1c4f119..6dc77f6 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -6,3 +6,5 @@ aiofile>=3.7.4
 py4j>=0.10.9.5
 netifaces>=0.11.0
 python-dateutil>=2.8.2
+hexdump==3.3
+pyasn1==0.4.8
