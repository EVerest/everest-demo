diff --git /ext/source/modules/EVSE/EvseV2G/CMakeLists.txt /ext/source/modules/EVSE/EvseV2G/CMakeLists.txt
index e07f4d7f4..d7b899c97 100644
--- /ext/source/modules/EVSE/EvseV2G/CMakeLists.txt
+++ /ext/source/modules/EVSE/EvseV2G/CMakeLists.txt
@@ -27,8 +27,184 @@ pkg_search_module(EVENT REQUIRED libevent)
 target_include_directories(${MODULE_NAME} PRIVATE
     crypto
     connection
+    asn1
 )
 
+add_library(asn1_modules
+	asn1/ANY_aper.c
+	asn1/ANY_ber.c
+	asn1/ANY.c
+	asn1/ANY_jer.c
+	asn1/ANY_uper.c
+	asn1/ANY_xer.c
+	asn1/aper_decoder.c
+	asn1/aper_encoder.c
+	asn1/aper_opentype.c
+	asn1/aper_support.c
+	asn1/asn_application.c
+	asn1/asn_bit_data.c
+	asn1/asn_codecs_prim_ber.c
+	asn1/asn_codecs_prim.c
+	asn1/asn_codecs_prim_jer.c
+	asn1/asn_codecs_prim_xer.c
+	asn1/asn_internal.c
+	asn1/asn_random_fill.c
+	asn1/asn_SEQUENCE_OF.c
+	asn1/asn_SET_OF.c
+	asn1/AuthorizationMethod.c
+	asn1/BasicSignaling.c
+	asn1/BasicSignalingProtocol.c
+	asn1/ber_decoder.c
+	asn1/ber_tlv_length.c
+	asn1/ber_tlv_tag.c
+	asn1/BIT_STRING.c
+	asn1/BIT_STRING_jer.c
+	asn1/BIT_STRING_oer.c
+	asn1/BIT_STRING_print.c
+	asn1/BIT_STRING_rfill.c
+	asn1/BIT_STRING_uper.c
+	asn1/BIT_STRING_xer.c
+	asn1/BOOLEAN_aper.c
+	asn1/BOOLEAN_ber.c
+	asn1/BOOLEAN.c
+	asn1/BOOLEAN_jer.c
+	asn1/BOOLEAN_oer.c
+	asn1/BOOLEAN_print.c
+	asn1/BOOLEAN_rfill.c
+	asn1/BOOLEAN_uper.c
+	asn1/BOOLEAN_xer.c
+	asn1/ChargingInterface.c
+	asn1/ChargingStationCharacteristics.c
+	asn1/ConductiveChargingInterfaceLimitations.c
+	asn1/constraints.c
+	asn1/constr_CHOICE_aper.c
+	asn1/constr_CHOICE_ber.c
+	asn1/constr_CHOICE.c
+	asn1/constr_CHOICE_jer.c
+	asn1/constr_CHOICE_oer.c
+	asn1/constr_CHOICE_print.c
+	asn1/constr_CHOICE_rfill.c
+	asn1/constr_CHOICE_uper.c
+	asn1/constr_CHOICE_xer.c
+	asn1/constr_SEQUENCE_aper.c
+	asn1/constr_SEQUENCE_ber.c
+	asn1/constr_SEQUENCE.c
+	asn1/constr_SEQUENCE_jer.c
+	asn1/constr_SEQUENCE_oer.c
+	asn1/constr_SEQUENCE_OF_aper.c
+	asn1/constr_SEQUENCE_OF_ber.c
+	asn1/constr_SEQUENCE_OF.c
+	asn1/constr_SEQUENCE_OF_jer.c
+	asn1/constr_SEQUENCE_OF_uper.c
+	asn1/constr_SEQUENCE_OF_xer.c
+	asn1/constr_SEQUENCE_print.c
+	asn1/constr_SEQUENCE_rfill.c
+	asn1/constr_SEQUENCE_uper.c
+	asn1/constr_SEQUENCE_xer.c
+	asn1/constr_SET_OF_aper.c
+	asn1/constr_SET_OF_ber.c
+	asn1/constr_SET_OF.c
+	asn1/constr_SET_OF_jer.c
+	asn1/constr_SET_OF_oer.c
+	asn1/constr_SET_OF_print.c
+	asn1/constr_SET_OF_rfill.c
+	asn1/constr_SET_OF_uper.c
+	asn1/constr_SET_OF_xer.c
+	asn1/constr_TYPE.c
+	asn1/DCChargingLimits.c
+	asn1/der_encoder.c
+	asn1/EMSPIdentifier.c
+	asn1/EMSPIdentifiers.c
+	asn1/EnergyTransferMode.c
+	asn1/ENUMERATED_aper.c
+	asn1/ENUMERATED.c
+	asn1/ENUMERATED_jer.c
+	asn1/ENUMERATED_oer.c
+	asn1/ENUMERATED_uper.c
+	asn1/EVCharacteristics.c
+	asn1/Extensions.c
+	asn1/EXTERNAL.c
+	asn1/ExternalExtension.c
+	asn1/ExternalExtensions.c
+	asn1/GraphicString.c
+	asn1/HighLevelCommunication.c
+	asn1/HighLevelCommunicationTuple.c
+	asn1/HLCProtocol.c
+	asn1/INTEGER_aper.c
+	asn1/INTEGER_ber.c
+	asn1/INTEGER.c
+	asn1/INTEGER_jer.c
+	asn1/INTEGER_oer.c
+	asn1/INTEGER_print.c
+	asn1/INTEGER_rfill.c
+	asn1/INTEGER_uper.c
+	asn1/INTEGER_xer.c
+	asn1/IPv6Socket.c
+	asn1/jer_decoder.c
+	asn1/jer_encoder.c
+	asn1/jer_support.c
+	asn1/NativeEnumerated_aper.c
+	asn1/NativeEnumerated.c
+	asn1/NativeEnumerated_jer.c
+	asn1/NativeEnumerated_oer.c
+	asn1/NativeEnumerated_uper.c
+	asn1/NativeEnumerated_xer.c
+	asn1/NativeInteger_aper.c
+	asn1/NativeInteger_ber.c
+	asn1/NativeInteger.c
+	asn1/NativeInteger_jer.c
+	asn1/NativeInteger_oer.c
+	asn1/NativeInteger_print.c
+	asn1/NativeInteger_rfill.c
+	asn1/NativeInteger_uper.c
+	asn1/NativeInteger_xer.c
+	asn1/ObjectDescriptor.c
+	asn1/OBJECT_IDENTIFIER.c
+	asn1/OBJECT_IDENTIFIER_jer.c
+	asn1/OBJECT_IDENTIFIER_print.c
+	asn1/OBJECT_IDENTIFIER_rfill.c
+	asn1/OBJECT_IDENTIFIER_xer.c
+	asn1/OCTET_STRING_aper.c
+	asn1/OCTET_STRING_ber.c
+	asn1/OCTET_STRING.c
+	asn1/OCTET_STRING_jer.c
+	asn1/OCTET_STRING_oer.c
+	asn1/OCTET_STRING_print.c
+	asn1/OCTET_STRING_rfill.c
+	asn1/OCTET_STRING_uper.c
+	asn1/OCTET_STRING_xer.c
+	asn1/oer_decoder.c
+	asn1/oer_encoder.c
+	asn1/oer_support.c
+	asn1/OPEN_TYPE_aper.c
+	asn1/OPEN_TYPE_ber.c
+	asn1/OPEN_TYPE.c
+	asn1/OPEN_TYPE_jer.c
+	asn1/OPEN_TYPE_oer.c
+	asn1/OPEN_TYPE_uper.c
+	asn1/OPEN_TYPE_xer.c
+	asn1/per_decoder.c
+	asn1/per_encoder.c
+	asn1/per_opentype.c
+	asn1/per_support.c
+	asn1/SecurityProfile.c
+	asn1/SecurityProfileTuple.c
+	asn1/StandardizedExtension.c
+	asn1/StandardizedExtensions.c
+	asn1/uper_decoder.c
+	asn1/uper_encoder.c
+	asn1/uper_opentype.c
+	asn1/uper_support.c
+	asn1/UTF8String.c
+	asn1/UTF8String_print.c
+	asn1/UTF8String_rfill.c
+	asn1/xer_decoder.c
+	asn1/xer_encoder.c
+	asn1/xer_support.c
+)
+
+target_include_directories(asn1_modules PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/asn1)
+
 target_link_libraries(${MODULE_NAME} PUBLIC ${EVENT_LIBRARIES} -levent -lpthread -levent_pthreads)
 
 target_link_libraries(${MODULE_NAME}
@@ -36,6 +212,7 @@ target_link_libraries(${MODULE_NAME}
         cbv2g::din
         cbv2g::iso2
         cbv2g::tp
+        asn1_modules
 )
 
 target_sources(${MODULE_NAME}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ANY.c /ext/source/modules/EVSE/EvseV2G/asn1/ANY.c
new file mode 100644
index 000000000..6440d72ce
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ANY.c
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ANY.h"
+
+asn_OCTET_STRING_specifics_t asn_SPC_ANY_specs = {
+    sizeof(ANY_t),
+    offsetof(ANY_t, _asn_ctx),
+    ASN_OSUBV_ANY
+};
+asn_TYPE_operation_t asn_OP_ANY = {
+    OCTET_STRING_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    OCTET_STRING_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    OCTET_STRING_compare,
+    OCTET_STRING_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    OCTET_STRING_decode_ber,
+    OCTET_STRING_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OCTET_STRING_decode_xer_hex,
+    ANY_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    OCTET_STRING_decode_jer_hex,
+    ANY_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    0,
+    0,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    ANY_decode_uper,
+    ANY_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    ANY_decode_aper,
+    ANY_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+    0,  /* Random fill is not defined for ANY type */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_ANY = {
+    "ANY",
+    "ANY",
+    &asn_OP_ANY,
+    0, 0, 0, 0,
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_no_constraint
+    },  /* No constraints */
+    0, 0,  /* No members */
+    &asn_SPC_ANY_specs,
+};
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ANY.h /ext/source/modules/EVSE/EvseV2G/asn1/ANY.h
new file mode 100644
index 000000000..c3e3c7e69
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ANY.h
@@ -0,0 +1,86 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef ASN_TYPE_ANY_H
+#define ASN_TYPE_ANY_H
+
+#include "OCTET_STRING.h"	/* Implemented via OCTET STRING type */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct ANY {
+	uint8_t *buf;	/* BER-encoded ANY contents */
+	int size;	/* Size of the above buffer */
+
+	asn_struct_ctx_t _asn_ctx;	/* Parsing across buffer boundaries */
+} ANY_t;
+
+extern asn_TYPE_descriptor_t asn_DEF_ANY;
+extern asn_TYPE_operation_t asn_OP_ANY;
+extern asn_OCTET_STRING_specifics_t asn_SPC_ANY_specs;
+
+#define ANY_free OCTET_STRING_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+#define ANY_print OCTET_STRING_print
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define ANY_compare OCTET_STRING_compare
+#define ANY_copy    OCTET_STRING_copy
+
+#define ANY_constraint asn_generic_no_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define ANY_decode_ber OCTET_STRING_decode_ber
+#define ANY_encode_der OCTET_STRING_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define ANY_decode_xer OCTET_STRING_decode_xer_hex
+xer_type_encoder_f ANY_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f ANY_decode_jer;
+jer_type_encoder_f ANY_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f ANY_decode_uper;
+per_type_encoder_f ANY_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f ANY_decode_aper;
+per_type_encoder_f ANY_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+/******************************
+ * Handy conversion routines. *
+ ******************************/
+
+/* Convert another ASN.1 type into the ANY. This implies DER encoding. */
+int ANY_fromType(ANY_t *, asn_TYPE_descriptor_t *td, void *struct_ptr);
+ANY_t *ANY_new_fromType(asn_TYPE_descriptor_t *td, void *struct_ptr);
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+int ANY_fromType_aper(ANY_t *st, asn_TYPE_descriptor_t *td, void *sptr);
+ANY_t *ANY_new_fromType_aper(asn_TYPE_descriptor_t *td, void *sptr);
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+/* Convert the contents of the ANY type into the specified type. */
+int ANY_to_type(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr);
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+int ANY_to_type_aper(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr);
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#define	ANY_fromBuf(s, buf, size)	OCTET_STRING_fromBuf((s), (buf), (size))
+#define	ANY_new_fromBuf(buf, size)	OCTET_STRING_new_fromBuf(	\
+						&asn_DEF_ANY, (buf), (size))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_TYPE_ANY_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ANY_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/ANY_aper.c
new file mode 100644
index 000000000..6335c077d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ANY_aper.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ANY.h"
+#include <errno.h>
+
+#undef RETURN
+#define RETURN(_code)                       \
+    do {                                    \
+        asn_dec_rval_t tmprval;             \
+        tmprval.code = _code;               \
+        tmprval.consumed = consumed_myself; \
+        return tmprval;                     \
+    } while(0)
+
+int
+ANY_fromType_aper(ANY_t *st, asn_TYPE_descriptor_t *td, void *sptr) {
+    uint8_t *buffer = NULL;
+    ssize_t erval;
+
+    if(!st || !td) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if(!sptr) {
+        if(st->buf) FREEMEM(st->buf);
+        st->size = 0;
+        return 0;
+    }
+
+    erval = aper_encode_to_new_buffer(td, td->encoding_constraints.per_constraints, sptr, (void**)&buffer);
+
+    if(erval == -1) {
+        if(buffer) FREEMEM(buffer);
+        return -1;
+    }
+    assert((size_t)erval > 0);
+
+    if(st->buf) FREEMEM(st->buf);
+    st->buf = buffer;
+    st->size = erval;
+
+    return 0;
+}
+
+ANY_t *
+ANY_new_fromType_aper(asn_TYPE_descriptor_t *td, void *sptr) {
+    ANY_t tmp;
+    ANY_t *st;
+
+    if(!td || !sptr) {
+        errno = EINVAL;
+        return 0;
+    }
+
+    memset(&tmp, 0, sizeof(tmp));
+
+    if(ANY_fromType_aper(&tmp, td, sptr)) return 0;
+
+    st = (ANY_t *)CALLOC(1, sizeof(ANY_t));
+    if(st) {
+        *st = tmp;
+        return st;
+    } else {
+        FREEMEM(tmp.buf);
+        return 0;
+    }
+}
+
+int
+ANY_to_type_aper(ANY_t *st, asn_TYPE_descriptor_t *td, void **struct_ptr) {
+    asn_dec_rval_t rval;
+    void *newst = 0;
+
+    if(!st || !td || !struct_ptr) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if(st->buf == 0) {
+        /* Nothing to convert, make it empty. */
+        *struct_ptr = (void *)0;
+        return 0;
+    }
+
+    rval = aper_decode(0, td, (void **)&newst, st->buf, st->size, 0, 0);
+    if(rval.code == RC_OK) {
+        *struct_ptr = newst;
+        return 0;
+    } else {
+        /* Remove possibly partially decoded data. */
+        ASN_STRUCT_FREE(*td, newst);
+        return -1;
+    }
+}
+
+asn_dec_rval_t
+ANY_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                const asn_TYPE_descriptor_t *td,
+                const asn_per_constraints_t *constraints, void **sptr,
+                asn_per_data_t *pd) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_ANY_specs;
+    size_t consumed_myself = 0;
+    int repeat;
+    ANY_t *st = (ANY_t *)*sptr;
+
+    (void)opt_codec_ctx;
+    (void)constraints;
+
+    /*
+     * Allocate the structure.
+     */
+    if(!st) {
+        st = (ANY_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) RETURN(RC_FAIL);
+    }
+
+    ASN_DEBUG("APER Decoding ANY type");
+
+    st->size = 0;
+    do {
+        ssize_t raw_len;
+        ssize_t len_bytes;
+        ssize_t len_bits;
+        void *p;
+        int ret;
+
+        /* Get the PER length */
+        raw_len = aper_get_length(pd, -1, -1, 0, &repeat);
+        if(raw_len < 0) RETURN(RC_WMORE);
+        if(raw_len == 0 && st->buf) break;
+
+        ASN_DEBUG("Got PER length len %" ASN_PRI_SIZE ", %s (%s)", raw_len,
+                  repeat ? "repeat" : "once", td->name);
+        len_bytes = raw_len;
+        len_bits = len_bytes * 8;
+
+        p = REALLOC(st->buf, st->size + len_bytes + 1);
+        if(!p) RETURN(RC_FAIL);
+        st->buf = (uint8_t *)p;
+
+        ret = per_get_many_bits(pd, &st->buf[st->size], 0, len_bits);
+        if(ret < 0) RETURN(RC_WMORE);
+        consumed_myself += len_bits;
+        st->size += len_bytes;
+    } while(repeat);
+    st->buf[st->size] = 0; /* nul-terminate */
+
+    RETURN(RC_OK);
+}
+
+asn_enc_rval_t
+ANY_encode_aper(const asn_TYPE_descriptor_t *td,
+                const asn_per_constraints_t *constraints, const void *sptr,
+                asn_per_outp_t *po) {
+    const ANY_t *st = (const ANY_t *)sptr;
+    asn_enc_rval_t er = {0, 0, 0};
+    const uint8_t *buf;
+    size_t size;
+    int ret;
+
+    (void)constraints;
+
+    if(!st || (!st->buf && st->size)) ASN__ENCODE_FAILED;
+
+    buf = st->buf;
+    size = st->size;
+    do {
+        int need_eom = 0;
+        ssize_t may_save = aper_put_length(po, -1, -1, size, &need_eom);
+        if(may_save < 0) ASN__ENCODE_FAILED;
+
+        ret = per_put_many_bits(po, buf, may_save * 8);
+        if(ret) ASN__ENCODE_FAILED;
+
+        buf += may_save;
+        size -= may_save;
+        assert(!(may_save & 0x07) || !size);
+        if(need_eom && aper_put_length(po, -1, -1, 0, NULL))
+            ASN__ENCODE_FAILED; /* End of Message length */
+    } while(size);
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ANY_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/ANY_ber.c
new file mode 100644
index 000000000..13041416a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ANY_ber.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ANY.h"
+#include <errno.h>
+
+struct _callback_arg {
+    uint8_t *buffer;
+    size_t offset;
+    size_t size;
+};
+
+static int ANY__consume_bytes(const void *buffer, size_t size, void *key) {
+    struct _callback_arg *arg = (struct _callback_arg *)key;
+
+    if((arg->offset + size) >= arg->size) {
+        size_t nsize = (arg->size ? arg->size << 2 : 16) + size;
+        void *p = REALLOC(arg->buffer, nsize);
+        if(!p) return -1;
+        arg->buffer = (uint8_t *)p;
+        arg->size = nsize;
+    }
+
+    memcpy(arg->buffer + arg->offset, buffer, size);
+    arg->offset += size;
+    assert(arg->offset < arg->size);
+
+    return 0;
+}
+
+int
+ANY_fromType(ANY_t *st, asn_TYPE_descriptor_t *td, void *sptr) {
+    struct _callback_arg arg;
+    asn_enc_rval_t erval = {0,0,0};
+
+    if(!st || !td) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if(!sptr) {
+        if(st->buf) FREEMEM(st->buf);
+        st->size = 0;
+        return 0;
+    }
+
+    arg.offset = arg.size = 0;
+    arg.buffer = 0;
+
+    erval = der_encode(td, sptr, ANY__consume_bytes, &arg);
+    if(erval.encoded == -1) {
+        if(arg.buffer) FREEMEM(arg.buffer);
+        return -1;
+    }
+    assert((size_t)erval.encoded == arg.offset);
+
+    if(st->buf) FREEMEM(st->buf);
+    st->buf = arg.buffer;
+    st->size = arg.offset;
+
+    return 0;
+}
+
+ANY_t *
+ANY_new_fromType(asn_TYPE_descriptor_t *td, void *sptr) {
+    ANY_t tmp;
+    ANY_t *st;
+
+    if(!td || !sptr) {
+        errno = EINVAL;
+        return 0;
+    }
+
+    memset(&tmp, 0, sizeof(tmp));
+
+    if(ANY_fromType(&tmp, td, sptr)) return 0;
+
+    st = (ANY_t *)CALLOC(1, sizeof(ANY_t));
+    if(st) {
+        *st = tmp;
+        return st;
+    } else {
+        FREEMEM(tmp.buf);
+        return 0;
+    }
+}
+
+int
+ANY_to_type(ANY_t *st, asn_TYPE_descriptor_t *td, void **struct_ptr) {
+    asn_dec_rval_t rval;
+    void *newst = 0;
+
+    if(!st || !td || !struct_ptr) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if(st->buf == 0) {
+        /* Nothing to convert, make it empty. */
+        *struct_ptr = (void *)0;
+        return 0;
+    }
+
+    rval = ber_decode(0, td, (void **)&newst, st->buf, st->size);
+    if(rval.code == RC_OK) {
+        *struct_ptr = newst;
+        return 0;
+    } else {
+        /* Remove possibly partially decoded data. */
+        ASN_STRUCT_FREE(*td, newst);
+        return -1;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ANY_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/ANY_jer.c
new file mode 100644
index 000000000..87feeeaa5
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ANY_jer.c
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ANY.h"
+
+asn_enc_rval_t
+ANY_encode_jer(const asn_TYPE_descriptor_t *td, const asn_jer_constraints_t *constraints,
+               const void *sptr, int ilevel,
+               enum jer_encoder_flags_e flags, asn_app_consume_bytes_f *cb,
+               void *app_key) {
+  ASN__ENCODE_FAILED;
+
+  /* Dump as binary */
+  return OCTET_STRING_encode_jer(td, constraints, sptr, ilevel, flags, cb, app_key);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ANY_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/ANY_uper.c
new file mode 100644
index 000000000..ddbf7b754
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ANY_uper.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ANY.h"
+#include <errno.h>
+
+#undef RETURN
+#define RETURN(_code)                       \
+    do {                                    \
+        asn_dec_rval_t tmprval;             \
+        tmprval.code = _code;               \
+        tmprval.consumed = consumed_myself; \
+        return tmprval;                     \
+    } while(0)
+
+asn_dec_rval_t
+ANY_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                const asn_TYPE_descriptor_t *td,
+                const asn_per_constraints_t *constraints, void **sptr,
+                asn_per_data_t *pd) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_ANY_specs;
+    size_t consumed_myself = 0;
+    int repeat;
+    ANY_t *st = (ANY_t *)*sptr;
+
+    (void)opt_codec_ctx;
+    (void)constraints;
+
+    /*
+     * Allocate the structure.
+     */
+    if(!st) {
+        st = (ANY_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) RETURN(RC_FAIL);
+    }
+
+    ASN_DEBUG("UPER Decoding ANY type");
+
+    st->size = 0;
+    do {
+        ssize_t raw_len;
+        ssize_t len_bytes;
+        ssize_t len_bits;
+        void *p;
+        int ret;
+
+        /* Get the PER length */
+        raw_len = uper_get_length(pd, -1, 0, &repeat);
+        if(raw_len < 0) RETURN(RC_WMORE);
+        if(raw_len == 0 && st->buf) break;
+
+        ASN_DEBUG("Got PER length len %" ASN_PRI_SIZE ", %s (%s)", raw_len,
+                  repeat ? "repeat" : "once", td->name);
+        len_bytes = raw_len;
+        len_bits = len_bytes * 8;
+
+        p = REALLOC(st->buf, st->size + len_bytes + 1);
+        if(!p) RETURN(RC_FAIL);
+        st->buf = (uint8_t *)p;
+
+        ret = per_get_many_bits(pd, &st->buf[st->size], 0, len_bits);
+        if(ret < 0) RETURN(RC_WMORE);
+        consumed_myself += len_bits;
+        st->size += len_bytes;
+    } while(repeat);
+    st->buf[st->size] = 0; /* nul-terminate */
+
+    RETURN(RC_OK);
+}
+
+asn_enc_rval_t
+ANY_encode_uper(const asn_TYPE_descriptor_t *td,
+                const asn_per_constraints_t *constraints, const void *sptr,
+                asn_per_outp_t *po) {
+    const ANY_t *st = (const ANY_t *)sptr;
+    asn_enc_rval_t er = {0, 0, 0};
+    const uint8_t *buf;
+    size_t size;
+    int ret;
+
+    (void)constraints;
+
+    if(!st || (!st->buf && st->size)) ASN__ENCODE_FAILED;
+
+    buf = st->buf;
+    size = st->size;
+    do {
+        int need_eom = 0;
+        ssize_t may_save = uper_put_length(po, size, &need_eom);
+        if(may_save < 0) ASN__ENCODE_FAILED;
+
+        ret = per_put_many_bits(po, buf, may_save * 8);
+        if(ret) ASN__ENCODE_FAILED;
+
+        buf += may_save;
+        size -= may_save;
+        assert(!(may_save & 0x07) || !size);
+        if(need_eom && uper_put_length(po, 0, 0))
+            ASN__ENCODE_FAILED; /* End of Message length */
+    } while(size);
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ANY_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/ANY_xer.c
new file mode 100644
index 000000000..759b342fb
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ANY_xer.c
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ANY.h"
+
+asn_enc_rval_t
+ANY_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+               enum xer_encoder_flags_e flags, asn_app_consume_bytes_f *cb,
+               void *app_key) {
+    if(flags & XER_F_CANONICAL) {
+        /*
+         * Canonical XER-encoding of ANY type is not supported.
+         */
+        ASN__ENCODE_FAILED;
+    }
+
+    /* Dump as binary */
+    return OCTET_STRING_encode_xer(td, sptr, ilevel, flags, cb, app_key);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/AuthorizationMethod.c /ext/source/modules/EVSE/EvseV2G/asn1/AuthorizationMethod.c
new file mode 100644
index 000000000..b849f03ec
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/AuthorizationMethod.c
@@ -0,0 +1,73 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "AuthorizationMethod.h"
+
+/*
+ * This type is implemented using NativeEnumerated,
+ * so here we adjust the DEF accordingly.
+ */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_AuthorizationMethod_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_AuthorizationMethod_constr_1 CC_NOTUSED = {
+	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static const asn_INTEGER_enum_map_t asn_MAP_AuthorizationMethod_value2enum_1[] = {
+	{ 0,	3,	"eim" },
+	{ 1,	5,	"pnc-2" },
+	{ 2,	6,	"pnc-20" }
+};
+static const unsigned int asn_MAP_AuthorizationMethod_enum2value_1[] = {
+	0,	/* eim(0) */
+	1,	/* pnc-2(1) */
+	2	/* pnc-20(2) */
+};
+const asn_INTEGER_specifics_t asn_SPC_AuthorizationMethod_specs_1 = {
+	asn_MAP_AuthorizationMethod_value2enum_1,	/* "tag" => N; sorted by tag */
+	asn_MAP_AuthorizationMethod_enum2value_1,	/* N => "tag"; sorted by N */
+	3,	/* Number of elements in the maps */
+	0,	/* Enumeration is not extensible */
+	1,	/* Strict enumeration */
+	0,	/* Native long size */
+	0
+};
+static const ber_tlv_tag_t asn_DEF_AuthorizationMethod_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_descriptor_t asn_DEF_AuthorizationMethod = {
+	"AuthorizationMethod",
+	"AuthorizationMethod",
+	&asn_OP_NativeEnumerated,
+	asn_DEF_AuthorizationMethod_tags_1,
+	sizeof(asn_DEF_AuthorizationMethod_tags_1)
+		/sizeof(asn_DEF_AuthorizationMethod_tags_1[0]), /* 1 */
+	asn_DEF_AuthorizationMethod_tags_1,	/* Same as above */
+	sizeof(asn_DEF_AuthorizationMethod_tags_1)
+		/sizeof(asn_DEF_AuthorizationMethod_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_AuthorizationMethod_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_AuthorizationMethod_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		NativeEnumerated_constraint
+	},
+	0, 0,	/* Defined elsewhere */
+	&asn_SPC_AuthorizationMethod_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/AuthorizationMethod.h /ext/source/modules/EVSE/EvseV2G/asn1/AuthorizationMethod.h
new file mode 100644
index 000000000..57ad45486
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/AuthorizationMethod.h
@@ -0,0 +1,55 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_AuthorizationMethod_H_
+#define	_AuthorizationMethod_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeEnumerated.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Dependencies */
+typedef enum AuthorizationMethod {
+	AuthorizationMethod_eim	= 0,
+	AuthorizationMethod_pnc_2	= 1,
+	AuthorizationMethod_pnc_20	= 2
+} e_AuthorizationMethod;
+
+/* AuthorizationMethod */
+typedef long	 AuthorizationMethod_t;
+
+/* Implementation */
+extern asn_per_constraints_t asn_PER_type_AuthorizationMethod_constr_1;
+extern asn_TYPE_descriptor_t asn_DEF_AuthorizationMethod;
+extern const asn_INTEGER_specifics_t asn_SPC_AuthorizationMethod_specs_1;
+asn_struct_free_f AuthorizationMethod_free;
+asn_struct_print_f AuthorizationMethod_print;
+asn_constr_check_f AuthorizationMethod_constraint;
+ber_type_decoder_f AuthorizationMethod_decode_ber;
+der_type_encoder_f AuthorizationMethod_encode_der;
+xer_type_decoder_f AuthorizationMethod_decode_xer;
+xer_type_encoder_f AuthorizationMethod_encode_xer;
+jer_type_encoder_f AuthorizationMethod_encode_jer;
+oer_type_decoder_f AuthorizationMethod_decode_oer;
+oer_type_encoder_f AuthorizationMethod_encode_oer;
+per_type_decoder_f AuthorizationMethod_decode_uper;
+per_type_encoder_f AuthorizationMethod_encode_uper;
+per_type_decoder_f AuthorizationMethod_decode_aper;
+per_type_encoder_f AuthorizationMethod_encode_aper;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _AuthorizationMethod_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING.c /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING.c
new file mode 100644
index 000000000..8469c0c61
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING.c
@@ -0,0 +1,253 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BIT_STRING.h"
+
+/*
+ * BIT STRING basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_BIT_STRING_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (3 << 2))
+};
+asn_OCTET_STRING_specifics_t asn_SPC_BIT_STRING_specs = {
+    sizeof(BIT_STRING_t),
+    offsetof(BIT_STRING_t, _asn_ctx),
+    ASN_OSUBV_BIT
+};
+asn_TYPE_operation_t asn_OP_BIT_STRING = {
+    OCTET_STRING_free,         /* Implemented in terms of OCTET STRING */
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    BIT_STRING_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    BIT_STRING_compare,
+    BIT_STRING_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    OCTET_STRING_decode_ber,   /* Implemented in terms of OCTET STRING */
+    OCTET_STRING_encode_der,   /* Implemented in terms of OCTET STRING */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OCTET_STRING_decode_xer_binary,
+    BIT_STRING_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    BIT_STRING_decode_jer,
+    BIT_STRING_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    BIT_STRING_decode_oer,
+    BIT_STRING_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    BIT_STRING_decode_uper,  /* Unaligned PER decoder */
+    BIT_STRING_encode_uper,  /* Unaligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    OCTET_STRING_decode_aper,  /* Aligned PER decoder */
+    OCTET_STRING_encode_aper,  /* Aligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    BIT_STRING_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_BIT_STRING = {
+    "BIT STRING",
+    "BIT_STRING",
+    &asn_OP_BIT_STRING,
+    asn_DEF_BIT_STRING_tags,
+    sizeof(asn_DEF_BIT_STRING_tags)
+      / sizeof(asn_DEF_BIT_STRING_tags[0]),
+    asn_DEF_BIT_STRING_tags,  /* Same as above */
+    sizeof(asn_DEF_BIT_STRING_tags)
+      / sizeof(asn_DEF_BIT_STRING_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        BIT_STRING_constraint
+    },
+    0, 0,  /* No members */
+    &asn_SPC_BIT_STRING_specs
+};
+
+/*
+ * BIT STRING generic constraint.
+ */
+int
+BIT_STRING_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
+                      asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+
+	if(st && st->buf) {
+		if((st->size == 0 && st->bits_unused)
+		|| st->bits_unused < 0 || st->bits_unused > 7) {
+			ASN__CTFAIL(app_key, td, sptr,
+				"%s: invalid padding byte (%s:%d)",
+				td->name, __FILE__, __LINE__);
+			return -1;
+		}
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Non-destructively remove the trailing 0-bits from the given bit string.
+ */
+const BIT_STRING_t *
+BIT_STRING__compactify(const BIT_STRING_t *st, BIT_STRING_t *tmp) {
+    const uint8_t *b;
+    union {
+        const uint8_t *c_buf;
+        uint8_t *nc_buf;
+    } unconst;
+
+    if(st->size == 0) {
+        assert(st->bits_unused == 0);
+        return st;
+    } else {
+        for(b = &st->buf[st->size - 1]; b > st->buf && *b == 0; b--) {
+            ;
+        }
+        /* b points to the last byte which may contain data */
+        if(*b) {
+            int unused = 7;
+            uint8_t v = *b;
+            v &= -(int8_t)v;
+            if(v & 0x0F) unused -= 4;
+            if(v & 0x33) unused -= 2;
+            if(v & 0x55) unused -= 1;
+            tmp->size = b-st->buf + 1;
+            tmp->bits_unused = unused;
+        } else {
+            tmp->size = b-st->buf;
+            tmp->bits_unused = 0;
+        }
+
+        assert(b >= st->buf);
+    }
+
+    unconst.c_buf = st->buf;
+    tmp->buf = unconst.nc_buf;
+    return tmp;
+}
+
+/*
+ * Lexicographically compare the common prefix of both strings,
+ * and if it is the same return -1 for the smallest string.
+ */
+int
+BIT_STRING_compare(const asn_TYPE_descriptor_t *td, const void *aptr,
+                   const void *bptr) {
+    /*
+     * Remove information about trailing bits, since
+     * X.680 (08/2015) #22.7 "ensure that different semantics are not"
+     * "associated with [values that differ only in] the trailing 0 bits."
+     */
+    BIT_STRING_t compact_a, compact_b;
+    const BIT_STRING_t *a = BIT_STRING__compactify(aptr, &compact_a);
+    const BIT_STRING_t *b = BIT_STRING__compactify(bptr, &compact_b);
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics;
+
+    (void)specs;
+    assert(specs && specs->subvariant == ASN_OSUBV_BIT);
+
+    if(a && b) {
+        size_t common_prefix_size = a->size <= b->size ? a->size : b->size;
+        int ret = memcmp(a->buf, b->buf, common_prefix_size);
+        if(ret == 0) {
+            /* Figure out which string with equal prefixes is longer. */
+            if(a->size < b->size) {
+                return -1;
+            } else if(a->size > b->size) {
+                return 1;
+            } else {
+                /* Figure out how many unused bits */
+                if(a->bits_unused > b->bits_unused) {
+                    return -1;
+                } else if(a->bits_unused < b->bits_unused) {
+                    return 1;
+                } else {
+                    return 0;
+                }
+            }
+        } else {
+            return ret;
+        }
+    } else if(!a && !b) {
+        return 0;
+    } else if(!a) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+int
+BIT_STRING_copy(const asn_TYPE_descriptor_t *td, void **aptr,
+                const void *bptr) {
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics;
+    BIT_STRING_t *a = (BIT_STRING_t *)*aptr;
+    const BIT_STRING_t *b = (const BIT_STRING_t *)bptr;
+
+    if(!b) {
+        if(a) {
+            FREEMEM(a->buf);
+            FREEMEM(a);
+            *aptr = 0;
+        }
+        return 0;
+    }
+
+    if(!a) {
+        a = *aptr = CALLOC(1, specs->struct_size);
+        if(!a) return -1;
+    }
+
+    uint8_t* buf = MALLOC(b->size + 1);
+    if(!buf) return -1;
+    memcpy(buf, b->buf, b->size);
+    buf[b->size] = 0;
+
+    FREEMEM(a->buf);
+    a->buf = buf;
+    a->size = b->size;
+    a->bits_unused = b->bits_unused;
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING.h /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING.h
new file mode 100644
index 000000000..208557581
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING.h
@@ -0,0 +1,77 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_BIT_STRING_H_
+#define	_BIT_STRING_H_
+
+#include "OCTET_STRING.h"	/* Some help from OCTET STRING */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct BIT_STRING_s {
+	uint8_t *buf;	/* BIT STRING body */
+	size_t size;	/* Size of the above buffer */
+
+	int bits_unused;/* Unused trailing bits in the last octet (0..7) */
+
+	asn_struct_ctx_t _asn_ctx;	/* Parsing across buffer boundaries */
+} BIT_STRING_t;
+
+extern asn_TYPE_descriptor_t asn_DEF_BIT_STRING;
+extern asn_TYPE_operation_t asn_OP_BIT_STRING;
+extern asn_OCTET_STRING_specifics_t asn_SPC_BIT_STRING_specs;
+
+#define BIT_STRING_free OCTET_STRING_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f BIT_STRING_print;  /* Human-readable output */
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f BIT_STRING_compare;
+asn_struct_copy_f    BIT_STRING_copy;
+
+asn_constr_check_f BIT_STRING_constraint;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define BIT_STRING_decode_ber OCTET_STRING_decode_ber
+#define BIT_STRING_encode_der OCTET_STRING_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define BIT_STRING_decode_xer OCTET_STRING_decode_xer_binary
+xer_type_encoder_f BIT_STRING_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f BIT_STRING_decode_jer;
+jer_type_encoder_f BIT_STRING_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f BIT_STRING_decode_oer;
+oer_type_encoder_f BIT_STRING_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f BIT_STRING_decode_uper;
+per_type_encoder_f BIT_STRING_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+#define BIT_STRING_decode_aper OCTET_STRING_decode_aper
+#define BIT_STRING_encode_aper OCTET_STRING_encode_aper
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f BIT_STRING_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+const BIT_STRING_t *BIT_STRING__compactify(const BIT_STRING_t *st, BIT_STRING_t *tmp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _BIT_STRING_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_jer.c
new file mode 100644
index 000000000..623b83119
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_jer.c
@@ -0,0 +1,295 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "BIT_STRING.h"
+#include "INTEGER.h"
+
+asn_enc_rval_t
+BIT_STRING_encode_jer(const asn_TYPE_descriptor_t *td,
+                      const asn_jer_constraints_t *constraints,
+                      const void *sptr, int ilevel,
+                      enum jer_encoder_flags_e flags,
+                      asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0, 0, 0};
+    const char * const h2c = "0123456789ABCDEF";
+    char scratch[16 * 3 + 4];
+    char *p = scratch;
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+    const asn_jer_constraints_t* cts = constraints ?
+        constraints : td->encoding_constraints.jer_constraints;
+    uint8_t *buf;
+    uint8_t *end;
+
+    (void)ilevel;
+    (void)flags;
+
+    int jmin = flags & JER_F_MINIFIED;
+
+    if(!st || !st->buf)
+        ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    buf = st->buf;
+    end = buf + st->size - 1;  /* Last byte is special */
+
+    /*
+     * Hex dump
+     */
+    if(cts->size != -1) { /* Fixed size */
+        *p++ = '"';
+        for(int i = 0; buf < end; buf++, i++) {
+            if(!(i % 16) && (i || st->size > 16)) {
+                ASN__CALLBACK(scratch, p-scratch);
+                p = scratch;
+            }
+            *p++ = h2c[*buf >> 4];
+            *p++ = h2c[*buf & 0x0F];
+        }
+
+        ASN__CALLBACK(scratch, p - scratch);
+        p = scratch;
+
+        if(buf == end) {
+            int ubits = st->bits_unused;
+            uint8_t v = *buf & (0xff << ubits);
+            *p++ = h2c[v >> 4];
+            *p++ = h2c[v & 0x0F];
+            ASN__CALLBACK(scratch, p - scratch);
+            p = scratch;
+        }
+        *p++ = '"';
+        ASN__CALLBACK(scratch, p - scratch);
+    } else { /* Variable size */
+        ASN__CALLBACK("{", 1);
+        if(!jmin) {
+            ASN__TEXT_INDENT(1, ilevel + 1);
+            ASN__CALLBACK("\"value\": ", 9);
+        } else {
+            ASN__CALLBACK("\"value\":", 8);
+        }
+        *p++ = '"';
+        for(int i = 0; buf < end; buf++, i++) {
+            if(!(i % 16) && (i || st->size > 16)) {
+                ASN__CALLBACK(scratch, p-scratch);
+                p = scratch;
+            }
+            *p++ = h2c[*buf >> 4];
+            *p++ = h2c[*buf & 0x0F];
+        }
+
+        ASN__CALLBACK(scratch, p - scratch);
+        p = scratch;
+
+        if(buf == end) {
+            int ubits = st->bits_unused;
+            uint8_t v = *buf & (0xff << ubits);
+            *p++ = h2c[v >> 4];
+            *p++ = h2c[v & 0x0F];
+            ASN__CALLBACK(scratch, p - scratch);
+            p = scratch;
+        }
+        *p++ = '"';
+        ASN__CALLBACK(scratch, p - scratch);
+
+        ASN__CALLBACK(",", 1);
+        if (!jmin) {
+            ASN__TEXT_INDENT(1, ilevel + 1);
+        }
+
+        if(!jmin) {
+            ASN__CALLBACK("\"length\": ", 10);
+        } else {
+            ASN__CALLBACK("\"length\":", 9);
+        }
+        int wr = snprintf(scratch, sizeof(scratch), "%lu",
+                st->size * 8 - (st->bits_unused));
+        if(wr < 0 || (size_t)wr >= sizeof(scratch)) {
+            ASN__ENCODE_FAILED;
+        }
+        ASN__CALLBACK(scratch, wr);
+        if (!jmin) {
+            ASN__TEXT_INDENT(1, ilevel);
+        }
+        ASN__CALLBACK("}", 1);
+    }
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+#define SKIPCHAR(_c)                 \
+    do {                             \
+        int found = 0;               \
+        for (; p < pend; ++p) {      \
+            if (*p == _c) {          \
+                found = 1; ++p;      \
+                break;               \
+            }                        \
+        }                            \
+        if(!found) RETURN(RC_WMORE); \
+    } while(0)
+
+asn_dec_rval_t
+BIT_STRING_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                            const asn_TYPE_descriptor_t *td,
+                            const asn_jer_constraints_t *constraints,
+                            void **sptr,
+                            const void *buf_ptr, size_t size) {
+    BIT_STRING_t *st = (BIT_STRING_t *)*sptr;
+    const asn_jer_constraints_t *cts = constraints ?
+        constraints : td->encoding_constraints.jer_constraints;
+    asn_dec_rval_t rval;  /* Return value from the decoder */
+    ssize_t consumed_myself = 0;  /* Consumed bytes from buf_ptr */
+
+    /*
+     * Create the string if does not exist.
+     */
+    if(!st) {
+        st = (BIT_STRING_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    const char *p = (const char*)buf_ptr;
+    const char *pend = p + size;
+
+    if(cts->size == -1) {
+        SKIPCHAR('{');
+        SKIPCHAR('"');
+        if(pend-p < 5) RETURN(RC_WMORE);
+        if(0 != memcmp(p, "value", 5)) RETURN(RC_FAIL);
+        p += 5;
+        SKIPCHAR('"');
+        SKIPCHAR(':');
+    }
+
+    /* bitstring value */
+    SKIPCHAR('"');
+
+    /* calculate size */
+    const char* p0 = p;
+    SKIPCHAR('"');
+    const char* p1 = p - 1;
+    p = p0;
+
+    void *nptr = REALLOC(st->buf, (p1-p0 + 1) / 2 + 1);
+    if(!nptr) RETURN(RC_FAIL);
+    st->buf = (uint8_t *)nptr;
+    uint8_t *buf = st->buf;
+    unsigned int clv = 0;
+    int half = 0;
+
+    for(; p < p1; p++) {
+        int ch = *(const unsigned char *)p;
+        switch(ch) {
+        case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:  /*01234*/
+        case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:  /*56789*/
+            clv = (clv << 4) + (ch - 0x30);
+            break;
+        case 0x41: case 0x42: case 0x43:  /* ABC */
+        case 0x44: case 0x45: case 0x46:  /* DEF */
+            clv = (clv << 4) + (ch - 0x41 + 10);
+            break;
+        case 0x61: case 0x62: case 0x63:  /* abc */
+        case 0x64: case 0x65: case 0x66:  /* def */
+            clv = (clv << 4) + (ch - 0x61 + 10);
+            break;
+        default:
+            *buf = 0;  /* JIC */
+            RETURN(RC_FAIL);
+        }
+        if(half++) {
+            half = 0;
+            *buf++ = clv;
+        }
+    }
+
+    /*
+     * Check partial decoding.
+     */
+    if(half) {
+        RETURN(RC_FAIL);
+    }
+
+    st->size = buf - st->buf;  /* Adjust the buffer size */
+    st->buf[st->size] = 0;  /* Courtesy termination */
+
+    SKIPCHAR('"');
+
+    if(cts->size == -1) {
+        SKIPCHAR(',');
+        SKIPCHAR('"');
+        if(pend-p < 6) RETURN(RC_WMORE);
+        if(0 != memcmp(p, "length", 6)) RETURN(RC_FAIL);
+        p += 6;
+        SKIPCHAR('"');
+        SKIPCHAR(':');
+        p0 = p;
+        /* Skip whitespace, numbers, for length calc for INTEGER dec
+         * Stop on first non-whitespace/non-number */
+        int numbered = 0;
+        for (; p < pend; ++p) {
+            switch (*p) {
+                case 0x09: case 0x0a: case 0x0c: case 0x0d:
+                case 0x20:
+                    if(!numbered) continue;
+                    else break;
+                    /* Ignore whitespace */
+                case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:  /*01234*/
+                case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:  /*56789*/
+                case 0x2d:  /*-*/
+                    numbered = 1;
+                    continue;
+            }
+            if(numbered) break;
+        }
+        if(!numbered) RETURN(RC_FAIL);
+
+        unsigned long length;
+
+        INTEGER_t integer = { 0 };
+        void *integer_ptr = (void *)&integer;
+        memset(&integer, 0, sizeof(integer));
+
+        asn_dec_rval_t dec =
+            INTEGER_decode_jer(NULL, &asn_DEF_INTEGER, NULL, &integer_ptr, p0, p-p0);
+        if(dec.code == RC_OK) {
+            if(asn_INTEGER2ulong(&integer, (unsigned long *)&length)) {
+                RETURN(RC_FAIL);
+            }
+        } else {
+            RETURN(RC_FAIL);
+        }
+        ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &integer);
+
+        if(dec.code != RC_OK) RETURN(RC_FAIL);
+        st->bits_unused = (st->size * 8) - length;
+
+        SKIPCHAR('}');
+    } else {
+        if(st->size * 8 < (size_t)cts->size) {
+            RETURN(RC_FAIL);
+        }
+        st->bits_unused = (st->size * 8) - cts->size;
+    }
+
+    consumed_myself = (const char *)p - (const char *)buf_ptr;
+    RETURN(RC_OK);
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_oer.c
new file mode 100644
index 000000000..07fcb9dec
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_oer.c
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BIT_STRING.h"
+
+asn_dec_rval_t
+BIT_STRING_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                      const asn_TYPE_descriptor_t *td,
+                      const asn_oer_constraints_t *constraints, void **sptr,
+                      const void *ptr, size_t size) {
+    BIT_STRING_t *st = (BIT_STRING_t *)*sptr;
+    const asn_oer_constraints_t *cts =
+        constraints ? constraints : td->encoding_constraints.oer_constraints;
+    ssize_t ct_size = cts ? cts->size : -1;
+    asn_dec_rval_t rval = {RC_OK, 0};
+    size_t expected_length = 0;
+
+    (void)opt_codec_ctx;
+
+    if(!st) {
+        st = (BIT_STRING_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    if(ct_size >= 0) {
+        expected_length = (ct_size + 7) >> 3;
+        st->bits_unused = (8 - (ct_size & 7)) & 7;
+    } else {
+        /*
+         * X.696 (08/2015) #13.3.1
+         * Encode length determinant as _number of octets_, but only
+         * if upper bound is not equal to lower bound.
+         */
+        ssize_t len_len = oer_fetch_length(ptr, size, &expected_length);
+        if(len_len > 0) {
+            ptr = (const char *)ptr + len_len;
+            size -= len_len;
+        } else if(len_len == 0) {
+            ASN__DECODE_STARVED;
+        } else if(len_len < 0) {
+            ASN__DECODE_FAILED;
+        }
+
+        if(expected_length < 1) {
+            ASN__DECODE_FAILED;
+        } else if(expected_length > size) {
+            ASN__DECODE_STARVED;
+        }
+
+        st->bits_unused = ((const uint8_t *)ptr)[0];
+        if(st->bits_unused & ~7) {
+            ASN_DEBUG("%s: unused bits outside of 0..7 range", td->name);
+            ASN__DECODE_FAILED;
+        }
+        ptr = (const char *)ptr + 1;
+        size--;
+        expected_length--;
+        rval.consumed = len_len + 1;
+    }
+
+    if(size < expected_length) {
+        ASN__DECODE_STARVED;
+    } else {
+        uint8_t *buf = MALLOC(expected_length + 1);
+        if(buf == NULL) {
+            ASN__DECODE_FAILED;
+        } else {
+            memcpy(buf, ptr, expected_length);
+            buf[expected_length] = '\0';
+        }
+        FREEMEM(st->buf);
+        st->buf = buf;
+        st->size = expected_length;
+        if(expected_length > 0) {
+            buf[expected_length - 1] &= (0xff << st->bits_unused);
+        }
+
+        rval.consumed += expected_length;
+        return rval;
+    }
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+BIT_STRING_encode_oer(const asn_TYPE_descriptor_t *td,
+                      const asn_oer_constraints_t *constraints,
+                      const void *sptr, asn_app_consume_bytes_f *cb,
+                      void *app_key) {
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+    asn_enc_rval_t erval = {0, 0, 0};
+    const asn_oer_constraints_t *cts =
+        constraints ? constraints : td->encoding_constraints.oer_constraints;
+    ssize_t ct_size = cts ? cts->size : -1;
+    size_t trailing_zeros = 0;
+    int fix_last_byte = 0;
+
+    if(!st) ASN__ENCODE_FAILED;
+
+    if(st->bits_unused & ~7) {
+        ASN_DEBUG("BIT STRING unused bits %d out of 0..7 range",
+                  st->bits_unused);
+        ASN__ENCODE_FAILED;
+    }
+    if(st->bits_unused && !(st->size && st->buf)) {
+        ASN_DEBUG("BIT STRING %s size 0 can't support unused bits %d", td->name,
+                  st->bits_unused);
+        ASN__ENCODE_FAILED;
+    }
+
+    if(ct_size >= 0) {
+        size_t ct_bytes = (ct_size + 7) >> 3;
+        if(st->size > ct_bytes) {
+            ASN_DEBUG("More bits in BIT STRING %s (%" ASN_PRI_SSIZE ") than constrained %" ASN_PRI_SSIZE "",
+                      td->name, 8 * st->size - st->bits_unused, ct_size);
+            ASN__ENCODE_FAILED;
+        }
+        trailing_zeros = ct_bytes - st->size;   /* Allow larger constraint */
+    } else {
+        uint8_t ub = st->bits_unused & 7;
+        ssize_t len_len = oer_serialize_length(1 + st->size, cb, app_key);
+        if(len_len < 0) ASN__ENCODE_FAILED;
+        if(cb(&ub, 1, app_key) < 0) {
+            ASN__ENCODE_FAILED;
+        }
+        erval.encoded += len_len + 1;
+    }
+
+    if(st->bits_unused) {
+        if(st->buf[st->size - 1] & (0xff << st->bits_unused)) {
+            fix_last_byte = 1;
+        }
+    }
+
+    if(cb(st->buf, st->size - fix_last_byte, app_key) < 0) {
+        ASN__ENCODE_FAILED;
+    }
+
+    if(fix_last_byte) {
+        uint8_t b = st->buf[st->size - 1] & (0xff << st->bits_unused);
+        if(cb(&b, 1, app_key) < 0) {
+            ASN__ENCODE_FAILED;
+        }
+    }
+
+    erval.encoded += st->size;
+
+    if(trailing_zeros) {
+        static uint8_t zeros[16];
+        while(trailing_zeros > 0) {
+            int ret;
+            if(trailing_zeros < sizeof(zeros)) {
+                ret = cb(zeros, trailing_zeros, app_key);
+                erval.encoded += trailing_zeros;
+            } else {
+                ret = cb(zeros, sizeof(zeros), app_key);
+                erval.encoded += sizeof(zeros);
+            }
+            if(ret < 0) ASN__ENCODE_FAILED;
+        }
+    }
+
+    return erval;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_print.c /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_print.c
new file mode 100644
index 000000000..f56496de9
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_print.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BIT_STRING.h"
+
+/*
+ * BIT STRING specific contents printer.
+ */
+int
+BIT_STRING_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+                 asn_app_consume_bytes_f *cb, void *app_key) {
+    const char * const h2c = "0123456789ABCDEF";
+    char scratch[64];
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+    uint8_t *buf;
+    uint8_t *end;
+    char *p = scratch;
+
+    (void)td;  /* Unused argument */
+
+    if(!st || !st->buf)
+        return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+
+    ilevel++;
+    buf = st->buf;
+    end = buf + st->size;
+
+    /*
+     * Hexadecimal dump.
+     */
+    for(; buf < end; buf++) {
+        if((buf - st->buf) % 16 == 0 && (st->size > 16)
+                && buf != st->buf) {
+            _i_INDENT(1);
+            /* Dump the string */
+            if(cb(scratch, p - scratch, app_key) < 0) return -1;
+            p = scratch;
+        }
+        *p++ = h2c[*buf >> 4];
+        *p++ = h2c[*buf & 0x0F];
+        *p++ = 0x20;
+    }
+
+    if(p > scratch) {
+        p--;  /* Eat the tailing space */
+
+        if((st->size > 16)) {
+            _i_INDENT(1);
+        }
+
+        /* Dump the incomplete 16-bytes row */
+        if(cb(scratch, p - scratch, app_key) < 0)
+            return -1;
+    }
+
+    if(st->bits_unused) {
+        int ret = snprintf(scratch, sizeof(scratch), " (%d bit%s unused)",
+                           st->bits_unused, st->bits_unused == 1 ? "" : "s");
+        assert(ret > 0 && ret < (ssize_t)sizeof(scratch));
+        if(ret > 0 && ret < (ssize_t)sizeof(scratch)
+           && cb(scratch, ret, app_key) < 0)
+            return -1;
+    }
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_rfill.c
new file mode 100644
index 000000000..fe1cea022
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_rfill.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BIT_STRING.h"
+
+asn_random_fill_result_t
+BIT_STRING_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                       const asn_encoding_constraints_t *constraints,
+                       size_t max_length) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_BIT_STRING_specs;
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    static unsigned lengths[] = {0,     1,     2,     3,     4,     8,
+                                 126,   127,   128,   16383, 16384, 16385,
+                                 65534, 65535, 65536, 65537};
+    uint8_t *buf;
+    uint8_t *bend;
+    uint8_t *b;
+    size_t rnd_bits, rnd_len;
+    BIT_STRING_t *st;
+
+    if(max_length == 0) return result_skipped;
+
+    switch(specs->subvariant) {
+    case ASN_OSUBV_ANY:
+        return result_failed;
+    case ASN_OSUBV_BIT:
+        break;
+    default:
+        break;
+    }
+
+    /* Figure out how far we should go */
+    rnd_bits = lengths[asn_random_between(
+        0, sizeof(lengths) / sizeof(lengths[0]) - 1)];
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+    if(!constraints || !constraints->per_constraints)
+        constraints = &td->encoding_constraints;
+    if(constraints->per_constraints) {
+        const asn_per_constraint_t *pc = &constraints->per_constraints->size;
+        if(pc->flags & APC_CONSTRAINED) {
+            long suggested_upper_bound = pc->upper_bound < (ssize_t)max_length
+                                             ? pc->upper_bound
+                                             : (ssize_t)max_length;
+            if(max_length < (size_t)pc->lower_bound) {
+                return result_skipped;
+            }
+            if(pc->flags & APC_EXTENSIBLE) {
+                switch(asn_random_between(0, 5)) {
+                case 0:
+                    if(pc->lower_bound > 0) {
+                        rnd_bits = pc->lower_bound - 1;
+                        break;
+                    }
+                    /* Fall through */
+                case 1:
+                    rnd_bits = pc->upper_bound + 1;
+                    break;
+                case 2:
+                    /* Keep rnd_bits from the table */
+                    if(rnd_bits < max_length) {
+                        break;
+                    }
+                    /* Fall through */
+                default:
+                    rnd_bits = asn_random_between(pc->lower_bound,
+                                                  suggested_upper_bound);
+                }
+            } else {
+                rnd_bits =
+                    asn_random_between(pc->lower_bound, suggested_upper_bound);
+            }
+        } else {
+            rnd_bits = asn_random_between(0, max_length - 1);
+        }
+    } else {
+#else
+    if(!constraints) constraints = &td->encoding_constraints;
+    {
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+        if(rnd_bits >= max_length) {
+            rnd_bits = asn_random_between(0, max_length - 1);
+        }
+    }
+
+    rnd_len = (rnd_bits + 7) / 8;
+    buf = CALLOC(1, rnd_len + 1);
+    if(!buf) return result_failed;
+
+    bend = &buf[rnd_len];
+
+    for(b = buf; b < bend; b++) {
+        *(uint8_t *)b = asn_random_between(0, 255);
+    }
+    *b = 0; /* Zero-terminate just in case. */
+
+    if(*sptr) {
+        st = *sptr;
+        FREEMEM(st->buf);
+    } else {
+        st = (BIT_STRING_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) {
+            FREEMEM(buf);
+            return result_failed;
+        }
+    }
+
+    st->buf = buf;
+    st->size = rnd_len;
+    st->bits_unused = (8 - (rnd_bits & 0x7)) & 0x7;
+    if(st->bits_unused) {
+        assert(st->size > 0);
+        st->buf[st->size-1] &= 0xff << st->bits_unused;
+    }
+
+    result_ok.length = st->size;
+    return result_ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_uper.c
new file mode 100644
index 000000000..7639674d3
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_uper.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BIT_STRING.h"
+
+#undef  RETURN
+#define RETURN(_code)                       \
+    do {                                    \
+        asn_dec_rval_t tmprval;             \
+        tmprval.code = _code;               \
+        tmprval.consumed = consumed_myself; \
+        return tmprval;                     \
+    } while(0)
+
+static asn_per_constraint_t asn_DEF_BIT_STRING_constraint_size = {
+    APC_SEMI_CONSTRAINED, -1, -1, 0, 0};
+
+asn_dec_rval_t
+BIT_STRING_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                       const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints, void **sptr,
+                       asn_per_data_t *pd) {
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_BIT_STRING_specs;
+    const asn_per_constraints_t *pc =
+        constraints ? constraints : td->encoding_constraints.per_constraints;
+    const asn_per_constraint_t *csiz;
+    asn_dec_rval_t rval = { RC_OK, 0 };
+    BIT_STRING_t *st = (BIT_STRING_t *)*sptr;
+    ssize_t consumed_myself = 0;
+    int repeat;
+
+    (void)opt_codec_ctx;
+
+    if(pc) {
+        csiz = &pc->size;
+    } else {
+        csiz = &asn_DEF_BIT_STRING_constraint_size;
+    }
+
+    if(specs->subvariant != ASN_OSUBV_BIT) {
+        ASN_DEBUG("Subvariant %d is not BIT OSUBV_BIT", specs->subvariant);
+        RETURN(RC_FAIL);
+    }
+
+    /*
+     * Allocate the string.
+     */
+    if(!st) {
+        st = (BIT_STRING_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) RETURN(RC_FAIL);
+    }
+
+    ASN_DEBUG("PER Decoding %s size %"ASN_PRIdMAX" .. %"ASN_PRIdMAX" bits %d",
+        csiz->flags & APC_EXTENSIBLE ? "extensible" : "non-extensible",
+        csiz->lower_bound, csiz->upper_bound, csiz->effective_bits);
+
+    if(csiz->flags & APC_EXTENSIBLE) {
+        int inext = per_get_few_bits(pd, 1);
+        if(inext < 0) RETURN(RC_WMORE);
+        if(inext) {
+            csiz = &asn_DEF_BIT_STRING_constraint_size;
+        }
+    }
+
+    if(csiz->effective_bits >= 0) {
+        FREEMEM(st->buf);
+        st->size = (csiz->upper_bound + 7) >> 3;
+        st->buf = (uint8_t *)MALLOC(st->size + 1);
+        if(!st->buf) { st->size = 0; RETURN(RC_FAIL); }
+    }
+
+    /* X.691, #16.5: zero-length encoding */
+    /* X.691, #16.6: short fixed length encoding (up to 2 octets) */
+    /* X.691, #16.7: long fixed length encoding (up to 64K octets) */
+    if(csiz->effective_bits == 0) {
+        int ret;
+        ASN_DEBUG("Encoding BIT STRING size %"ASN_PRIdMAX"", csiz->upper_bound);
+        ret = per_get_many_bits(pd, st->buf, 0, csiz->upper_bound);
+        if(ret < 0) RETURN(RC_WMORE);
+        consumed_myself += csiz->upper_bound;
+        st->buf[st->size] = 0;
+        st->bits_unused = (8 - (csiz->upper_bound & 0x7)) & 0x7;
+        RETURN(RC_OK);
+    }
+
+    st->size = 0;
+    do {
+        ssize_t raw_len;
+        ssize_t len_bytes;
+        ssize_t len_bits;
+        void *p;
+        int ret;
+
+        /* Get the PER length */
+        raw_len = uper_get_length(pd, csiz->effective_bits, csiz->lower_bound,
+                                  &repeat);
+        if(raw_len < 0) RETURN(RC_WMORE);
+        if(raw_len == 0 && st->buf) break;
+
+        ASN_DEBUG("Got PER length eb %ld, len %ld, %s (%s)",
+            (long)csiz->effective_bits, (long)raw_len,
+            repeat ? "repeat" : "once", td->name);
+        len_bits = raw_len;
+        len_bytes = (len_bits + 7) >> 3;
+        if(len_bits & 0x7) st->bits_unused = 8 - (len_bits & 0x7);
+        /* len_bits be multiple of 16K if repeat is set */
+        p = REALLOC(st->buf, st->size + len_bytes + 1);
+        if(!p) RETURN(RC_FAIL);
+        st->buf = (uint8_t *)p;
+
+        ret = per_get_many_bits(pd, &st->buf[st->size], 0, len_bits);
+        if(ret < 0) RETURN(RC_WMORE);
+        st->size += len_bytes;
+    } while(repeat);
+    st->buf[st->size] = 0;  /* nul-terminate */
+
+    return rval;
+}
+
+asn_enc_rval_t
+BIT_STRING_encode_uper(const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints,
+                       const void *sptr, asn_per_outp_t *po) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_BIT_STRING_specs;
+    const asn_per_constraints_t *pc =
+        constraints ? constraints : td->encoding_constraints.per_constraints;
+    const asn_per_constraint_t *csiz;
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+    BIT_STRING_t compact_bstr;  /* Do not modify this directly! */
+    asn_enc_rval_t er = { 0, 0, 0 };
+    int inext = 0;  /* Lies not within extension root */
+    size_t size_in_bits;
+    const uint8_t *buf;
+    int ret;
+    int ct_extensible;
+
+    if(!st || (!st->buf && st->size))
+        ASN__ENCODE_FAILED;
+
+    if(specs->subvariant == ASN_OSUBV_BIT) {
+        if((st->size == 0 && st->bits_unused) || (st->bits_unused & ~7))
+            ASN__ENCODE_FAILED;
+    } else {
+        ASN__ENCODE_FAILED;
+    }
+
+    if(pc) {
+        csiz = &pc->size;
+    } else {
+        csiz = &asn_DEF_BIT_STRING_constraint_size;
+    }
+    ct_extensible = csiz->flags & APC_EXTENSIBLE;
+
+    /* Figure out the size without the trailing bits */
+    st = BIT_STRING__compactify(st, &compact_bstr);
+    size_in_bits = 8 * st->size - st->bits_unused;
+
+    ASN_DEBUG(
+        "Encoding %s into %" ASN_PRI_SIZE " bits"
+        " (%"ASN_PRIdMAX"..%"ASN_PRIdMAX", effective %d)%s",
+        td->name, size_in_bits, csiz->lower_bound, csiz->upper_bound,
+        csiz->effective_bits, ct_extensible ? " EXT" : "");
+
+    /* Figure out whether size lies within PER visible constraint */
+
+    if(csiz->effective_bits >= 0) {
+        if((ssize_t)size_in_bits > csiz->upper_bound) {
+            if(ct_extensible) {
+                csiz = &asn_DEF_BIT_STRING_constraint_size;
+                inext = 1;
+            } else {
+                ASN__ENCODE_FAILED;
+            }
+        }
+    } else {
+        inext = 0;
+    }
+
+    if(ct_extensible) {
+        /* Declare whether length is [not] within extension root */
+        if(per_put_few_bits(po, inext, 1))
+            ASN__ENCODE_FAILED;
+    }
+
+    if(csiz->effective_bits >= 0 && !inext) {
+        int add_trailer = (ssize_t)size_in_bits < csiz->lower_bound;
+        ASN_DEBUG(
+            "Encoding %" ASN_PRI_SIZE " bytes (%"ASN_PRIdMAX"), length (in %d bits) trailer %d; actual "
+            "value %" ASN_PRI_SSIZE "",
+            st->size, size_in_bits - csiz->lower_bound, csiz->effective_bits,
+            add_trailer,
+            add_trailer ? 0 : (ssize_t)size_in_bits - (ssize_t)csiz->lower_bound);
+        ret = per_put_few_bits(
+            po, add_trailer ? 0 : (ssize_t)size_in_bits - csiz->lower_bound,
+            csiz->effective_bits);
+        if(ret) ASN__ENCODE_FAILED;
+        ret = per_put_many_bits(po, st->buf, size_in_bits);
+        if(ret) ASN__ENCODE_FAILED;
+        if(add_trailer) {
+            static const uint8_t zeros[16];
+            size_t trailing_zero_bits = csiz->lower_bound - size_in_bits;
+            while(trailing_zero_bits > 0) {
+                if(trailing_zero_bits > 8 * sizeof(zeros)) {
+                    ret = per_put_many_bits(po, zeros, 8 * sizeof(zeros));
+                    trailing_zero_bits -= 8 * sizeof(zeros);
+                } else {
+                    ret = per_put_many_bits(po, zeros, trailing_zero_bits);
+                    trailing_zero_bits = 0;
+                }
+                if(ret) ASN__ENCODE_FAILED;
+            }
+        }
+        ASN__ENCODED_OK(er);
+    }
+
+    ASN_DEBUG("Encoding %" ASN_PRI_SIZE " bytes", st->size);
+
+    buf = st->buf;
+    do {
+        int need_eom = 0;
+        ssize_t maySave = uper_put_length(po, size_in_bits, &need_eom);
+        if(maySave < 0) ASN__ENCODE_FAILED;
+
+        ASN_DEBUG("Encoding %" ASN_PRI_SSIZE " of %" ASN_PRI_SIZE "", maySave, size_in_bits);
+
+        ret = per_put_many_bits(po, buf, maySave);
+        if(ret) ASN__ENCODE_FAILED;
+
+        buf += maySave >> 3;
+        size_in_bits -= maySave;
+        assert(!(maySave & 0x07) || !size_in_bits);
+        if(need_eom && uper_put_length(po, 0, 0))
+            ASN__ENCODE_FAILED; /* End of Message length */
+    } while(size_in_bits);
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_xer.c
new file mode 100644
index 000000000..fc63c2514
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BIT_STRING_xer.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BIT_STRING.h"
+
+static const char *_bit_pattern[16] = {
+    "0000", "0001", "0010", "0011", "0100", "0101", "0110", "0111",
+    "1000", "1001", "1010", "1011", "1100", "1101", "1110", "1111"
+};
+
+asn_enc_rval_t
+BIT_STRING_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                      int ilevel, enum xer_encoder_flags_e flags,
+                      asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0, 0, 0};
+    char scratch[128];
+    char *p = scratch;
+    char *scend = scratch + (sizeof(scratch) - 10);
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+    int xcan = (flags & XER_F_CANONICAL);
+    uint8_t *buf;
+    uint8_t *end;
+
+    if(!st || !st->buf)
+        ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    buf = st->buf;
+    end = buf + st->size - 1;  /* Last byte is special */
+
+    /*
+     * Binary dump
+     */
+    for(; buf < end; buf++) {
+        int v = *buf;
+        int nline = xcan?0:(((buf - st->buf) % 8) == 0);
+        if(p >= scend || nline) {
+            ASN__CALLBACK(scratch, p - scratch);
+            p = scratch;
+            if(nline) ASN__TEXT_INDENT(1, ilevel);
+        }
+        memcpy(p + 0, _bit_pattern[v >> 4], 4);
+        memcpy(p + 4, _bit_pattern[v & 0x0f], 4);
+        p += 8;
+    }
+
+    if(!xcan && ((buf - st->buf) % 8) == 0)
+        ASN__TEXT_INDENT(1, ilevel);
+    ASN__CALLBACK(scratch, p - scratch);
+    p = scratch;
+
+    if(buf == end) {
+        int v = *buf;
+        int ubits = st->bits_unused;
+        int i;
+        for(i = 7; i >= ubits; i--)
+            *p++ = (v & (1 << i)) ? 0x31 : 0x30;
+        ASN__CALLBACK(scratch, p - scratch);
+    }
+
+    if(!xcan) ASN__TEXT_INDENT(1, ilevel - 1);
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN.c
new file mode 100644
index 000000000..1fbd4e6db
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN.c
@@ -0,0 +1,160 @@
+/*-
+ * Copyright (c) 2003, 2005 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BOOLEAN.h"
+
+/*
+ * BOOLEAN basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_BOOLEAN_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (1 << 2))
+};
+asn_TYPE_operation_t asn_OP_BOOLEAN = {
+    BOOLEAN_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    BOOLEAN_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    BOOLEAN_compare,
+    BOOLEAN_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    BOOLEAN_decode_ber,
+    BOOLEAN_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    BOOLEAN_decode_xer,
+    BOOLEAN_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    BOOLEAN_decode_jer,
+    BOOLEAN_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    BOOLEAN_decode_oer,
+    BOOLEAN_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    BOOLEAN_decode_uper,  /* Unaligned PER decoder */
+    BOOLEAN_encode_uper,  /* Unaligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    BOOLEAN_decode_aper,  /* Aligned PER decoder */
+    BOOLEAN_encode_aper,  /* Aligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    BOOLEAN_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_BOOLEAN = {
+    "BOOLEAN",
+    "BOOLEAN",
+    &asn_OP_BOOLEAN,
+    asn_DEF_BOOLEAN_tags,
+    sizeof(asn_DEF_BOOLEAN_tags) / sizeof(asn_DEF_BOOLEAN_tags[0]),
+    asn_DEF_BOOLEAN_tags,  /* Same as above */
+    sizeof(asn_DEF_BOOLEAN_tags) / sizeof(asn_DEF_BOOLEAN_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_no_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
+
+void
+BOOLEAN_free(const asn_TYPE_descriptor_t *td, void *ptr,
+             enum asn_struct_free_method method) {
+    if(td && ptr) {
+        switch(method) {
+        case ASFM_FREE_EVERYTHING:
+            FREEMEM(ptr);
+            break;
+        case ASFM_FREE_UNDERLYING:
+            break;
+        case ASFM_FREE_UNDERLYING_AND_RESET:
+            memset(ptr, 0, sizeof(BOOLEAN_t));
+            break;
+        }
+    }
+}
+
+int
+BOOLEAN_compare(const asn_TYPE_descriptor_t *td, const void *aptr,
+                const void *bptr) {
+    const BOOLEAN_t *a = aptr;
+    const BOOLEAN_t *b = bptr;
+
+    (void)td;
+
+    if(a && b) {
+        if(!*a == !*b) {    /* TRUE can be encoded by any non-zero byte. */
+            return 0;
+        } else if(!*a) {
+            return -1;
+        } else {
+            return 1;
+        }
+    } else if(!a) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+int
+BOOLEAN_copy(const asn_TYPE_descriptor_t *td, void **aptr,
+             const void *bptr) {
+    BOOLEAN_t *a = *aptr;
+    const BOOLEAN_t *b = bptr;
+
+    (void)td;
+
+    if(!b) {
+        if(a) {
+            FREEMEM(a);
+            *aptr = 0;
+        }
+        return 0;
+    }
+
+    if(!a) {
+        a = *aptr = MALLOC(sizeof(BOOLEAN_t));
+        if(!a) return -1;
+    }
+
+    *a = *b;
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN.h /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN.h
new file mode 100644
index 000000000..b634aab9c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN.h
@@ -0,0 +1,72 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_BOOLEAN_H_
+#define	_BOOLEAN_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The underlying integer may contain various values, but everything
+ * non-zero is capped to 0xff by the DER encoder. The BER decoder may
+ * yield non-zero values different from 1, beware.
+ */
+typedef unsigned BOOLEAN_t;
+
+extern asn_TYPE_descriptor_t asn_DEF_BOOLEAN;
+extern asn_TYPE_operation_t asn_OP_BOOLEAN;
+
+asn_struct_free_f BOOLEAN_free;
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f BOOLEAN_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f BOOLEAN_compare;
+asn_struct_copy_f    BOOLEAN_copy;
+
+#define BOOLEAN_constraint asn_generic_no_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+ber_type_decoder_f BOOLEAN_decode_ber;
+der_type_encoder_f BOOLEAN_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f BOOLEAN_decode_xer;
+xer_type_encoder_f BOOLEAN_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f BOOLEAN_decode_jer;
+jer_type_encoder_f BOOLEAN_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f BOOLEAN_decode_oer;
+oer_type_encoder_f BOOLEAN_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f BOOLEAN_decode_uper;
+per_type_encoder_f BOOLEAN_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f BOOLEAN_decode_aper;
+per_type_encoder_f BOOLEAN_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f BOOLEAN_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _BOOLEAN_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_aper.c
new file mode 100644
index 000000000..bf9d15a69
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_aper.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BOOLEAN.h"
+
+asn_dec_rval_t
+BOOLEAN_decode_aper(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+    asn_dec_rval_t rv;
+    BOOLEAN_t *st = (BOOLEAN_t *)*sptr;
+
+    (void)opt_codec_ctx;
+    (void)constraints;
+    (void)td;
+
+    if(!st) {
+        st = (BOOLEAN_t *)(*sptr = MALLOC(sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    /*
+     * Extract a single bit
+     */
+    switch(per_get_few_bits(pd, 1)) {
+    case 1:
+        *st = 1;
+        break;
+    case 0:
+        *st = 0;
+        break;
+    case -1:
+    default:
+        ASN__DECODE_STARVED;
+    }
+
+    ASN_DEBUG("%s decoded as %s", td->name, *st ? "TRUE" : "FALSE");
+
+    rv.code = RC_OK;
+    rv.consumed = 1;
+    return rv;
+}
+
+asn_enc_rval_t
+BOOLEAN_encode_aper(const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints,
+                    const void *sptr, asn_per_outp_t *po) {
+    const BOOLEAN_t *st = (const BOOLEAN_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+
+    (void)constraints;
+
+    if(!st) ASN__ENCODE_FAILED;
+
+    if(per_put_few_bits(po, *st ? 1 : 0, 1))
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_ber.c
new file mode 100644
index 000000000..4540fb5ae
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_ber.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BOOLEAN.h"
+
+/*
+ * Decode BOOLEAN type.
+ */
+asn_dec_rval_t
+BOOLEAN_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td, void **bool_value,
+                   const void *buf_ptr, size_t size, int tag_mode) {
+    BOOLEAN_t *st = (BOOLEAN_t *)*bool_value;
+    asn_dec_rval_t rval;
+    ber_tlv_len_t length;
+    ber_tlv_len_t lidx;
+
+    if(st == NULL) {
+        st = (BOOLEAN_t *)(*bool_value = CALLOC(1, sizeof(*st)));
+        if(st == NULL) {
+            rval.code = RC_FAIL;
+            rval.consumed = 0;
+            return rval;
+        }
+    }
+
+    ASN_DEBUG("Decoding %s as BOOLEAN (tm=%d)",
+            td->name, tag_mode);
+
+    /*
+     * Check tags.
+     */
+    rval = ber_check_tags(opt_codec_ctx, td, 0, buf_ptr, size,
+        tag_mode, 0, &length, 0);
+    if(rval.code != RC_OK)
+        return rval;
+
+    ASN_DEBUG("Boolean length is %d bytes", (int)length);
+
+    buf_ptr = ((const char *)buf_ptr) + rval.consumed;
+    size -= rval.consumed;
+    if(length > (ber_tlv_len_t)size) {
+        rval.code = RC_WMORE;
+        rval.consumed = 0;
+        return rval;
+    }
+
+    /*
+     * Compute boolean value.
+     */
+    for(*st = 0, lidx = 0;
+        (lidx < length) && *st == 0; lidx++) {
+        /*
+         * Very simple approach: read bytes until the end or
+         * value is already TRUE.
+         * BOOLEAN is not supposed to contain meaningful data anyway.
+         */
+        *st |= ((const uint8_t *)buf_ptr)[lidx];
+    }
+
+    rval.code = RC_OK;
+    rval.consumed += length;
+
+    ASN_DEBUG("Took %ld/%ld bytes to encode %s, value=%d",
+        (long)rval.consumed, (long)length,
+        td->name, *st);
+
+    return rval;
+}
+
+asn_enc_rval_t
+BOOLEAN_encode_der(const asn_TYPE_descriptor_t *td, const void *sptr,
+                   int tag_mode, ber_tlv_tag_t tag, asn_app_consume_bytes_f *cb,
+                   void *app_key) {
+    asn_enc_rval_t erval = {0,0,0};
+    const BOOLEAN_t *st = (const BOOLEAN_t *)sptr;
+
+    erval.encoded = der_write_tags(td, 1, tag_mode, 0, tag, cb, app_key);
+    if(erval.encoded == -1) {
+        erval.failed_type = td;
+        erval.structure_ptr = sptr;
+        return erval;
+    }
+
+    if(cb) {
+        uint8_t bool_value;
+
+        bool_value = *st ? 0xff : 0; /* 0xff mandated by DER */
+
+        if(cb(&bool_value, 1, app_key) < 0) {
+            erval.encoded = -1;
+            erval.failed_type = td;
+            erval.structure_ptr = sptr;
+            return erval;
+        }
+    }
+
+    erval.encoded += 1;
+
+    ASN__ENCODED_OK(erval);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_jer.c
new file mode 100644
index 000000000..d161b604a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_jer.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+#include "BOOLEAN.h"
+#include <errno.h>
+
+/*
+ * Decode the chunk of JSON text encoding INTEGER.
+ */
+static enum jer_pbd_rval
+BOOLEAN__jer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,
+                         const void *chunk_buf, size_t chunk_size) {
+    BOOLEAN_t *st = (BOOLEAN_t *)sptr;
+    const char *p = (const char *)chunk_buf;
+
+    (void)td;
+    (void)chunk_size;
+
+    if(p[0] == 't' /* 'true' */) {
+        *st = 1;
+        return JPBD_BODY_CONSUMED;
+    } else if (p[0] == 'f' /* 'false' */) {
+        *st = 0;
+        return JPBD_BODY_CONSUMED;
+    } else {
+        return JPBD_BROKEN_ENCODING;
+    }
+}
+
+
+asn_dec_rval_t
+BOOLEAN_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_jer_constraints_t* constraints,
+                   void **sptr, const void *buf_ptr, size_t size) {
+    return jer_decode_primitive(opt_codec_ctx, td,
+                                sptr, sizeof(BOOLEAN_t), buf_ptr, size,
+                                BOOLEAN__jer_body_decode);
+}
+
+
+asn_enc_rval_t
+BOOLEAN_encode_jer(const asn_TYPE_descriptor_t *td,
+                   const asn_jer_constraints_t *constraints,
+                   const void *sptr, int ilevel, enum jer_encoder_flags_e flags,
+                   asn_app_consume_bytes_f *cb, void *app_key) {
+    const BOOLEAN_t *st = (const BOOLEAN_t *)sptr;
+    asn_enc_rval_t er = {0, 0, 0};
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!st) ASN__ENCODE_FAILED;
+
+    if(*st) {
+        ASN__CALLBACK("true", 4);
+    } else {
+        ASN__CALLBACK("false", 5);
+    }
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_oer.c
new file mode 100644
index 000000000..99a2f3ea0
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_oer.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BOOLEAN.h"
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+BOOLEAN_encode_oer(const asn_TYPE_descriptor_t *td,
+                   const asn_oer_constraints_t *constraints, const void *sptr,
+                   asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = { 1, 0, 0 };
+    const BOOLEAN_t *st = sptr;
+    uint8_t bool_value = *st ? 0xff : 0; /* 0xff mandated by OER */
+
+    (void)td;
+    (void)constraints;  /* Constraints are unused in OER */
+
+    if(cb(&bool_value, 1, app_key) < 0) {
+        ASN__ENCODE_FAILED;
+    } else {
+        ASN__ENCODED_OK(er);
+    }
+}
+
+asn_dec_rval_t
+BOOLEAN_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_oer_constraints_t *constraints, void **sptr,
+                   const void *ptr, size_t size) {
+    asn_dec_rval_t ok = {RC_OK, 1};
+    BOOLEAN_t *st;
+
+    (void)opt_codec_ctx;
+    (void)td;
+    (void)constraints; /* Constraints are unused in OER */
+
+    if(size < 1) {
+        ASN__DECODE_STARVED;
+    }
+
+    if(!(st = *sptr)) {
+        st = (BOOLEAN_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    *st = *(const uint8_t *)ptr;
+
+    return ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_print.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_print.c
new file mode 100644
index 000000000..5bd1228c6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_print.c
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BOOLEAN.h"
+
+int
+BOOLEAN_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+              asn_app_consume_bytes_f *cb, void *app_key) {
+    const BOOLEAN_t *st = (const BOOLEAN_t *)sptr;
+    const char *buf;
+    size_t buflen;
+
+    (void)td;  /* Unused argument */
+    (void)ilevel;  /* Unused argument */
+
+    if(st) {
+        if(*st) {
+            buf = "TRUE";
+            buflen = 4;
+        } else {
+            buf = "FALSE";
+            buflen = 5;
+        }
+    } else {
+        buf = "<absent>";
+        buflen = 8;
+    }
+
+    return (cb(buf, buflen, app_key) < 0) ? -1 : 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_rfill.c
new file mode 100644
index 000000000..501ffe036
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_rfill.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BOOLEAN.h"
+
+asn_random_fill_result_t
+BOOLEAN_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                    const asn_encoding_constraints_t *constraints,
+                    size_t max_length) {
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    BOOLEAN_t *st = *sptr;
+
+    if(max_length == 0) return result_skipped;
+
+    if(st == NULL) {
+        st = (BOOLEAN_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(st == NULL) {
+            return result_failed;
+        }
+    }
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+    if(!constraints || !constraints->per_constraints)
+        constraints = &td->encoding_constraints;
+    if(constraints->per_constraints) {
+        const asn_per_constraint_t *pc = &constraints->per_constraints->value;
+        if(pc->flags & APC_CONSTRAINED) {
+            *st = asn_random_between(pc->lower_bound, pc->upper_bound);
+            return result_ok;
+        }
+    }
+#else
+    if(!constraints) constraints = &td->encoding_constraints;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+
+    /* Simulate booleans that are sloppily set and biased. */
+    switch(asn_random_between(0, 7)) {
+    case 0:
+    case 1:
+    case 2:
+        *st = 0; break;
+    case 3: *st = -1; break;
+    case 4: *st = 1; break;
+    case 5: *st = INT_MIN; break;
+    case 6: *st = INT_MAX; break;
+    default:
+        *st = asn_random_between(INT_MIN, INT_MAX);
+        break;
+    }
+    return result_ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_uper.c
new file mode 100644
index 000000000..f74b03015
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_uper.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "BOOLEAN.h"
+
+asn_dec_rval_t
+BOOLEAN_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                    const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints, void **sptr,
+                    asn_per_data_t *pd) {
+    asn_dec_rval_t rv;
+    BOOLEAN_t *st = (BOOLEAN_t *)*sptr;
+
+    (void)opt_codec_ctx;
+    (void)td;
+    (void)constraints;
+
+    if(!st) {
+        st = (BOOLEAN_t *)(*sptr = MALLOC(sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    /*
+     * Extract a single bit
+     */
+    switch(per_get_few_bits(pd, 1)) {
+    case 1: *st = 1; break;
+    case 0: *st = 0; break;
+    case -1: default: ASN__DECODE_STARVED;
+    }
+
+    ASN_DEBUG("%s decoded as %s", td->name, *st ? "TRUE" : "FALSE");
+
+    rv.code = RC_OK;
+    rv.consumed = 1;
+    return rv;
+}
+
+
+asn_enc_rval_t
+BOOLEAN_encode_uper(const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints, const void *sptr,
+                    asn_per_outp_t *po) {
+    const BOOLEAN_t *st = (const BOOLEAN_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+
+    (void)constraints;
+
+    if(!st) ASN__ENCODE_FAILED;
+
+    if(per_put_few_bits(po, *st ? 1 : 0, 1))
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_xer.c
new file mode 100644
index 000000000..818aa2673
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BOOLEAN_xer.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+#include "BOOLEAN.h"
+#include <errno.h>
+
+/*
+ * Decode the chunk of XML text encoding INTEGER.
+ */
+static enum xer_pbd_rval
+BOOLEAN__xer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,
+                         const void *chunk_buf, size_t chunk_size) {
+    BOOLEAN_t *st = (BOOLEAN_t *)sptr;
+    const char *p = (const char *)chunk_buf;
+
+    (void)td;
+
+    if(chunk_size && p[0] == 0x3c /* '<' */) {
+        switch(xer_check_tag(chunk_buf, chunk_size, "false")) {
+        case XCT_BOTH:
+            /* "<false/>" */
+            *st = 0;
+            break;
+        case XCT_UNKNOWN_BO:
+            if(xer_check_tag(chunk_buf, chunk_size, "true") != XCT_BOTH)
+                return XPBD_BROKEN_ENCODING;
+            /* "<true/>" */
+            *st = 1;  /* Or 0xff as in DER?.. */
+            break;
+        default:
+            return XPBD_BROKEN_ENCODING;
+        }
+        return XPBD_BODY_CONSUMED;
+    } else {
+        return XPBD_BROKEN_ENCODING;
+    }
+}
+
+
+asn_dec_rval_t
+BOOLEAN_decode_xer(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td, void **sptr,
+                   const char *opt_mname, const void *buf_ptr, size_t size) {
+    return xer_decode_primitive(opt_codec_ctx, td,
+                                sptr, sizeof(BOOLEAN_t), opt_mname, buf_ptr, size,
+                                BOOLEAN__xer_body_decode);
+}
+
+asn_enc_rval_t
+BOOLEAN_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                   int ilevel, enum xer_encoder_flags_e flags,
+                   asn_app_consume_bytes_f *cb, void *app_key) {
+    const BOOLEAN_t *st = (const BOOLEAN_t *)sptr;
+    asn_enc_rval_t er = {0, 0, 0};
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!st) ASN__ENCODE_FAILED;
+
+    if(*st) {
+        ASN__CALLBACK("<true/>", 7);
+    } else {
+        ASN__CALLBACK("<false/>", 8);
+    }
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignaling.c /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignaling.c
new file mode 100644
index 000000000..36fd16e56
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignaling.c
@@ -0,0 +1,78 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "BasicSignaling.h"
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_BasicSignaling_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_BasicSignaling_constr_1 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_BasicSignaling_1[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
+		0,
+		&asn_DEF_BasicSignalingProtocol,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_BasicSignaling_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static asn_SET_OF_specifics_t asn_SPC_BasicSignaling_specs_1 = {
+	sizeof(struct BasicSignaling),
+	offsetof(struct BasicSignaling, _asn_ctx),
+	1,	/* XER encoding is XMLValueList */
+};
+asn_TYPE_descriptor_t asn_DEF_BasicSignaling = {
+	"BasicSignaling",
+	"BasicSignaling",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_BasicSignaling_tags_1,
+	sizeof(asn_DEF_BasicSignaling_tags_1)
+		/sizeof(asn_DEF_BasicSignaling_tags_1[0]), /* 1 */
+	asn_DEF_BasicSignaling_tags_1,	/* Same as above */
+	sizeof(asn_DEF_BasicSignaling_tags_1)
+		/sizeof(asn_DEF_BasicSignaling_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_BasicSignaling_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_BasicSignaling_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_BasicSignaling_1,
+	1,	/* Single element */
+	&asn_SPC_BasicSignaling_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignaling.h /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignaling.h
new file mode 100644
index 000000000..61baa3a90
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignaling.h
@@ -0,0 +1,39 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_BasicSignaling_H_
+#define	_BasicSignaling_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "BasicSignalingProtocol.h"
+#include "asn_SEQUENCE_OF.h"
+#include "constr_SEQUENCE_OF.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* BasicSignaling */
+typedef struct BasicSignaling {
+	A_SEQUENCE_OF(BasicSignalingProtocol_t) list;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} BasicSignaling_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_BasicSignaling;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _BasicSignaling_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignalingProtocol.c /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignalingProtocol.c
new file mode 100644
index 000000000..ee4eaac68
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignalingProtocol.c
@@ -0,0 +1,75 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "BasicSignalingProtocol.h"
+
+/*
+ * This type is implemented using NativeEnumerated,
+ * so here we adjust the DEF accordingly.
+ */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_BasicSignalingProtocol_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_BasicSignalingProtocol_constr_1 CC_NOTUSED = {
+	{ APC_CONSTRAINED,	 2,  2,  0,  3 }	/* (0..3) */,
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static const asn_INTEGER_enum_map_t asn_MAP_BasicSignalingProtocol_value2enum_1[] = {
+	{ 0,	14,	"iec61851-1-ED2" },
+	{ 1,	14,	"iec61851-1-ED3" },
+	{ 2,	15,	"iec61851-23-ED1" },
+	{ 3,	15,	"iec61851-23-ED2" }
+};
+static const unsigned int asn_MAP_BasicSignalingProtocol_enum2value_1[] = {
+	0,	/* iec61851-1-ED2(0) */
+	1,	/* iec61851-1-ED3(1) */
+	2,	/* iec61851-23-ED1(2) */
+	3	/* iec61851-23-ED2(3) */
+};
+const asn_INTEGER_specifics_t asn_SPC_BasicSignalingProtocol_specs_1 = {
+	asn_MAP_BasicSignalingProtocol_value2enum_1,	/* "tag" => N; sorted by tag */
+	asn_MAP_BasicSignalingProtocol_enum2value_1,	/* N => "tag"; sorted by N */
+	4,	/* Number of elements in the maps */
+	0,	/* Enumeration is not extensible */
+	1,	/* Strict enumeration */
+	0,	/* Native long size */
+	0
+};
+static const ber_tlv_tag_t asn_DEF_BasicSignalingProtocol_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_descriptor_t asn_DEF_BasicSignalingProtocol = {
+	"BasicSignalingProtocol",
+	"BasicSignalingProtocol",
+	&asn_OP_NativeEnumerated,
+	asn_DEF_BasicSignalingProtocol_tags_1,
+	sizeof(asn_DEF_BasicSignalingProtocol_tags_1)
+		/sizeof(asn_DEF_BasicSignalingProtocol_tags_1[0]), /* 1 */
+	asn_DEF_BasicSignalingProtocol_tags_1,	/* Same as above */
+	sizeof(asn_DEF_BasicSignalingProtocol_tags_1)
+		/sizeof(asn_DEF_BasicSignalingProtocol_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_BasicSignalingProtocol_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_BasicSignalingProtocol_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		NativeEnumerated_constraint
+	},
+	0, 0,	/* Defined elsewhere */
+	&asn_SPC_BasicSignalingProtocol_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignalingProtocol.h /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignalingProtocol.h
new file mode 100644
index 000000000..1bfd1a6bb
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/BasicSignalingProtocol.h
@@ -0,0 +1,56 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_BasicSignalingProtocol_H_
+#define	_BasicSignalingProtocol_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeEnumerated.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Dependencies */
+typedef enum BasicSignalingProtocol {
+	BasicSignalingProtocol_iec61851_1_ED2	= 0,
+	BasicSignalingProtocol_iec61851_1_ED3	= 1,
+	BasicSignalingProtocol_iec61851_23_ED1	= 2,
+	BasicSignalingProtocol_iec61851_23_ED2	= 3
+} e_BasicSignalingProtocol;
+
+/* BasicSignalingProtocol */
+typedef long	 BasicSignalingProtocol_t;
+
+/* Implementation */
+extern asn_per_constraints_t asn_PER_type_BasicSignalingProtocol_constr_1;
+extern asn_TYPE_descriptor_t asn_DEF_BasicSignalingProtocol;
+extern const asn_INTEGER_specifics_t asn_SPC_BasicSignalingProtocol_specs_1;
+asn_struct_free_f BasicSignalingProtocol_free;
+asn_struct_print_f BasicSignalingProtocol_print;
+asn_constr_check_f BasicSignalingProtocol_constraint;
+ber_type_decoder_f BasicSignalingProtocol_decode_ber;
+der_type_encoder_f BasicSignalingProtocol_encode_der;
+xer_type_decoder_f BasicSignalingProtocol_decode_xer;
+xer_type_encoder_f BasicSignalingProtocol_encode_xer;
+jer_type_encoder_f BasicSignalingProtocol_encode_jer;
+oer_type_decoder_f BasicSignalingProtocol_decode_oer;
+oer_type_encoder_f BasicSignalingProtocol_encode_oer;
+per_type_decoder_f BasicSignalingProtocol_decode_uper;
+per_type_encoder_f BasicSignalingProtocol_encode_uper;
+per_type_decoder_f BasicSignalingProtocol_decode_aper;
+per_type_encoder_f BasicSignalingProtocol_encode_aper;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _BasicSignalingProtocol_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ChargingInterface.c /ext/source/modules/EVSE/EvseV2G/asn1/ChargingInterface.c
new file mode 100644
index 000000000..9a4306479
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ChargingInterface.c
@@ -0,0 +1,83 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "ChargingInterface.h"
+
+/*
+ * This type is implemented using NativeEnumerated,
+ * so here we adjust the DEF accordingly.
+ */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_ChargingInterface_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_ChargingInterface_constr_1 CC_NOTUSED = {
+	{ APC_CONSTRAINED,	 3,  3,  0,  7 }	/* (0..7) */,
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static const asn_INTEGER_enum_map_t asn_MAP_ChargingInterface_value2enum_1[] = {
+	{ 0,	4,	"nacs" },
+	{ 1,	4,	"ccs1" },
+	{ 2,	4,	"ccs2" },
+	{ 3,	7,	"chademo" },
+	{ 4,	6,	"chaoji" },
+	{ 5,	6,	"type-1" },
+	{ 6,	6,	"type-2" },
+	{ 7,	3,	"mcs" }
+};
+static const unsigned int asn_MAP_ChargingInterface_enum2value_1[] = {
+	1,	/* ccs1(1) */
+	2,	/* ccs2(2) */
+	3,	/* chademo(3) */
+	4,	/* chaoji(4) */
+	7,	/* mcs(7) */
+	0,	/* nacs(0) */
+	5,	/* type-1(5) */
+	6	/* type-2(6) */
+};
+static const asn_INTEGER_specifics_t asn_SPC_ChargingInterface_specs_1 = {
+	asn_MAP_ChargingInterface_value2enum_1,	/* "tag" => N; sorted by tag */
+	asn_MAP_ChargingInterface_enum2value_1,	/* N => "tag"; sorted by N */
+	8,	/* Number of elements in the maps */
+	0,	/* Enumeration is not extensible */
+	1,	/* Strict enumeration */
+	0,	/* Native long size */
+	0
+};
+static const ber_tlv_tag_t asn_DEF_ChargingInterface_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_descriptor_t asn_DEF_ChargingInterface = {
+	"ChargingInterface",
+	"ChargingInterface",
+	&asn_OP_NativeEnumerated,
+	asn_DEF_ChargingInterface_tags_1,
+	sizeof(asn_DEF_ChargingInterface_tags_1)
+		/sizeof(asn_DEF_ChargingInterface_tags_1[0]), /* 1 */
+	asn_DEF_ChargingInterface_tags_1,	/* Same as above */
+	sizeof(asn_DEF_ChargingInterface_tags_1)
+		/sizeof(asn_DEF_ChargingInterface_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_ChargingInterface_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_ChargingInterface_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		NativeEnumerated_constraint
+	},
+	0, 0,	/* Defined elsewhere */
+	&asn_SPC_ChargingInterface_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ChargingInterface.h /ext/source/modules/EVSE/EvseV2G/asn1/ChargingInterface.h
new file mode 100644
index 000000000..50fff2953
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ChargingInterface.h
@@ -0,0 +1,58 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_ChargingInterface_H_
+#define	_ChargingInterface_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeEnumerated.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Dependencies */
+typedef enum ChargingInterface {
+	ChargingInterface_nacs	= 0,
+	ChargingInterface_ccs1	= 1,
+	ChargingInterface_ccs2	= 2,
+	ChargingInterface_chademo	= 3,
+	ChargingInterface_chaoji	= 4,
+	ChargingInterface_type_1	= 5,
+	ChargingInterface_type_2	= 6,
+	ChargingInterface_mcs	= 7
+} e_ChargingInterface;
+
+/* ChargingInterface */
+typedef long	 ChargingInterface_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_ChargingInterface;
+asn_struct_free_f ChargingInterface_free;
+asn_struct_print_f ChargingInterface_print;
+asn_constr_check_f ChargingInterface_constraint;
+ber_type_decoder_f ChargingInterface_decode_ber;
+der_type_encoder_f ChargingInterface_encode_der;
+xer_type_decoder_f ChargingInterface_decode_xer;
+xer_type_encoder_f ChargingInterface_encode_xer;
+jer_type_encoder_f ChargingInterface_encode_jer;
+oer_type_decoder_f ChargingInterface_decode_oer;
+oer_type_encoder_f ChargingInterface_encode_oer;
+per_type_decoder_f ChargingInterface_decode_uper;
+per_type_encoder_f ChargingInterface_encode_uper;
+per_type_decoder_f ChargingInterface_decode_aper;
+per_type_encoder_f ChargingInterface_encode_aper;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _ChargingInterface_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ChargingStationCharacteristics.c /ext/source/modules/EVSE/EvseV2G/asn1/ChargingStationCharacteristics.c
new file mode 100644
index 000000000..53a4c6476
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ChargingStationCharacteristics.c
@@ -0,0 +1,177 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "ChargingStationCharacteristics.h"
+
+static int
+memb_evseID_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	size = st->size;
+	
+	if((size >= 1UL)) {
+		/* Constraint check succeeded */
+		return 0;
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+static int
+memb_seccSoftwareVersion_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	const UTF8String_t *st = (const UTF8String_t *)sptr;
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	size = UTF8String_length(st);
+	if((ssize_t)size < 0) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: UTF-8: broken encoding (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	if((size >= 1UL)) {
+		/* Constraint check succeeded */
+		return 0;
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_evseID_constr_2 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_evseID_constr_2 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_seccSoftwareVersion_constr_3 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(0..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_seccSoftwareVersion_constr_3 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_ChargingStationCharacteristics_1[] = {
+	{ ATF_POINTER, 2, offsetof(struct ChargingStationCharacteristics, evseID),
+		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
+		0,
+		&asn_DEF_OCTET_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_evseID_constr_2,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_evseID_constr_2,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_evseID_constraint_1
+		},
+		0, 0, /* No default value */
+		"evseID"
+		},
+	{ ATF_POINTER, 1, offsetof(struct ChargingStationCharacteristics, seccSoftwareVersion),
+		(ASN_TAG_CLASS_UNIVERSAL | (12 << 2)),
+		0,
+		&asn_DEF_UTF8String,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_seccSoftwareVersion_constr_3,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_seccSoftwareVersion_constr_3,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_seccSoftwareVersion_constraint_1
+		},
+		0, 0, /* No default value */
+		"seccSoftwareVersion"
+		},
+};
+static const int asn_MAP_ChargingStationCharacteristics_oms_1[] = { 0, 1 };
+static const ber_tlv_tag_t asn_DEF_ChargingStationCharacteristics_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_ChargingStationCharacteristics_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)), 0, 0, 0 }, /* evseID */
+    { (ASN_TAG_CLASS_UNIVERSAL | (12 << 2)), 1, 0, 0 } /* seccSoftwareVersion */
+};
+static asn_SEQUENCE_specifics_t asn_SPC_ChargingStationCharacteristics_specs_1 = {
+	sizeof(struct ChargingStationCharacteristics),
+	offsetof(struct ChargingStationCharacteristics, _asn_ctx),
+	asn_MAP_ChargingStationCharacteristics_tag2el_1,
+	2,	/* Count of tags in the map */
+	asn_MAP_ChargingStationCharacteristics_oms_1,	/* Optional members */
+	2, 0,	/* Root/Additions */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_ChargingStationCharacteristics = {
+	"ChargingStationCharacteristics",
+	"ChargingStationCharacteristics",
+	&asn_OP_SEQUENCE,
+	asn_DEF_ChargingStationCharacteristics_tags_1,
+	sizeof(asn_DEF_ChargingStationCharacteristics_tags_1)
+		/sizeof(asn_DEF_ChargingStationCharacteristics_tags_1[0]), /* 1 */
+	asn_DEF_ChargingStationCharacteristics_tags_1,	/* Same as above */
+	sizeof(asn_DEF_ChargingStationCharacteristics_tags_1)
+		/sizeof(asn_DEF_ChargingStationCharacteristics_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_ChargingStationCharacteristics_1,
+	2,	/* Elements count */
+	&asn_SPC_ChargingStationCharacteristics_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ChargingStationCharacteristics.h /ext/source/modules/EVSE/EvseV2G/asn1/ChargingStationCharacteristics.h
new file mode 100644
index 000000000..1f266b2d6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ChargingStationCharacteristics.h
@@ -0,0 +1,40 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_ChargingStationCharacteristics_H_
+#define	_ChargingStationCharacteristics_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "OCTET_STRING.h"
+#include "UTF8String.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ChargingStationCharacteristics */
+typedef struct ChargingStationCharacteristics {
+	OCTET_STRING_t	*evseID;	/* OPTIONAL */
+	UTF8String_t	*seccSoftwareVersion;	/* OPTIONAL */
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} ChargingStationCharacteristics_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_ChargingStationCharacteristics;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _ChargingStationCharacteristics_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ConductiveChargingInterfaceLimitations.c /ext/source/modules/EVSE/EvseV2G/asn1/ConductiveChargingInterfaceLimitations.c
new file mode 100644
index 000000000..802b16b04
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ConductiveChargingInterfaceLimitations.c
@@ -0,0 +1,72 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "ConductiveChargingInterfaceLimitations.h"
+
+static asn_TYPE_member_t asn_MBR_ConductiveChargingInterfaceLimitations_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct ConductiveChargingInterfaceLimitations, maximumContactorTemperature),
+		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
+		0,
+		&asn_DEF_NativeInteger,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"maximumContactorTemperature"
+		},
+};
+static const ber_tlv_tag_t asn_DEF_ConductiveChargingInterfaceLimitations_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_ConductiveChargingInterfaceLimitations_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 } /* maximumContactorTemperature */
+};
+static asn_SEQUENCE_specifics_t asn_SPC_ConductiveChargingInterfaceLimitations_specs_1 = {
+	sizeof(struct ConductiveChargingInterfaceLimitations),
+	offsetof(struct ConductiveChargingInterfaceLimitations, _asn_ctx),
+	asn_MAP_ConductiveChargingInterfaceLimitations_tag2el_1,
+	1,	/* Count of tags in the map */
+	0, 0, 0,	/* Optional elements (not needed) */
+	1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_ConductiveChargingInterfaceLimitations = {
+	"ConductiveChargingInterfaceLimitations",
+	"ConductiveChargingInterfaceLimitations",
+	&asn_OP_SEQUENCE,
+	asn_DEF_ConductiveChargingInterfaceLimitations_tags_1,
+	sizeof(asn_DEF_ConductiveChargingInterfaceLimitations_tags_1)
+		/sizeof(asn_DEF_ConductiveChargingInterfaceLimitations_tags_1[0]), /* 1 */
+	asn_DEF_ConductiveChargingInterfaceLimitations_tags_1,	/* Same as above */
+	sizeof(asn_DEF_ConductiveChargingInterfaceLimitations_tags_1)
+		/sizeof(asn_DEF_ConductiveChargingInterfaceLimitations_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_ConductiveChargingInterfaceLimitations_1,
+	1,	/* Elements count */
+	&asn_SPC_ConductiveChargingInterfaceLimitations_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ConductiveChargingInterfaceLimitations.h /ext/source/modules/EVSE/EvseV2G/asn1/ConductiveChargingInterfaceLimitations.h
new file mode 100644
index 000000000..11b94736d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ConductiveChargingInterfaceLimitations.h
@@ -0,0 +1,42 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_ConductiveChargingInterfaceLimitations_H_
+#define	_ConductiveChargingInterfaceLimitations_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeInteger.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ConductiveChargingInterfaceLimitations */
+typedef struct ConductiveChargingInterfaceLimitations {
+	long	 maximumContactorTemperature;
+	/*
+	 * This type is extensible,
+	 * possible extensions are below.
+	 */
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} ConductiveChargingInterfaceLimitations_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_ConductiveChargingInterfaceLimitations;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _ConductiveChargingInterfaceLimitations_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/DCChargingLimits.c /ext/source/modules/EVSE/EvseV2G/asn1/DCChargingLimits.c
new file mode 100644
index 000000000..d8741f240
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/DCChargingLimits.c
@@ -0,0 +1,93 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "DCChargingLimits.h"
+
+static asn_TYPE_member_t asn_MBR_DCChargingLimits_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct DCChargingLimits, maximumVoltage),
+		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
+		0,
+		&asn_DEF_NativeInteger,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"maximumVoltage"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct DCChargingLimits, minimumVoltage),
+		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
+		0,
+		&asn_DEF_NativeInteger,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"minimumVoltage"
+		},
+};
+static const ber_tlv_tag_t asn_DEF_DCChargingLimits_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_DCChargingLimits_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1 }, /* maximumVoltage */
+    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0 } /* minimumVoltage */
+};
+static asn_SEQUENCE_specifics_t asn_SPC_DCChargingLimits_specs_1 = {
+	sizeof(struct DCChargingLimits),
+	offsetof(struct DCChargingLimits, _asn_ctx),
+	asn_MAP_DCChargingLimits_tag2el_1,
+	2,	/* Count of tags in the map */
+	0, 0, 0,	/* Optional elements (not needed) */
+	2,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_DCChargingLimits = {
+	"DCChargingLimits",
+	"DCChargingLimits",
+	&asn_OP_SEQUENCE,
+	asn_DEF_DCChargingLimits_tags_1,
+	sizeof(asn_DEF_DCChargingLimits_tags_1)
+		/sizeof(asn_DEF_DCChargingLimits_tags_1[0]), /* 1 */
+	asn_DEF_DCChargingLimits_tags_1,	/* Same as above */
+	sizeof(asn_DEF_DCChargingLimits_tags_1)
+		/sizeof(asn_DEF_DCChargingLimits_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_DCChargingLimits_1,
+	2,	/* Elements count */
+	&asn_SPC_DCChargingLimits_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/DCChargingLimits.h /ext/source/modules/EVSE/EvseV2G/asn1/DCChargingLimits.h
new file mode 100644
index 000000000..ceb5c0951
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/DCChargingLimits.h
@@ -0,0 +1,43 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_DCChargingLimits_H_
+#define	_DCChargingLimits_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeInteger.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* DCChargingLimits */
+typedef struct DCChargingLimits {
+	long	 maximumVoltage;
+	long	 minimumVoltage;
+	/*
+	 * This type is extensible,
+	 * possible extensions are below.
+	 */
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} DCChargingLimits_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_DCChargingLimits;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _DCChargingLimits_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifier.c /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifier.c
new file mode 100644
index 000000000..35cd2bb7c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifier.c
@@ -0,0 +1,80 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "EMSPIdentifier.h"
+
+int
+EMSPIdentifier_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	size = st->size;
+	
+	if((size >= 1UL)) {
+		/* Constraint check succeeded */
+		return 0;
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+/*
+ * This type is implemented using OCTET_STRING,
+ * so here we adjust the DEF accordingly.
+ */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_EMSPIdentifier_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_EMSPIdentifier_constr_1 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static const ber_tlv_tag_t asn_DEF_EMSPIdentifier_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
+};
+asn_TYPE_descriptor_t asn_DEF_EMSPIdentifier = {
+	"EMSPIdentifier",
+	"EMSPIdentifier",
+	&asn_OP_OCTET_STRING,
+	asn_DEF_EMSPIdentifier_tags_1,
+	sizeof(asn_DEF_EMSPIdentifier_tags_1)
+		/sizeof(asn_DEF_EMSPIdentifier_tags_1[0]), /* 1 */
+	asn_DEF_EMSPIdentifier_tags_1,	/* Same as above */
+	sizeof(asn_DEF_EMSPIdentifier_tags_1)
+		/sizeof(asn_DEF_EMSPIdentifier_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_EMSPIdentifier_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_EMSPIdentifier_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		EMSPIdentifier_constraint
+	},
+	0, 0,	/* No members */
+	&asn_SPC_OCTET_STRING_specs	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifier.h /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifier.h
new file mode 100644
index 000000000..93da52a3b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifier.h
@@ -0,0 +1,47 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_EMSPIdentifier_H_
+#define	_EMSPIdentifier_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "OCTET_STRING.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* EMSPIdentifier */
+typedef OCTET_STRING_t	 EMSPIdentifier_t;
+
+/* Implementation */
+extern asn_per_constraints_t asn_PER_type_EMSPIdentifier_constr_1;
+extern asn_TYPE_descriptor_t asn_DEF_EMSPIdentifier;
+asn_struct_free_f EMSPIdentifier_free;
+asn_struct_print_f EMSPIdentifier_print;
+asn_constr_check_f EMSPIdentifier_constraint;
+ber_type_decoder_f EMSPIdentifier_decode_ber;
+der_type_encoder_f EMSPIdentifier_encode_der;
+xer_type_decoder_f EMSPIdentifier_decode_xer;
+xer_type_encoder_f EMSPIdentifier_encode_xer;
+jer_type_encoder_f EMSPIdentifier_encode_jer;
+oer_type_decoder_f EMSPIdentifier_decode_oer;
+oer_type_encoder_f EMSPIdentifier_encode_oer;
+per_type_decoder_f EMSPIdentifier_decode_uper;
+per_type_encoder_f EMSPIdentifier_encode_uper;
+per_type_decoder_f EMSPIdentifier_decode_aper;
+per_type_encoder_f EMSPIdentifier_encode_aper;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _EMSPIdentifier_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifiers.c /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifiers.c
new file mode 100644
index 000000000..281d2881f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifiers.c
@@ -0,0 +1,78 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "EMSPIdentifiers.h"
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_EMSPIdentifiers_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_EMSPIdentifiers_constr_1 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_EMSPIdentifiers_1[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
+		0,
+		&asn_DEF_EMSPIdentifier,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_EMSPIdentifiers_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static asn_SET_OF_specifics_t asn_SPC_EMSPIdentifiers_specs_1 = {
+	sizeof(struct EMSPIdentifiers),
+	offsetof(struct EMSPIdentifiers, _asn_ctx),
+	0,	/* XER encoding is XMLDelimitedItemList */
+};
+asn_TYPE_descriptor_t asn_DEF_EMSPIdentifiers = {
+	"EMSPIdentifiers",
+	"EMSPIdentifiers",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_EMSPIdentifiers_tags_1,
+	sizeof(asn_DEF_EMSPIdentifiers_tags_1)
+		/sizeof(asn_DEF_EMSPIdentifiers_tags_1[0]), /* 1 */
+	asn_DEF_EMSPIdentifiers_tags_1,	/* Same as above */
+	sizeof(asn_DEF_EMSPIdentifiers_tags_1)
+		/sizeof(asn_DEF_EMSPIdentifiers_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_EMSPIdentifiers_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_EMSPIdentifiers_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_EMSPIdentifiers_1,
+	1,	/* Single element */
+	&asn_SPC_EMSPIdentifiers_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifiers.h /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifiers.h
new file mode 100644
index 000000000..57694bd8d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EMSPIdentifiers.h
@@ -0,0 +1,39 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_EMSPIdentifiers_H_
+#define	_EMSPIdentifiers_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "EMSPIdentifier.h"
+#include "asn_SEQUENCE_OF.h"
+#include "constr_SEQUENCE_OF.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* EMSPIdentifiers */
+typedef struct EMSPIdentifiers {
+	A_SEQUENCE_OF(EMSPIdentifier_t) list;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} EMSPIdentifiers_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_EMSPIdentifiers;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _EMSPIdentifiers_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED.c /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED.c
new file mode 100644
index 000000000..c4eaaa895
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED.c
@@ -0,0 +1,95 @@
+/*-
+ * Copyright (c) 2003, 2005, 2006 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ENUMERATED.h"
+
+/*
+ * ENUMERATED basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_ENUMERATED_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_operation_t asn_OP_ENUMERATED = {
+    ASN__PRIMITIVE_TYPE_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    INTEGER_print,  /* Implemented in terms of INTEGER */
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    INTEGER_compare,  /* Implemented in terms of INTEGER */
+    INTEGER_copy,  /* Implemented in terms of INTEGER */
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    ber_decode_primitive,
+    INTEGER_encode_der,  /* Implemented in terms of INTEGER */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    INTEGER_decode_xer,  /* This is temporary! */
+    INTEGER_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    ENUMERATED_decode_jer,
+    INTEGER_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    ENUMERATED_decode_oer,
+    ENUMERATED_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    ENUMERATED_decode_uper,  /* Unaligned PER decoder */
+    ENUMERATED_encode_uper,  /* Unaligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    ENUMERATED_decode_aper,  /* Aligned PER decoder */
+    ENUMERATED_encode_aper,  /* Aligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    ENUMERATED_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_ENUMERATED = {
+    "ENUMERATED",
+    "ENUMERATED",
+    &asn_OP_ENUMERATED,
+    asn_DEF_ENUMERATED_tags,
+    sizeof(asn_DEF_ENUMERATED_tags) / sizeof(asn_DEF_ENUMERATED_tags[0]),
+    asn_DEF_ENUMERATED_tags,	/* Same as above */
+    sizeof(asn_DEF_ENUMERATED_tags) / sizeof(asn_DEF_ENUMERATED_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_no_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED.h /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED.h
new file mode 100644
index 000000000..d05238054
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED.h
@@ -0,0 +1,67 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_ENUMERATED_H_
+#define	_ENUMERATED_H_
+
+#include "INTEGER.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef INTEGER_t ENUMERATED_t;		/* Implemented via INTEGER */
+
+extern asn_TYPE_descriptor_t asn_DEF_ENUMERATED;
+extern asn_TYPE_operation_t asn_OP_ENUMERATED;
+
+#define ENUMERATED_free ASN__PRIMITIVE_TYPE_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+#define ENUMERATED_print INTEGER_print
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define ENUMERATED_compare INTEGER_compare
+#define ENUMERATED_copy    INTEGER_copy
+
+#define ENUMERATED_constraint asn_generic_no_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define ENUMERATED_decode_ber ber_decode_primitive
+#define ENUMERATED_encode_der INTEGER_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define ENUMERATED_decode_xer INTEGER_decode_xer
+#define ENUMERATED_encode_xer INTEGER_encode_xer
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f ENUMERATED_decode_jer;
+#define ENUMERATED_encode_jer INTEGER_encode_jer
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f ENUMERATED_decode_oer;
+oer_type_encoder_f ENUMERATED_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f ENUMERATED_decode_uper;
+per_type_encoder_f ENUMERATED_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f ENUMERATED_decode_aper;
+per_type_encoder_f ENUMERATED_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+#define ENUMERATED_random_fill INTEGER_random_fill
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _ENUMERATED_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_aper.c
new file mode 100644
index 000000000..b849c27ab
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_aper.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ENUMERATED.h"
+#include "NativeEnumerated.h"
+
+asn_dec_rval_t
+ENUMERATED_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                       const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+    asn_dec_rval_t rval;
+    ENUMERATED_t *st = (ENUMERATED_t *)*sptr;
+    long value;
+    void *vptr = &value;
+
+    if(!st) {
+        st = (ENUMERATED_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    rval = NativeEnumerated_decode_aper(opt_codec_ctx, td, constraints,
+                                        (void **)&vptr, pd);
+    if(rval.code == RC_OK)
+        if(asn_long2INTEGER(st, value))
+            rval.code = RC_FAIL;
+    return rval;
+}
+
+asn_enc_rval_t
+ENUMERATED_encode_aper(const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints,
+                       const void *sptr, asn_per_outp_t *po) {
+    const ENUMERATED_t *st = (const ENUMERATED_t *)sptr;
+    long value;
+
+    if(asn_INTEGER2long(st, &value))
+        ASN__ENCODE_FAILED;
+
+    return NativeEnumerated_encode_aper(td, constraints, &value, po);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_jer.c
new file mode 100644
index 000000000..97915b632
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_jer.c
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ENUMERATED.h"
+#include "INTEGER.h"
+
+struct e2v_key {
+    const char *start;
+    const char *stop;
+    const asn_INTEGER_enum_map_t *vemap;
+    const unsigned int *evmap;
+};
+static int
+ENUMERATED__jer_compar_enum2value(const void *kp, const void *am) {
+    const struct e2v_key *key = (const struct e2v_key *)kp;
+    const asn_INTEGER_enum_map_t *el = (const asn_INTEGER_enum_map_t *)am;
+    const char *ptr, *end, *name;
+
+    /* Remap the element (sort by different criterion) */
+    el = key->vemap + key->evmap[el - key->vemap];
+
+    /* Compare strings */
+    for(ptr = key->start, end = key->stop, name = el->enum_name;
+            ptr < end; ptr++, name++) {
+        if(*ptr != *name || !*name)
+            return *(const unsigned char *)ptr - *(const unsigned char *)name;
+    }
+    return name[0] ? -1 : 0;
+}
+
+static const asn_INTEGER_enum_map_t *
+ENUMERATED_jer_map_enum2value(const asn_INTEGER_specifics_t *specs, const char *lstart,
+                       const char *lstop) {
+    const asn_INTEGER_enum_map_t *el_found;
+    int count = specs ? specs->map_count : 0;
+    struct e2v_key key;
+    const char *lp;
+
+    if(!count) return NULL;
+
+    /* Guaranteed: assert(lstart < lstop); */
+    /* Figure out the tag name */
+    for(lstart++, lp = lstart; lp < lstop; lp++) {
+        switch(*lp) {
+        case 9: case 10: case 11: case 12: case 13: case 32: /* WSP */
+        case 0x22: /* '"' */
+            break;
+        default:
+            continue;
+        }
+        break;
+    }
+    if(lp == lstop) return NULL;  /* No tag found */
+    lstop = lp;
+
+    key.start = lstart;
+    key.stop = lstop;
+    key.vemap = specs->value2enum;
+    key.evmap = specs->enum2value;
+    el_found = (asn_INTEGER_enum_map_t *)bsearch(&key,
+        specs->value2enum, count, sizeof(specs->value2enum[0]),
+        ENUMERATED__jer_compar_enum2value);
+    if(el_found) {
+        /* Remap enum2value into value2enum */
+        el_found = key.vemap + key.evmap[el_found - key.vemap];
+    }
+    return el_found;
+}
+
+static enum jer_pbd_rval
+ENUMERATED__jer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,
+                         const void *chunk_buf, size_t chunk_size) {
+    INTEGER_t *st = (INTEGER_t *)sptr;
+    intmax_t dec_value;
+    const char *lp;
+    const char *lstart = (const char *)chunk_buf;
+    const char *lstop = lstart + chunk_size;
+    int decoded = 0;
+
+    for (lp = lstart; lp < lstop; ++lp) {
+        if (*lp == 0x22 /* '"' */) {
+            const asn_INTEGER_enum_map_t *el;
+            el = ENUMERATED_jer_map_enum2value(
+                    (const asn_INTEGER_specifics_t *)
+                    td->specifics, lstart, lstop);
+            if(el) {
+                ASN_DEBUG("Found \"%s\" => %ld",
+                        el->enum_name, el->nat_value);
+                dec_value = el->nat_value;
+                decoded = 1;
+                lp = lstop - 1;
+                continue;
+            }
+            ASN_DEBUG("Unknown identifier for ENUMERATED");
+        } else {
+            continue;
+        }
+    }
+
+    if (!decoded) {
+        return JPBD_BROKEN_ENCODING;;
+    }
+
+    /*
+     * Convert the result of parsing of enumeration into a BER representation.
+     */
+    if(asn_imax2INTEGER(st, dec_value)) {
+        ASN_DEBUG("ENUMERATED decode %s conversion failed", td->name);
+        return JPBD_SYSTEM_FAILURE;
+    }
+
+    return JPBD_BODY_CONSUMED;
+}
+
+asn_dec_rval_t
+ENUMERATED_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_jer_constraints_t *constraints,
+                   void **sptr, const void *buf_ptr, size_t size) {
+    return jer_decode_primitive(opt_codec_ctx, td,
+        sptr, sizeof(INTEGER_t),
+        buf_ptr, size, ENUMERATED__jer_body_decode);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_oer.c
new file mode 100644
index 000000000..b68ebd951
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_oer.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ENUMERATED.h"
+#include "NativeEnumerated.h"
+
+asn_dec_rval_t
+ENUMERATED_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                      const asn_TYPE_descriptor_t *td,
+                      const asn_oer_constraints_t *constraints, void **sptr,
+                      const void *ptr, size_t size) {
+    asn_dec_rval_t rval;
+    ENUMERATED_t *st = (ENUMERATED_t *)*sptr;
+    long value;
+    void *vptr = &value;
+
+    if(!st) {
+        st = (ENUMERATED_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    rval = NativeEnumerated_decode_oer(opt_codec_ctx, td, constraints,
+                                       (void **)&vptr, ptr, size);
+    if(rval.code == RC_OK) {
+        if(asn_long2INTEGER(st, value)) {
+            rval.code = RC_FAIL;
+        }
+    }
+    return rval;
+}
+
+asn_enc_rval_t
+ENUMERATED_encode_oer(const asn_TYPE_descriptor_t *td,
+                      const asn_oer_constraints_t *constraints,
+                      const void *sptr, asn_app_consume_bytes_f *cb,
+                      void *app_key) {
+    const ENUMERATED_t *st = sptr;
+    long value;
+
+    if(asn_INTEGER2long(st, &value)) {
+        ASN__ENCODE_FAILED;
+    }
+
+    return NativeEnumerated_encode_oer(td, constraints, &value, cb, app_key);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_uper.c
new file mode 100644
index 000000000..21f39da53
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ENUMERATED_uper.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ENUMERATED.h"
+#include "NativeEnumerated.h"
+
+asn_dec_rval_t
+ENUMERATED_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                       const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints, void **sptr,
+                       asn_per_data_t *pd) {
+    asn_dec_rval_t rval;
+    ENUMERATED_t *st = (ENUMERATED_t *)*sptr;
+    long value;
+    void *vptr = &value;
+
+    if(!st) {
+        st = (ENUMERATED_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    rval = NativeEnumerated_decode_uper(opt_codec_ctx, td, constraints,
+                                        (void **)&vptr, pd);
+    if(rval.code == RC_OK) {
+        if(asn_long2INTEGER(st, value)) {
+            rval.code = RC_FAIL;
+        }
+    }
+    return rval;
+}
+
+asn_enc_rval_t
+ENUMERATED_encode_uper(const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints,
+                       const void *sptr, asn_per_outp_t *po) {
+    const ENUMERATED_t *st = (const ENUMERATED_t *)sptr;
+    long value;
+
+    if(asn_INTEGER2long(st, &value)) {
+        ASN__ENCODE_FAILED;
+    }
+
+    return NativeEnumerated_encode_uper(td, constraints, &value, po);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EVCharacteristics.c /ext/source/modules/EVSE/EvseV2G/asn1/EVCharacteristics.c
new file mode 100644
index 000000000..b57f65c76
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EVCharacteristics.c
@@ -0,0 +1,177 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "EVCharacteristics.h"
+
+static int
+memb_vehicleIdentificationNumber_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	size = st->size;
+	
+	if((size == 17UL)) {
+		/* Constraint check succeeded */
+		return 0;
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+static int
+memb_evccSoftwareVersion_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	const UTF8String_t *st = (const UTF8String_t *)sptr;
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	size = UTF8String_length(st);
+	if((ssize_t)size < 0) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: UTF-8: broken encoding (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	if((size >= 1UL)) {
+		/* Constraint check succeeded */
+		return 0;
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_vehicleIdentificationNumber_constr_2 CC_NOTUSED = {
+	{ 0, 0 },
+	17	/* (SIZE(17..17)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_vehicleIdentificationNumber_constr_2 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_CONSTRAINED,	 0,  0,  17,  17 }	/* (SIZE(17..17)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_evccSoftwareVersion_constr_3 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(0..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_evccSoftwareVersion_constr_3 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_EVCharacteristics_1[] = {
+	{ ATF_POINTER, 2, offsetof(struct EVCharacteristics, vehicleIdentificationNumber),
+		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
+		0,
+		&asn_DEF_OCTET_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_vehicleIdentificationNumber_constr_2,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_vehicleIdentificationNumber_constr_2,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_vehicleIdentificationNumber_constraint_1
+		},
+		0, 0, /* No default value */
+		"vehicleIdentificationNumber"
+		},
+	{ ATF_POINTER, 1, offsetof(struct EVCharacteristics, evccSoftwareVersion),
+		(ASN_TAG_CLASS_UNIVERSAL | (12 << 2)),
+		0,
+		&asn_DEF_UTF8String,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_evccSoftwareVersion_constr_3,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_evccSoftwareVersion_constr_3,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_evccSoftwareVersion_constraint_1
+		},
+		0, 0, /* No default value */
+		"evccSoftwareVersion"
+		},
+};
+static const int asn_MAP_EVCharacteristics_oms_1[] = { 0, 1 };
+static const ber_tlv_tag_t asn_DEF_EVCharacteristics_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_EVCharacteristics_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)), 0, 0, 0 }, /* vehicleIdentificationNumber */
+    { (ASN_TAG_CLASS_UNIVERSAL | (12 << 2)), 1, 0, 0 } /* evccSoftwareVersion */
+};
+static asn_SEQUENCE_specifics_t asn_SPC_EVCharacteristics_specs_1 = {
+	sizeof(struct EVCharacteristics),
+	offsetof(struct EVCharacteristics, _asn_ctx),
+	asn_MAP_EVCharacteristics_tag2el_1,
+	2,	/* Count of tags in the map */
+	asn_MAP_EVCharacteristics_oms_1,	/* Optional members */
+	2, 0,	/* Root/Additions */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_EVCharacteristics = {
+	"EVCharacteristics",
+	"EVCharacteristics",
+	&asn_OP_SEQUENCE,
+	asn_DEF_EVCharacteristics_tags_1,
+	sizeof(asn_DEF_EVCharacteristics_tags_1)
+		/sizeof(asn_DEF_EVCharacteristics_tags_1[0]), /* 1 */
+	asn_DEF_EVCharacteristics_tags_1,	/* Same as above */
+	sizeof(asn_DEF_EVCharacteristics_tags_1)
+		/sizeof(asn_DEF_EVCharacteristics_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_EVCharacteristics_1,
+	2,	/* Elements count */
+	&asn_SPC_EVCharacteristics_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EVCharacteristics.h /ext/source/modules/EVSE/EvseV2G/asn1/EVCharacteristics.h
new file mode 100644
index 000000000..2d1b1b5b9
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EVCharacteristics.h
@@ -0,0 +1,40 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_EVCharacteristics_H_
+#define	_EVCharacteristics_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "OCTET_STRING.h"
+#include "UTF8String.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* EVCharacteristics */
+typedef struct EVCharacteristics {
+	OCTET_STRING_t	*vehicleIdentificationNumber;	/* OPTIONAL */
+	UTF8String_t	*evccSoftwareVersion;	/* OPTIONAL */
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} EVCharacteristics_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_EVCharacteristics;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _EVCharacteristics_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EXTERNAL.c /ext/source/modules/EVSE/EvseV2G/asn1/EXTERNAL.c
new file mode 100644
index 000000000..b6a05d99b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EXTERNAL.c
@@ -0,0 +1,255 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ASN1C-UsefulInformationObjectClasses"
+ * 	found in "/usr/local/share/asn1c/standard-modules/ASN1C-UsefulInformationObjectClasses.asn1"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "EXTERNAL.h"
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_encoding_constr_5 CC_NOTUSED = {
+	{ 0, 0 },
+	-1};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_encoding_constr_5 CC_NOTUSED = {
+	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_encoding_5[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct encoding, choice.single_ASN1_type),
+		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
+		+1,	/* EXPLICIT tag at current level */
+		&asn_DEF_ANY,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"single-ASN1-type"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct encoding, choice.octet_aligned),
+		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
+		-1,	/* IMPLICIT tag at current level */
+		&asn_DEF_OCTET_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"octet-aligned"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct encoding, choice.arbitrary),
+		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
+		-1,	/* IMPLICIT tag at current level */
+		&asn_DEF_BIT_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"arbitrary"
+		},
+};
+static const asn_TYPE_tag2member_t asn_MAP_encoding_tag2el_5[] = {
+    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* single-ASN1-type */
+    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* octet-aligned */
+    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* arbitrary */
+};
+static asn_CHOICE_specifics_t asn_SPC_encoding_specs_5 = {
+	sizeof(struct encoding),
+	offsetof(struct encoding, _asn_ctx),
+	offsetof(struct encoding, present),
+	sizeof(((struct encoding *)0)->present),
+	asn_MAP_encoding_tag2el_5,
+	3,	/* Count of tags in the map */
+	0, 0,
+	-1	/* Extensions start */
+};
+static /* Use -fall-defs-global to expose */
+asn_TYPE_descriptor_t asn_DEF_encoding_5 = {
+	"encoding",
+	"encoding",
+	&asn_OP_CHOICE,
+	0,	/* No effective tags (pointer) */
+	0,	/* No effective tags (count) */
+	0,	/* No tags (pointer) */
+	0,	/* No tags (count) */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_encoding_constr_5,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_encoding_constr_5,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		CHOICE_constraint
+	},
+	asn_MBR_encoding_5,
+	3,	/* Elements count */
+	&asn_SPC_encoding_specs_5	/* Additional specs */
+};
+
+static asn_TYPE_member_t asn_MBR_EXTERNAL_1[] = {
+	{ ATF_POINTER, 3, offsetof(struct EXTERNAL, direct_reference),
+		(ASN_TAG_CLASS_UNIVERSAL | (6 << 2)),
+		0,
+		&asn_DEF_OBJECT_IDENTIFIER,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"direct-reference"
+		},
+	{ ATF_POINTER, 2, offsetof(struct EXTERNAL, indirect_reference),
+		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
+		0,
+		&asn_DEF_NativeInteger,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"indirect-reference"
+		},
+	{ ATF_POINTER, 1, offsetof(struct EXTERNAL, data_value_descriptor),
+		(ASN_TAG_CLASS_UNIVERSAL | (7 << 2)),
+		0,
+		&asn_DEF_ObjectDescriptor,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"data-value-descriptor"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct EXTERNAL, encoding),
+		-1 /* Ambiguous tag (CHOICE?) */,
+		0,
+		&asn_DEF_encoding_5,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"encoding"
+		},
+};
+static const int asn_MAP_EXTERNAL_oms_1[] = { 0, 1, 2 };
+static const ber_tlv_tag_t asn_DEF_EXTERNAL_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (8 << 2)),
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_EXTERNAL_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, 0, 0 }, /* indirect-reference */
+    { (ASN_TAG_CLASS_UNIVERSAL | (6 << 2)), 0, 0, 0 }, /* direct-reference */
+    { (ASN_TAG_CLASS_UNIVERSAL | (7 << 2)), 2, 0, 0 }, /* data-value-descriptor */
+    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 3, 0, 0 }, /* single-ASN1-type */
+    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 3, 0, 0 }, /* octet-aligned */
+    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 3, 0, 0 } /* arbitrary */
+};
+static asn_SEQUENCE_specifics_t asn_SPC_EXTERNAL_specs_1 = {
+	sizeof(struct EXTERNAL),
+	offsetof(struct EXTERNAL, _asn_ctx),
+	asn_MAP_EXTERNAL_tag2el_1,
+	6,	/* Count of tags in the map */
+	asn_MAP_EXTERNAL_oms_1,	/* Optional members */
+	3, 0,	/* Root/Additions */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_EXTERNAL = {
+	"EXTERNAL",
+	"EXTERNAL",
+	&asn_OP_SEQUENCE,
+	asn_DEF_EXTERNAL_tags_1,
+	sizeof(asn_DEF_EXTERNAL_tags_1)
+		/sizeof(asn_DEF_EXTERNAL_tags_1[0]) - 1, /* 1 */
+	asn_DEF_EXTERNAL_tags_1,	/* Same as above */
+	sizeof(asn_DEF_EXTERNAL_tags_1)
+		/sizeof(asn_DEF_EXTERNAL_tags_1[0]), /* 2 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_EXTERNAL_1,
+	4,	/* Elements count */
+	&asn_SPC_EXTERNAL_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EXTERNAL.h /ext/source/modules/EVSE/EvseV2G/asn1/EXTERNAL.h
new file mode 100644
index 000000000..9f9f54877
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EXTERNAL.h
@@ -0,0 +1,65 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ASN1C-UsefulInformationObjectClasses"
+ * 	found in "/usr/local/share/asn1c/standard-modules/ASN1C-UsefulInformationObjectClasses.asn1"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_EXTERNAL_H_
+#define	_EXTERNAL_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "OBJECT_IDENTIFIER.h"
+#include "NativeInteger.h"
+#include "ObjectDescriptor.h"
+#include "ANY.h"
+#include "OCTET_STRING.h"
+#include "BIT_STRING.h"
+#include "constr_CHOICE.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Dependencies */
+typedef enum encoding_PR {
+	encoding_PR_NOTHING,	/* No components present */
+	encoding_PR_single_ASN1_type,
+	encoding_PR_octet_aligned,
+	encoding_PR_arbitrary
+} encoding_PR;
+
+/* EXTERNAL */
+typedef struct EXTERNAL {
+	OBJECT_IDENTIFIER_t	*direct_reference;	/* OPTIONAL */
+	long	*indirect_reference;	/* OPTIONAL */
+	ObjectDescriptor_t	*data_value_descriptor;	/* OPTIONAL */
+	struct encoding {
+		encoding_PR present;
+		union EXTERNAL__encoding_u {
+			ANY_t	 single_ASN1_type;
+			OCTET_STRING_t	 octet_aligned;
+			BIT_STRING_t	 arbitrary;
+		} choice;
+		
+		/* Context for parsing across buffer boundaries */
+		asn_struct_ctx_t _asn_ctx;
+	} encoding;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} EXTERNAL_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_EXTERNAL;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _EXTERNAL_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EnergyTransferMode.c /ext/source/modules/EVSE/EvseV2G/asn1/EnergyTransferMode.c
new file mode 100644
index 000000000..92c7cc1a9
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EnergyTransferMode.c
@@ -0,0 +1,75 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "EnergyTransferMode.h"
+
+/*
+ * This type is implemented using NativeEnumerated,
+ * so here we adjust the DEF accordingly.
+ */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_EnergyTransferMode_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_EnergyTransferMode_constr_1 CC_NOTUSED = {
+	{ APC_CONSTRAINED,	 2,  2,  0,  3 }	/* (0..3) */,
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static const asn_INTEGER_enum_map_t asn_MAP_EnergyTransferMode_value2enum_1[] = {
+	{ 0,	2,	"dc" },
+	{ 1,	6,	"dc-bpt" },
+	{ 2,	2,	"ac" },
+	{ 3,	6,	"ac-bpt" }
+};
+static const unsigned int asn_MAP_EnergyTransferMode_enum2value_1[] = {
+	2,	/* ac(2) */
+	3,	/* ac-bpt(3) */
+	0,	/* dc(0) */
+	1	/* dc-bpt(1) */
+};
+const asn_INTEGER_specifics_t asn_SPC_EnergyTransferMode_specs_1 = {
+	asn_MAP_EnergyTransferMode_value2enum_1,	/* "tag" => N; sorted by tag */
+	asn_MAP_EnergyTransferMode_enum2value_1,	/* N => "tag"; sorted by N */
+	4,	/* Number of elements in the maps */
+	0,	/* Enumeration is not extensible */
+	1,	/* Strict enumeration */
+	0,	/* Native long size */
+	0
+};
+static const ber_tlv_tag_t asn_DEF_EnergyTransferMode_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_descriptor_t asn_DEF_EnergyTransferMode = {
+	"EnergyTransferMode",
+	"EnergyTransferMode",
+	&asn_OP_NativeEnumerated,
+	asn_DEF_EnergyTransferMode_tags_1,
+	sizeof(asn_DEF_EnergyTransferMode_tags_1)
+		/sizeof(asn_DEF_EnergyTransferMode_tags_1[0]), /* 1 */
+	asn_DEF_EnergyTransferMode_tags_1,	/* Same as above */
+	sizeof(asn_DEF_EnergyTransferMode_tags_1)
+		/sizeof(asn_DEF_EnergyTransferMode_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_EnergyTransferMode_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_EnergyTransferMode_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		NativeEnumerated_constraint
+	},
+	0, 0,	/* Defined elsewhere */
+	&asn_SPC_EnergyTransferMode_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/EnergyTransferMode.h /ext/source/modules/EVSE/EvseV2G/asn1/EnergyTransferMode.h
new file mode 100644
index 000000000..c5c8a2da4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/EnergyTransferMode.h
@@ -0,0 +1,56 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_EnergyTransferMode_H_
+#define	_EnergyTransferMode_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeEnumerated.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Dependencies */
+typedef enum EnergyTransferMode {
+	EnergyTransferMode_dc	= 0,
+	EnergyTransferMode_dc_bpt	= 1,
+	EnergyTransferMode_ac	= 2,
+	EnergyTransferMode_ac_bpt	= 3
+} e_EnergyTransferMode;
+
+/* EnergyTransferMode */
+typedef long	 EnergyTransferMode_t;
+
+/* Implementation */
+extern asn_per_constraints_t asn_PER_type_EnergyTransferMode_constr_1;
+extern asn_TYPE_descriptor_t asn_DEF_EnergyTransferMode;
+extern const asn_INTEGER_specifics_t asn_SPC_EnergyTransferMode_specs_1;
+asn_struct_free_f EnergyTransferMode_free;
+asn_struct_print_f EnergyTransferMode_print;
+asn_constr_check_f EnergyTransferMode_constraint;
+ber_type_decoder_f EnergyTransferMode_decode_ber;
+der_type_encoder_f EnergyTransferMode_encode_der;
+xer_type_decoder_f EnergyTransferMode_decode_xer;
+xer_type_encoder_f EnergyTransferMode_encode_xer;
+jer_type_encoder_f EnergyTransferMode_encode_jer;
+oer_type_decoder_f EnergyTransferMode_decode_oer;
+oer_type_encoder_f EnergyTransferMode_encode_oer;
+per_type_decoder_f EnergyTransferMode_decode_uper;
+per_type_encoder_f EnergyTransferMode_encode_uper;
+per_type_decoder_f EnergyTransferMode_decode_aper;
+per_type_encoder_f EnergyTransferMode_encode_aper;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _EnergyTransferMode_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/Extensions.c /ext/source/modules/EVSE/EvseV2G/asn1/Extensions.c
new file mode 100644
index 000000000..ffbb1c9e0
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/Extensions.c
@@ -0,0 +1,95 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "Extensions.h"
+
+static asn_TYPE_member_t asn_MBR_Extensions_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct Extensions, standardized),
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_StandardizedExtensions,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"standardized"
+		},
+	{ ATF_POINTER, 1, offsetof(struct Extensions, external),
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_ExternalExtensions,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"external"
+		},
+};
+static const int asn_MAP_Extensions_oms_1[] = { 1 };
+static const ber_tlv_tag_t asn_DEF_Extensions_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_Extensions_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 1 }, /* standardized */
+    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, -1, 0 } /* external */
+};
+static asn_SEQUENCE_specifics_t asn_SPC_Extensions_specs_1 = {
+	sizeof(struct Extensions),
+	offsetof(struct Extensions, _asn_ctx),
+	asn_MAP_Extensions_tag2el_1,
+	2,	/* Count of tags in the map */
+	asn_MAP_Extensions_oms_1,	/* Optional members */
+	1, 0,	/* Root/Additions */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_Extensions = {
+	"Extensions",
+	"Extensions",
+	&asn_OP_SEQUENCE,
+	asn_DEF_Extensions_tags_1,
+	sizeof(asn_DEF_Extensions_tags_1)
+		/sizeof(asn_DEF_Extensions_tags_1[0]), /* 1 */
+	asn_DEF_Extensions_tags_1,	/* Same as above */
+	sizeof(asn_DEF_Extensions_tags_1)
+		/sizeof(asn_DEF_Extensions_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_Extensions_1,
+	2,	/* Elements count */
+	&asn_SPC_Extensions_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/Extensions.h /ext/source/modules/EVSE/EvseV2G/asn1/Extensions.h
new file mode 100644
index 000000000..6cad9089b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/Extensions.h
@@ -0,0 +1,45 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_Extensions_H_
+#define	_Extensions_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "StandardizedExtensions.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Forward declarations */
+struct ExternalExtensions;
+
+/* Extensions */
+typedef struct Extensions {
+	StandardizedExtensions_t	 standardized;
+	struct ExternalExtensions	*external;	/* OPTIONAL */
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} Extensions_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_Extensions;
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Referred external types */
+#include "ExternalExtensions.h"
+
+#endif	/* _Extensions_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtension.c /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtension.c
new file mode 100644
index 000000000..92519bb64
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtension.c
@@ -0,0 +1,139 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "ExternalExtension.h"
+
+static int asn_DFL_3_cmp_1(const void *sptr) {
+	const BOOLEAN_t *st = sptr;
+	
+	if(!st) {
+		return -1; /* No value is not a default value */
+	}
+	
+	/* Test default value 1 */
+	return (*st != 1);
+}
+static int asn_DFL_3_set_1(void **sptr) {
+	BOOLEAN_t *st = *sptr;
+	
+	if(!st) {
+		st = (*sptr = CALLOC(1, sizeof(*st)));
+		if(!st) return -1;
+	}
+	
+	/* Install default value 1 */
+	*st = 1;
+	return 0;
+}
+asn_TYPE_member_t asn_MBR_ExternalExtension_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct ExternalExtension, externalExtensionID),
+		(ASN_TAG_CLASS_UNIVERSAL | (6 << 2)),
+		0,
+		&asn_DEF_OBJECT_IDENTIFIER,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"externalExtensionID"
+		},
+	{ ATF_POINTER, 1, offsetof(struct ExternalExtension, critical),
+		(ASN_TAG_CLASS_UNIVERSAL | (1 << 2)),
+		0,
+		&asn_DEF_BOOLEAN,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		&asn_DFL_3_cmp_1,	/* Compare DEFAULT 1 */
+		&asn_DFL_3_set_1,	/* Set DEFAULT 1 */
+		"critical"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct ExternalExtension, extensionValue),
+		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
+		0,
+		&asn_DEF_OCTET_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"extensionValue"
+		},
+};
+static const int asn_MAP_ExternalExtension_oms_1[] = { 1 };
+static const ber_tlv_tag_t asn_DEF_ExternalExtension_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_ExternalExtension_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (1 << 2)), 1, 0, 0 }, /* critical */
+    { (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)), 2, 0, 0 }, /* extensionValue */
+    { (ASN_TAG_CLASS_UNIVERSAL | (6 << 2)), 0, 0, 0 } /* externalExtensionID */
+};
+asn_SEQUENCE_specifics_t asn_SPC_ExternalExtension_specs_1 = {
+	sizeof(struct ExternalExtension),
+	offsetof(struct ExternalExtension, _asn_ctx),
+	asn_MAP_ExternalExtension_tag2el_1,
+	3,	/* Count of tags in the map */
+	asn_MAP_ExternalExtension_oms_1,	/* Optional members */
+	1, 0,	/* Root/Additions */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_ExternalExtension = {
+	"ExternalExtension",
+	"ExternalExtension",
+	&asn_OP_SEQUENCE,
+	asn_DEF_ExternalExtension_tags_1,
+	sizeof(asn_DEF_ExternalExtension_tags_1)
+		/sizeof(asn_DEF_ExternalExtension_tags_1[0]), /* 1 */
+	asn_DEF_ExternalExtension_tags_1,	/* Same as above */
+	sizeof(asn_DEF_ExternalExtension_tags_1)
+		/sizeof(asn_DEF_ExternalExtension_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_ExternalExtension_1,
+	3,	/* Elements count */
+	&asn_SPC_ExternalExtension_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtension.h /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtension.h
new file mode 100644
index 000000000..122703ccd
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtension.h
@@ -0,0 +1,44 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_ExternalExtension_H_
+#define	_ExternalExtension_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "OBJECT_IDENTIFIER.h"
+#include "BOOLEAN.h"
+#include "OCTET_STRING.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ExternalExtension */
+typedef struct ExternalExtension {
+	OBJECT_IDENTIFIER_t	 externalExtensionID;
+	BOOLEAN_t	*critical;	/* DEFAULT TRUE */
+	OCTET_STRING_t	 extensionValue;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} ExternalExtension_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_ExternalExtension;
+extern asn_SEQUENCE_specifics_t asn_SPC_ExternalExtension_specs_1;
+extern asn_TYPE_member_t asn_MBR_ExternalExtension_1[3];
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _ExternalExtension_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtensions.c /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtensions.c
new file mode 100644
index 000000000..aff911225
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtensions.c
@@ -0,0 +1,78 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "ExternalExtensions.h"
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_ExternalExtensions_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_ExternalExtensions_constr_1 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+asn_TYPE_member_t asn_MBR_ExternalExtensions_1[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_ExternalExtension,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_ExternalExtensions_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+asn_SET_OF_specifics_t asn_SPC_ExternalExtensions_specs_1 = {
+	sizeof(struct ExternalExtensions),
+	offsetof(struct ExternalExtensions, _asn_ctx),
+	0,	/* XER encoding is XMLDelimitedItemList */
+};
+asn_TYPE_descriptor_t asn_DEF_ExternalExtensions = {
+	"ExternalExtensions",
+	"ExternalExtensions",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_ExternalExtensions_tags_1,
+	sizeof(asn_DEF_ExternalExtensions_tags_1)
+		/sizeof(asn_DEF_ExternalExtensions_tags_1[0]), /* 1 */
+	asn_DEF_ExternalExtensions_tags_1,	/* Same as above */
+	sizeof(asn_DEF_ExternalExtensions_tags_1)
+		/sizeof(asn_DEF_ExternalExtensions_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_ExternalExtensions_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_ExternalExtensions_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_ExternalExtensions_1,
+	1,	/* Single element */
+	&asn_SPC_ExternalExtensions_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtensions.h /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtensions.h
new file mode 100644
index 000000000..a9beae696
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ExternalExtensions.h
@@ -0,0 +1,47 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_ExternalExtensions_H_
+#define	_ExternalExtensions_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "asn_SEQUENCE_OF.h"
+#include "constr_SEQUENCE_OF.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Forward declarations */
+struct ExternalExtension;
+
+/* ExternalExtensions */
+typedef struct ExternalExtensions {
+	A_SEQUENCE_OF(struct ExternalExtension) list;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} ExternalExtensions_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_ExternalExtensions;
+extern asn_SET_OF_specifics_t asn_SPC_ExternalExtensions_specs_1;
+extern asn_TYPE_member_t asn_MBR_ExternalExtensions_1[1];
+extern asn_per_constraints_t asn_PER_type_ExternalExtensions_constr_1;
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Referred external types */
+#include "ExternalExtension.h"
+
+#endif	/* _ExternalExtensions_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/GraphicString.c /ext/source/modules/EVSE/EvseV2G/asn1/GraphicString.c
new file mode 100644
index 000000000..cd27ee294
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/GraphicString.c
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 2003 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "GraphicString.h"
+
+/*
+ * GraphicString basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_GraphicString_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (25 << 2)),  /* [UNIVERSAL 25] IMPLICIT ...*/
+    (ASN_TAG_CLASS_UNIVERSAL | (4 << 2))    /* ... OCTET STRING */
+};
+asn_TYPE_operation_t asn_OP_GraphicString = {
+    OCTET_STRING_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    OCTET_STRING_print,  /* non-ascii string */
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    OCTET_STRING_compare,
+    OCTET_STRING_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    OCTET_STRING_decode_ber,  /* Implemented in terms of OCTET STRING */
+    OCTET_STRING_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OCTET_STRING_decode_xer_hex,
+    OCTET_STRING_encode_xer,  /* Can't expect it to be ASCII/UTF8 */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    OCTET_STRING_decode_jer_hex,
+    OCTET_STRING_encode_jer,  /* Can't expect it to be ASCII/UTF8 */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    OCTET_STRING_decode_oer,
+    OCTET_STRING_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    OCTET_STRING_decode_uper,  /* Implemented in terms of OCTET STRING */
+    OCTET_STRING_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    OCTET_STRING_decode_aper,  /* Implemented in terms of OCTET STRING */
+    OCTET_STRING_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    OCTET_STRING_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_GraphicString = {
+    "GraphicString",
+    "GraphicString",
+    &asn_OP_GraphicString,
+    asn_DEF_GraphicString_tags,
+    sizeof(asn_DEF_GraphicString_tags)
+      / sizeof(asn_DEF_GraphicString_tags[0]) - 1,
+    asn_DEF_GraphicString_tags,
+    sizeof(asn_DEF_GraphicString_tags)
+      / sizeof(asn_DEF_GraphicString_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_unknown_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/GraphicString.h /ext/source/modules/EVSE/EvseV2G/asn1/GraphicString.h
new file mode 100644
index 000000000..877d0078f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/GraphicString.h
@@ -0,0 +1,58 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_GraphicString_H_
+#define	_GraphicString_H_
+
+#include "OCTET_STRING.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef OCTET_STRING_t GraphicString_t;	/* Implemented via OCTET STRING */
+
+extern asn_TYPE_descriptor_t asn_DEF_GraphicString;
+extern asn_TYPE_operation_t asn_OP_GraphicString;
+
+#define GraphicString_free OCTET_STRING_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+#define GraphicString_print OCTET_STRING_print
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define GraphicString_compare OCTET_STRING_compare
+#define GraphicString_copy    OCTET_STRING_copy
+
+#define GraphicString_constraint asn_generic_unknown_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define GraphicString_decode_ber OCTET_STRING_decode_ber
+#define GraphicString_encode_der OCTET_STRING_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define GraphicString_decode_xer OCTET_STRING_decode_xer_hex
+#define GraphicString_encode_xer OCTET_STRING_encode_xer
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+#define GraphicString_decode_jer OCTET_STRING_decode_jer
+#define GraphicString_encode_jer OCTET_STRING_encode_jer
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+#define GraphicString_decode_uper OCTET_STRING_decode_uper
+#define GraphicString_encode_uper OCTET_STRING_encode_uper
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+#define GraphicString_decode_aper OCTET_STRING_decode_aper
+#define GraphicString_encode_aper OCTET_STRING_encode_aper
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _GraphicString_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/HLCProtocol.c /ext/source/modules/EVSE/EvseV2G/asn1/HLCProtocol.c
new file mode 100644
index 000000000..07046084d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/HLCProtocol.c
@@ -0,0 +1,75 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "HLCProtocol.h"
+
+/*
+ * This type is implemented using NativeEnumerated,
+ * so here we adjust the DEF accordingly.
+ */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_HLCProtocol_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_HLCProtocol_constr_1 CC_NOTUSED = {
+	{ APC_CONSTRAINED,	 2,  2,  0,  3 }	/* (0..3) */,
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static const asn_INTEGER_enum_map_t asn_MAP_HLCProtocol_value2enum_1[] = {
+	{ 0,	19,	"din-spec-70121-2014" },
+	{ 1,	16,	"iso-15118-2-2014" },
+	{ 2,	17,	"iso-15118-20-2022" },
+	{ 3,	18,	"sae-j2847-2-202309" }
+};
+static const unsigned int asn_MAP_HLCProtocol_enum2value_1[] = {
+	0,	/* din-spec-70121-2014(0) */
+	1,	/* iso-15118-2-2014(1) */
+	2,	/* iso-15118-20-2022(2) */
+	3	/* sae-j2847-2-202309(3) */
+};
+const asn_INTEGER_specifics_t asn_SPC_HLCProtocol_specs_1 = {
+	asn_MAP_HLCProtocol_value2enum_1,	/* "tag" => N; sorted by tag */
+	asn_MAP_HLCProtocol_enum2value_1,	/* N => "tag"; sorted by N */
+	4,	/* Number of elements in the maps */
+	0,	/* Enumeration is not extensible */
+	1,	/* Strict enumeration */
+	0,	/* Native long size */
+	0
+};
+static const ber_tlv_tag_t asn_DEF_HLCProtocol_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_descriptor_t asn_DEF_HLCProtocol = {
+	"HLCProtocol",
+	"HLCProtocol",
+	&asn_OP_NativeEnumerated,
+	asn_DEF_HLCProtocol_tags_1,
+	sizeof(asn_DEF_HLCProtocol_tags_1)
+		/sizeof(asn_DEF_HLCProtocol_tags_1[0]), /* 1 */
+	asn_DEF_HLCProtocol_tags_1,	/* Same as above */
+	sizeof(asn_DEF_HLCProtocol_tags_1)
+		/sizeof(asn_DEF_HLCProtocol_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_HLCProtocol_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_HLCProtocol_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		NativeEnumerated_constraint
+	},
+	0, 0,	/* Defined elsewhere */
+	&asn_SPC_HLCProtocol_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/HLCProtocol.h /ext/source/modules/EVSE/EvseV2G/asn1/HLCProtocol.h
new file mode 100644
index 000000000..f9b453dc8
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/HLCProtocol.h
@@ -0,0 +1,56 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_HLCProtocol_H_
+#define	_HLCProtocol_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeEnumerated.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Dependencies */
+typedef enum HLCProtocol {
+	HLCProtocol_din_spec_70121_2014	= 0,
+	HLCProtocol_iso_15118_2_2014	= 1,
+	HLCProtocol_iso_15118_20_2022	= 2,
+	HLCProtocol_sae_j2847_2_202309	= 3
+} e_HLCProtocol;
+
+/* HLCProtocol */
+typedef long	 HLCProtocol_t;
+
+/* Implementation */
+extern asn_per_constraints_t asn_PER_type_HLCProtocol_constr_1;
+extern asn_TYPE_descriptor_t asn_DEF_HLCProtocol;
+extern const asn_INTEGER_specifics_t asn_SPC_HLCProtocol_specs_1;
+asn_struct_free_f HLCProtocol_free;
+asn_struct_print_f HLCProtocol_print;
+asn_constr_check_f HLCProtocol_constraint;
+ber_type_decoder_f HLCProtocol_decode_ber;
+der_type_encoder_f HLCProtocol_encode_der;
+xer_type_decoder_f HLCProtocol_decode_xer;
+xer_type_encoder_f HLCProtocol_encode_xer;
+jer_type_encoder_f HLCProtocol_encode_jer;
+oer_type_decoder_f HLCProtocol_decode_oer;
+oer_type_encoder_f HLCProtocol_encode_oer;
+per_type_decoder_f HLCProtocol_decode_uper;
+per_type_encoder_f HLCProtocol_encode_uper;
+per_type_decoder_f HLCProtocol_decode_aper;
+per_type_encoder_f HLCProtocol_encode_aper;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _HLCProtocol_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunication.c /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunication.c
new file mode 100644
index 000000000..906d9a565
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunication.c
@@ -0,0 +1,78 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "HighLevelCommunication.h"
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_HighLevelCommunication_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_HighLevelCommunication_constr_1 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_HighLevelCommunication_1[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_HighLevelCommunicationTuple,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_HighLevelCommunication_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static asn_SET_OF_specifics_t asn_SPC_HighLevelCommunication_specs_1 = {
+	sizeof(struct HighLevelCommunication),
+	offsetof(struct HighLevelCommunication, _asn_ctx),
+	0,	/* XER encoding is XMLDelimitedItemList */
+};
+asn_TYPE_descriptor_t asn_DEF_HighLevelCommunication = {
+	"HighLevelCommunication",
+	"HighLevelCommunication",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_HighLevelCommunication_tags_1,
+	sizeof(asn_DEF_HighLevelCommunication_tags_1)
+		/sizeof(asn_DEF_HighLevelCommunication_tags_1[0]), /* 1 */
+	asn_DEF_HighLevelCommunication_tags_1,	/* Same as above */
+	sizeof(asn_DEF_HighLevelCommunication_tags_1)
+		/sizeof(asn_DEF_HighLevelCommunication_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_HighLevelCommunication_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_HighLevelCommunication_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_HighLevelCommunication_1,
+	1,	/* Single element */
+	&asn_SPC_HighLevelCommunication_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunication.h /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunication.h
new file mode 100644
index 000000000..f488ed83e
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunication.h
@@ -0,0 +1,44 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_HighLevelCommunication_H_
+#define	_HighLevelCommunication_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "asn_SEQUENCE_OF.h"
+#include "constr_SEQUENCE_OF.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Forward declarations */
+struct HighLevelCommunicationTuple;
+
+/* HighLevelCommunication */
+typedef struct HighLevelCommunication {
+	A_SEQUENCE_OF(struct HighLevelCommunicationTuple) list;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} HighLevelCommunication_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_HighLevelCommunication;
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Referred external types */
+#include "HighLevelCommunicationTuple.h"
+
+#endif	/* _HighLevelCommunication_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunicationTuple.c /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunicationTuple.c
new file mode 100644
index 000000000..92a61904b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunicationTuple.c
@@ -0,0 +1,201 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "HighLevelCommunicationTuple.h"
+
+static int
+memb_securityProfileTuple_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	/* Determine the number of elements */
+	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
+	
+	if((size >= 1UL)) {
+		/* Perform validation of the inner elements */
+		return SEQUENCE_OF_constraint(td, sptr, ctfailcb, app_key);
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_securityProfileTuple_constr_3 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_securityProfileTuple_constr_3 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_securityProfileTuple_constr_3 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_securityProfileTuple_constr_3 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_securityProfileTuple_3[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_SecurityProfileTuple,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_securityProfileTuple_tags_3[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static asn_SET_OF_specifics_t asn_SPC_securityProfileTuple_specs_3 = {
+	sizeof(struct securityProfileTuple),
+	offsetof(struct securityProfileTuple, _asn_ctx),
+	0,	/* XER encoding is XMLDelimitedItemList */
+};
+static /* Use -fall-defs-global to expose */
+asn_TYPE_descriptor_t asn_DEF_securityProfileTuple_3 = {
+	"securityProfileTuple",
+	"securityProfileTuple",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_securityProfileTuple_tags_3,
+	sizeof(asn_DEF_securityProfileTuple_tags_3)
+		/sizeof(asn_DEF_securityProfileTuple_tags_3[0]), /* 1 */
+	asn_DEF_securityProfileTuple_tags_3,	/* Same as above */
+	sizeof(asn_DEF_securityProfileTuple_tags_3)
+		/sizeof(asn_DEF_securityProfileTuple_tags_3[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_securityProfileTuple_constr_3,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_securityProfileTuple_constr_3,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_securityProfileTuple_3,
+	1,	/* Single element */
+	&asn_SPC_securityProfileTuple_specs_3	/* Additional specs */
+};
+
+asn_TYPE_member_t asn_MBR_HighLevelCommunicationTuple_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct HighLevelCommunicationTuple, hlcProtocol),
+		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
+		0,
+		&asn_DEF_HLCProtocol,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"hlcProtocol"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct HighLevelCommunicationTuple, securityProfileTuple),
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_securityProfileTuple_3,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_securityProfileTuple_constr_3,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_securityProfileTuple_constr_3,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_securityProfileTuple_constraint_1
+		},
+		0, 0, /* No default value */
+		"securityProfileTuple"
+		},
+};
+static const ber_tlv_tag_t asn_DEF_HighLevelCommunicationTuple_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_HighLevelCommunicationTuple_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 0, 0, 0 }, /* hlcProtocol */
+    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0, 0 } /* securityProfileTuple */
+};
+asn_SEQUENCE_specifics_t asn_SPC_HighLevelCommunicationTuple_specs_1 = {
+	sizeof(struct HighLevelCommunicationTuple),
+	offsetof(struct HighLevelCommunicationTuple, _asn_ctx),
+	asn_MAP_HighLevelCommunicationTuple_tag2el_1,
+	2,	/* Count of tags in the map */
+	0, 0, 0,	/* Optional elements (not needed) */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_HighLevelCommunicationTuple = {
+	"HighLevelCommunicationTuple",
+	"HighLevelCommunicationTuple",
+	&asn_OP_SEQUENCE,
+	asn_DEF_HighLevelCommunicationTuple_tags_1,
+	sizeof(asn_DEF_HighLevelCommunicationTuple_tags_1)
+		/sizeof(asn_DEF_HighLevelCommunicationTuple_tags_1[0]), /* 1 */
+	asn_DEF_HighLevelCommunicationTuple_tags_1,	/* Same as above */
+	sizeof(asn_DEF_HighLevelCommunicationTuple_tags_1)
+		/sizeof(asn_DEF_HighLevelCommunicationTuple_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_HighLevelCommunicationTuple_1,
+	2,	/* Elements count */
+	&asn_SPC_HighLevelCommunicationTuple_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunicationTuple.h /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunicationTuple.h
new file mode 100644
index 000000000..ba9153a8a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/HighLevelCommunicationTuple.h
@@ -0,0 +1,54 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_HighLevelCommunicationTuple_H_
+#define	_HighLevelCommunicationTuple_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "HLCProtocol.h"
+#include "asn_SEQUENCE_OF.h"
+#include "constr_SEQUENCE_OF.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Forward declarations */
+struct SecurityProfileTuple;
+
+/* HighLevelCommunicationTuple */
+typedef struct HighLevelCommunicationTuple {
+	HLCProtocol_t	 hlcProtocol;
+	struct securityProfileTuple {
+		A_SEQUENCE_OF(struct SecurityProfileTuple) list;
+		
+		/* Context for parsing across buffer boundaries */
+		asn_struct_ctx_t _asn_ctx;
+	} securityProfileTuple;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} HighLevelCommunicationTuple_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_HighLevelCommunicationTuple;
+extern asn_SEQUENCE_specifics_t asn_SPC_HighLevelCommunicationTuple_specs_1;
+extern asn_TYPE_member_t asn_MBR_HighLevelCommunicationTuple_1[2];
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Referred external types */
+#include "SecurityProfileTuple.h"
+
+#endif	/* _HighLevelCommunicationTuple_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER.c
new file mode 100644
index 000000000..2fab5eb5a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER.c
@@ -0,0 +1,808 @@
+/*
+ * Copyright (c) 2003-2019 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+#include <errno.h>
+#include <inttypes.h>
+
+/*
+ * INTEGER basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_INTEGER_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
+};
+asn_TYPE_operation_t asn_OP_INTEGER = {
+    INTEGER_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    INTEGER_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    INTEGER_compare,
+    INTEGER_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    ber_decode_primitive,
+    INTEGER_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    INTEGER_decode_xer,
+    INTEGER_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    INTEGER_decode_jer,
+    INTEGER_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    INTEGER_decode_oer,  /* OER decoder */
+    INTEGER_encode_oer,  /* Canonical OER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    INTEGER_decode_uper,  /* Unaligned PER decoder */
+    INTEGER_encode_uper,  /* Unaligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    INTEGER_decode_aper,  /* Aligned PER decoder */
+    INTEGER_encode_aper,  /* Aligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    INTEGER_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_INTEGER = {
+    "INTEGER",
+    "INTEGER",
+    &asn_OP_INTEGER,
+    asn_DEF_INTEGER_tags,
+    sizeof(asn_DEF_INTEGER_tags) / sizeof(asn_DEF_INTEGER_tags[0]),
+    asn_DEF_INTEGER_tags,	/* Same as above */
+    sizeof(asn_DEF_INTEGER_tags) / sizeof(asn_DEF_INTEGER_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_no_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
+
+/*
+ * INTEGER specific human-readable output.
+ */
+ssize_t
+INTEGER__dump(const asn_TYPE_descriptor_t *td, const INTEGER_t *st, asn_app_consume_bytes_f *cb, void *app_key, int plainOrXER) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+	char scratch[32];
+	uint8_t *buf = st->buf;
+	uint8_t *buf_end = st->buf + st->size;
+	intmax_t value = 0;
+	ssize_t wrote = 0;
+	char *p = NULL;
+	int ret = -1;
+
+	if(specs && specs->field_unsigned)
+		ret = asn_INTEGER2umax(st, (uintmax_t *)&value);
+	else
+		ret = asn_INTEGER2imax(st, &value);
+
+	/* Simple case: the integer size is small */
+	if(ret == 0) {
+		const asn_INTEGER_enum_map_t *el;
+		el = (value >= 0 || !specs || !specs->field_unsigned)
+			? INTEGER_map_value2enum(specs, value) : 0;
+		if(el) {
+			if(plainOrXER == 0)
+				return asn__format_to_callback(cb, app_key,
+					"%" ASN_PRIdMAX " (%s)", value, el->enum_name);
+			else
+				return asn__format_to_callback(cb, app_key,
+					"<%s/>", el->enum_name);
+		} else if(plainOrXER && specs && specs->strict_enumeration) {
+			ASN_DEBUG("ASN.1 forbids dealing with "
+				"unknown value of ENUMERATED type");
+			errno = EPERM;
+			return -1;
+		} else {
+            return asn__format_to_callback(cb, app_key,
+                                           (specs && specs->field_unsigned)
+                                               ? "%" ASN_PRIuMAX
+                                               : "%" ASN_PRIdMAX,
+                                           value);
+        }
+	} else if(plainOrXER && specs && specs->strict_enumeration) {
+		/*
+		 * Here and earlier, we cannot encode the ENUMERATED values
+		 * if there is no corresponding identifier.
+		 */
+		ASN_DEBUG("ASN.1 forbids dealing with "
+			"unknown value of ENUMERATED type");
+		errno = EPERM;
+		return -1;
+	}
+
+	/* Output in the long xx:yy:zz... format */
+	/* TODO: replace with generic algorithm (Knuth TAOCP Vol 2, 4.3.1) */
+	for(p = scratch; buf < buf_end; buf++) {
+		const char * const h2c = "0123456789ABCDEF";
+		if((p - scratch) >= (ssize_t)(sizeof(scratch) - 4)) {
+			/* Flush buffer */
+			if(cb(scratch, p - scratch, app_key) < 0)
+				return -1;
+			wrote += p - scratch;
+			p = scratch;
+		}
+		*p++ = h2c[*buf >> 4];
+		*p++ = h2c[*buf & 0x0F];
+		*p++ = 0x3a;	/* ":" */
+	}
+	if(p != scratch)
+		p--;	/* Remove the last ":" */
+
+	wrote += p - scratch;
+	return (cb(scratch, p - scratch, app_key) < 0) ? -1 : wrote;
+}
+
+static int
+INTEGER__compar_value2enum(const void *kp, const void *am) {
+	long a = *(const long *)kp;
+	const asn_INTEGER_enum_map_t *el = (const asn_INTEGER_enum_map_t *)am;
+	long b = el->nat_value;
+	if(a < b) return -1;
+	else if(a == b) return 0;
+	else return 1;
+}
+
+const asn_INTEGER_enum_map_t *
+INTEGER_map_value2enum(const asn_INTEGER_specifics_t *specs, long value) {
+	int count = specs ? specs->map_count : 0;
+	if(!count) return 0;
+	return (asn_INTEGER_enum_map_t *)bsearch(&value, specs->value2enum,
+		count, sizeof(specs->value2enum[0]),
+		INTEGER__compar_value2enum);
+}
+
+static intmax_t
+asn__integer_convert(const uint8_t *b, const uint8_t *end) {
+    uintmax_t value;
+
+    /* Perform the sign initialization */
+    /* Actually value = -(*b >> 7); gains nothing, yet unreadable! */
+    if((*b >> 7)) {
+        value = (uintmax_t)(-1);
+    } else {
+        value = 0;
+    }
+
+    /* Conversion engine */
+    for(; b < end; b++) {
+        value = (value << 8) | *b;
+    }
+
+    return value;
+}
+
+int
+asn_INTEGER2imax(const INTEGER_t *iptr, intmax_t *lptr) {
+	uint8_t *b, *end;
+	size_t size = 0;
+
+	/* Sanity checking */
+	if(!iptr || !iptr->buf || !lptr) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	/* Cache the begin/end of the buffer */
+	b = iptr->buf;	/* Start of the INTEGER buffer */
+	size = iptr->size;
+	end = b + size;	/* Where to stop */
+
+	if(size > sizeof(intmax_t)) {
+		uint8_t *end1 = end - 1;
+		/*
+		 * Slightly more advanced processing,
+		 * able to process INTEGERs with >sizeof(intmax_t) bytes
+		 * when the actual value is small, e.g. for intmax_t == int32_t
+		 * (0x0000000000abcdef INTEGER would yield a fine 0x00abcdef int32_t)
+		 */
+		/* Skip out the insignificant leading bytes */
+		for(; b < end1; b++) {
+			switch(*b) {
+				case 0x00: if((b[1] & 0x80) == 0) continue; break;
+				case 0xff: if((b[1] & 0x80) != 0) continue; break;
+			}
+			break;
+		}
+
+		size = end - b;
+		if(size > sizeof(intmax_t)) {
+			/* Still cannot fit the sizeof(intmax_t) */
+			errno = ERANGE;
+			return -1;
+		}
+	}
+
+	/* Shortcut processing of a corner case */
+	if(end == b) {
+		*lptr = 0;
+		return 0;
+	}
+
+	*lptr = asn__integer_convert(b, end);
+	return 0;
+}
+
+/* FIXME: negative INTEGER values are silently interpreted as large unsigned ones. */
+int
+asn_INTEGER2umax(const INTEGER_t *iptr, uintmax_t *lptr) {
+	uint8_t *b, *end;
+	uintmax_t value;
+	size_t size;
+
+	if(!iptr || !iptr->buf || !lptr) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	b = iptr->buf;
+	size = iptr->size;
+	end = b + size;
+
+	/* If all extra leading bytes are zeroes, ignore them */
+	for(; size > sizeof(value); b++, size--) {
+		if(*b) {
+			/* Value won't fit into uintmax_t */
+			errno = ERANGE;
+			return -1;
+		}
+	}
+
+	/* Conversion engine */
+	for(value = 0; b < end; b++)
+		value = (value << 8) | *b;
+
+	*lptr = value;
+	return 0;
+}
+
+int
+asn_umax2INTEGER(INTEGER_t *st, uintmax_t value) {
+    uint8_t *buf;
+    uint8_t *end;
+    uint8_t *b;
+    int shr;
+
+    if(value <= ((~(uintmax_t)0) >> 1)) {
+        return asn_imax2INTEGER(st, value);
+    }
+
+    buf = (uint8_t *)MALLOC(1 + sizeof(value));
+    if(!buf) return -1;
+
+    end = buf + (sizeof(value) + 1);
+    buf[0] = 0; /* INTEGERs are signed. 0-byte indicates positive. */
+    for(b = buf + 1, shr = (sizeof(value) - 1) * 8; b < end; shr -= 8, b++)
+        *b = (uint8_t)(value >> shr);
+
+    if(st->buf) FREEMEM(st->buf);
+    st->buf = buf;
+    st->size = 1 + sizeof(value);
+
+	return 0;
+}
+
+int
+asn_imax2INTEGER(INTEGER_t *st, intmax_t value) {
+	uint8_t *buf, *bp;
+	volatile uint8_t *p;
+	volatile uint8_t *pstart;
+	volatile uint8_t *pend1;
+	int littleEndian = 1;	/* Run-time detection */
+	volatile int add;
+
+	if(!st) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	buf = (uint8_t *)(long *)MALLOC(sizeof(value));
+	if(!buf) return -1;
+
+	if(*(char *)&littleEndian) {
+		pstart = (uint8_t *)&value + sizeof(value) - 1;
+		pend1 = (uint8_t *)&value;
+		add = -1;
+	} else {
+		pstart = (uint8_t *)&value;
+		pend1 = pstart + sizeof(value) - 1;
+		add = 1;
+	}
+
+	/*
+	 * If the contents octet consists of more than one octet,
+	 * then bits of the first octet and bit 8 of the second octet:
+	 * a) shall not all be ones; and
+	 * b) shall not all be zero.
+	 */
+	for(p = pstart; p != pend1; p += add) {
+		switch(*p) {
+		case 0x00: if((*(p+add) & 0x80) == 0)
+				continue;
+			break;
+		case 0xff: if((*(p+add) & 0x80))
+				continue;
+			break;
+		}
+		break;
+	}
+	/* Copy the integer body */
+	for(bp = buf, pend1 += add; p != pend1; p += add)
+		*bp++ = *p;
+
+	if(st->buf) FREEMEM(st->buf);
+	st->buf = buf;
+	st->size = bp - buf;
+
+	return 0;
+}
+
+int
+asn_INTEGER2long(const INTEGER_t *iptr, long *l) {
+    intmax_t v;
+    if(asn_INTEGER2imax(iptr, &v) == 0) {
+        if(v < LONG_MIN || v > LONG_MAX) {
+            errno = ERANGE;
+            return -1;
+        }
+        *l = v;
+        return 0;
+    } else {
+        return -1;
+    }
+}
+
+int
+asn_INTEGER2ulong(const INTEGER_t *iptr, unsigned long *l) {
+    uintmax_t v;
+    if(asn_INTEGER2umax(iptr, &v) == 0) {
+        if(v > ULONG_MAX) {
+            errno = ERANGE;
+            return -1;
+        }
+        *l = v;
+        return 0;
+    } else {
+        return -1;
+    }
+}
+
+int
+asn_long2INTEGER(INTEGER_t *st, long value) {
+    return asn_imax2INTEGER(st, value);
+}
+
+int
+asn_ulong2INTEGER(INTEGER_t *st, unsigned long value) {
+    return asn_imax2INTEGER(st, value);
+}
+
+int asn_INTEGER2int64(const INTEGER_t *st, int64_t *value) {
+    intmax_t v;
+    if(asn_INTEGER2imax(st, &v) == 0) {
+        if(v < INT64_MIN || v > INT64_MAX) {
+            errno = ERANGE;
+            return -1;
+        }
+        *value = v;
+        return 0;
+    } else {
+        return -1;
+    }
+}
+
+int asn_INTEGER2uint64(const INTEGER_t *st, uint64_t *value) {
+    uintmax_t v;
+    if(asn_INTEGER2umax(st, &v) == 0) {
+        if(v > UINT64_MAX) {
+            errno = ERANGE;
+            return -1;
+        }
+        *value = v;
+        return 0;
+    } else {
+        return -1;
+    }
+}
+
+int
+asn_uint642INTEGER(INTEGER_t *st, uint64_t value) {
+	uint8_t *buf;
+	uint8_t *end;
+	uint8_t *b;
+	int shr;
+
+	if(value <= INT64_MAX)
+		return asn_int642INTEGER(st, value);
+
+	buf = (uint8_t *)MALLOC(1 + sizeof(value));
+	if(!buf) return -1;
+
+	end = buf + (sizeof(value) + 1);
+	buf[0] = 0;
+	for(b = buf + 1, shr = (sizeof(value)-1)*8; b < end; shr -= 8, b++)
+		*b = (uint8_t)(value >> shr);
+
+	if(st->buf) FREEMEM(st->buf);
+	st->buf = buf;
+	st->size = 1 + sizeof(value);
+
+	return 0;
+}
+
+int
+asn_int642INTEGER(INTEGER_t *st, int64_t value) {
+	uint8_t *buf, *bp;
+	volatile uint8_t *p;
+	volatile uint8_t *pstart;
+	volatile uint8_t *pend1;
+	int littleEndian = 1;	/* Run-time detection */
+	volatile int add;
+
+	if(!st) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	buf = (uint8_t *)MALLOC(sizeof(value));
+	if(!buf) return -1;
+
+	if(*(char *)&littleEndian) {
+		pstart = (uint8_t *)&value + sizeof(value) - 1;
+		pend1 = (uint8_t *)&value;
+		add = -1;
+	} else {
+		pstart = (uint8_t *)&value;
+		pend1 = pstart + sizeof(value) - 1;
+		add = 1;
+	}
+
+	/*
+	 * If the contents octet consists of more than one octet,
+	 * then bits of the first octet and bit 8 of the second octet:
+	 * a) shall not all be ones; and
+	 * b) shall not all be zero.
+	 */
+	for(p = pstart; p != pend1; p += add) {
+		switch(*p) {
+		case 0x00: if((*(p+add) & 0x80) == 0)
+				continue;
+			break;
+		case 0xff: if((*(p+add) & 0x80))
+				continue;
+			break;
+		}
+		break;
+	}
+	/* Copy the integer body */
+	for(pstart = p, bp = buf, pend1 += add; p != pend1; p += add)
+		*bp++ = *p;
+
+	if(st->buf) FREEMEM(st->buf);
+	st->buf = buf;
+	st->size = bp - buf;
+
+	return 0;
+}
+
+/*
+ * Parse the number in the given string until the given *end position,
+ * returning the position after the last parsed character back using the
+ * same (*end) pointer.
+ * WARNING: This behavior is different from the standard strtol/strtoimax(3).
+ */
+enum asn_strtox_result_e
+asn_strtoimax_lim(const char *str, const char **end, intmax_t *intp) {
+    int sign = 1;
+    intmax_t value;
+
+    const intmax_t asn1_intmax_max = ((~(uintmax_t)0) >> 1);
+    const intmax_t upper_boundary = asn1_intmax_max / 10;
+    intmax_t last_digit_max = asn1_intmax_max % 10;
+
+    if(str >= *end) return ASN_STRTOX_ERROR_INVAL;
+
+    switch(*str) {
+    case '-':
+        last_digit_max++;
+        sign = -1;
+        /* FALL THROUGH */
+    case '+':
+        str++;
+        if(str >= *end) {
+            *end = str;
+            return ASN_STRTOX_EXPECT_MORE;
+        }
+    }
+
+    for(value = 0; str < (*end); str++) {
+        if(*str >= 0x30 && *str <= 0x39) {
+            int d = *str - '0';
+            if(value < upper_boundary) {
+                value = value * 10 + d;
+            } else if(value == upper_boundary) {
+                if(d <= last_digit_max) {
+                    if(sign > 0) {
+                        value = value * 10 + d;
+                    } else {
+                        sign = 1;
+                        value = -value * 10 - d;
+                    }
+                    str += 1;
+                    if(str < *end) {
+                        // If digits continue, we're guaranteed out of range.
+                        *end = str;
+                        if(*str >= 0x30 && *str <= 0x39) {
+                            return ASN_STRTOX_ERROR_RANGE;
+                        } else {
+                            *intp = sign * value;
+                            return ASN_STRTOX_EXTRA_DATA;
+                        }
+                    }
+                    break;
+                } else {
+                    *end = str;
+                    return ASN_STRTOX_ERROR_RANGE;
+                }
+            } else {
+                *end = str;
+                return ASN_STRTOX_ERROR_RANGE;
+            }
+        } else {
+            *end = str;
+            *intp = sign * value;
+            return ASN_STRTOX_EXTRA_DATA;
+        }
+    }
+
+    *end = str;
+    *intp = sign * value;
+    return ASN_STRTOX_OK;
+}
+
+/*
+ * Parse the number in the given string until the given *end position,
+ * returning the position after the last parsed character back using the
+ * same (*end) pointer.
+ * WARNING: This behavior is different from the standard strtoul/strtoumax(3).
+ */
+enum asn_strtox_result_e
+asn_strtoumax_lim(const char *str, const char **end, uintmax_t *uintp) {
+    uintmax_t value;
+
+    const uintmax_t asn1_uintmax_max = ((~(uintmax_t)0));
+    const uintmax_t upper_boundary = asn1_uintmax_max / 10;
+    uintmax_t last_digit_max = asn1_uintmax_max % 10;
+
+    if(str >= *end) return ASN_STRTOX_ERROR_INVAL;
+
+    switch(*str) {
+    case '-':
+        return ASN_STRTOX_ERROR_INVAL;
+    case '+':
+        str++;
+        if(str >= *end) {
+            *end = str;
+            return ASN_STRTOX_EXPECT_MORE;
+        }
+    }
+
+    for(value = 0; str < (*end); str++) {
+        if(*str >= 0x30 && *str <= 0x39) {
+            unsigned int d = *str - '0';
+            if(value < upper_boundary) {
+                value = value * 10 + d;
+            } else if(value == upper_boundary) {
+                if(d <= last_digit_max) {
+                    value = value * 10 + d;
+                    str += 1;
+                    if(str < *end) {
+                        // If digits continue, we're guaranteed out of range.
+                        *end = str;
+                        if(*str >= 0x30 && *str <= 0x39) {
+                            return ASN_STRTOX_ERROR_RANGE;
+                        } else {
+                            *uintp = value;
+                            return ASN_STRTOX_EXTRA_DATA;
+                        }
+                    }
+                    break;
+                } else {
+                    *end = str;
+                    return ASN_STRTOX_ERROR_RANGE;
+                }
+            } else {
+                *end = str;
+                return ASN_STRTOX_ERROR_RANGE;
+            }
+        } else {
+            *end = str;
+            *uintp = value;
+            return ASN_STRTOX_EXTRA_DATA;
+        }
+    }
+
+    *end = str;
+    *uintp = value;
+    return ASN_STRTOX_OK;
+}
+
+enum asn_strtox_result_e
+asn_strtol_lim(const char *str, const char **end, long *lp) {
+    intmax_t value;
+    switch(asn_strtoimax_lim(str, end, &value)) {
+    case ASN_STRTOX_ERROR_RANGE:
+        return ASN_STRTOX_ERROR_RANGE;
+    case ASN_STRTOX_ERROR_INVAL:
+        return ASN_STRTOX_ERROR_INVAL;
+    case ASN_STRTOX_EXPECT_MORE:
+        return ASN_STRTOX_EXPECT_MORE;
+    case ASN_STRTOX_OK:
+        if(value >= LONG_MIN && value <= LONG_MAX) {
+            *lp = value;
+            return ASN_STRTOX_OK;
+        } else {
+            return ASN_STRTOX_ERROR_RANGE;
+        }
+    case ASN_STRTOX_EXTRA_DATA:
+        if(value >= LONG_MIN && value <= LONG_MAX) {
+            *lp = value;
+            return ASN_STRTOX_EXTRA_DATA;
+        } else {
+            return ASN_STRTOX_ERROR_RANGE;
+        }
+    }
+
+    assert(!"Unreachable");
+    return ASN_STRTOX_ERROR_INVAL;
+}
+
+enum asn_strtox_result_e
+asn_strtoul_lim(const char *str, const char **end, unsigned long *ulp) {
+    uintmax_t value;
+    switch(asn_strtoumax_lim(str, end, &value)) {
+    case ASN_STRTOX_ERROR_RANGE:
+        return ASN_STRTOX_ERROR_RANGE;
+    case ASN_STRTOX_ERROR_INVAL:
+        return ASN_STRTOX_ERROR_INVAL;
+    case ASN_STRTOX_EXPECT_MORE:
+        return ASN_STRTOX_EXPECT_MORE;
+    case ASN_STRTOX_OK:
+        if(value <= ULONG_MAX) {
+            *ulp = value;
+            return ASN_STRTOX_OK;
+        } else {
+            return ASN_STRTOX_ERROR_RANGE;
+        }
+    case ASN_STRTOX_EXTRA_DATA:
+        if(value <= ULONG_MAX) {
+            *ulp = value;
+            return ASN_STRTOX_EXTRA_DATA;
+        } else {
+            return ASN_STRTOX_ERROR_RANGE;
+        }
+    }
+
+    assert(!"Unreachable");
+    return ASN_STRTOX_ERROR_INVAL;
+}
+
+int
+INTEGER_compare(const asn_TYPE_descriptor_t *td, const void *aptr,
+                     const void *bptr) {
+    const INTEGER_t *a = aptr;
+    const INTEGER_t *b = bptr;
+
+    (void)td;
+
+    if(a && b) {
+        if(a->size && b->size) {
+            int sign_a = (a->buf[0] & 0x80) ? -1 : 1;
+            int sign_b = (b->buf[0] & 0x80) ? -1 : 1;
+
+            if(sign_a < sign_b) return -1;
+            if(sign_a > sign_b) return 1;
+
+            /* The shortest integer wins, unless comparing negatives */
+            if(a->size < b->size) {
+                return -1 * sign_a;
+            } else if(a->size > b->size) {
+                return 1 * sign_b;
+            }
+
+            return sign_a * memcmp(a->buf, b->buf, a->size);
+        } else if(a->size) {
+            int sign = (a->buf[0] & 0x80) ? -1 : 1;
+            return (1) * sign;
+        } else if(b->size) {
+            int sign = (a->buf[0] & 0x80) ? -1 : 1;
+            return (-1) * sign;
+        } else {
+            return 0;
+        }
+    } else if(!a && !b) {
+        return 0;
+    } else if(!a) {
+        return -1;
+    } else {
+        return 1;
+    }
+
+}
+
+int
+INTEGER_copy(const asn_TYPE_descriptor_t *td, void **aptr,
+                     const void *bptr) {
+    (void)td;
+    INTEGER_t *a = *aptr;
+    const INTEGER_t *b = bptr;
+
+    if(!b) {
+        if(a) {
+            FREEMEM(a->buf);
+            FREEMEM(a);
+            *aptr = 0;
+        }
+        return 0;
+    }
+
+    if(!a) {
+        a = *aptr = CALLOC(1, sizeof(*a));
+        if(!a) return -1;
+    }
+
+    if(b->size) {
+        uint8_t* buf = MALLOC(b->size);
+        if(!buf) return -1;
+        memcpy(buf, b->buf, b->size);
+        FREEMEM(a->buf);
+        a->buf = buf;
+        a->size = b->size;
+    } else {
+        FREEMEM(a->buf);
+        a->buf = 0;
+        a->size = 0;
+    }
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER.h /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER.h
new file mode 100644
index 000000000..8e6022a99
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER.h
@@ -0,0 +1,143 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_INTEGER_H_
+#define	_INTEGER_H_
+
+#include "asn_application.h"
+#include "asn_codecs_prim.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef ASN__PRIMITIVE_TYPE_t INTEGER_t;
+
+extern asn_TYPE_descriptor_t asn_DEF_INTEGER;
+extern asn_TYPE_operation_t asn_OP_INTEGER;
+
+/* Map with <tag> to integer value association */
+typedef struct asn_INTEGER_enum_map_s {
+	long		 nat_value;	/* associated native integer value */
+	size_t		 enum_len;	/* strlen("tag") */
+	const char	*enum_name;	/* "tag" */
+} asn_INTEGER_enum_map_t;
+
+/* This type describes an enumeration for INTEGER and ENUMERATED types */
+typedef struct asn_INTEGER_specifics_s {
+	const asn_INTEGER_enum_map_t *value2enum;	/* N -> "tag"; sorted by N */
+	const unsigned int *enum2value;		/* "tag" => N; sorted by tag */
+	int map_count;				/* Elements in either map */
+	int extension;				/* This map is extensible */
+	int strict_enumeration;			/* Enumeration set is fixed */
+	int field_width;			/* Size of native integer */
+	int field_unsigned;			/* Signed=0, unsigned=1 */
+} asn_INTEGER_specifics_t;
+
+ssize_t INTEGER__dump(const asn_TYPE_descriptor_t *td,
+                      const INTEGER_t *st,
+                      asn_app_consume_bytes_f *cb,
+                      void *app_key, int plainOrXER);
+
+#define INTEGER_free ASN__PRIMITIVE_TYPE_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f INTEGER_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f INTEGER_compare;
+asn_struct_copy_f INTEGER_copy;
+
+#define INTEGER_constraint asn_generic_no_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define INTEGER_decode_ber ber_decode_primitive
+der_type_encoder_f INTEGER_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f INTEGER_decode_xer;
+xer_type_encoder_f INTEGER_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f INTEGER_decode_jer;
+jer_type_encoder_f INTEGER_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f INTEGER_decode_oer;
+oer_type_encoder_f INTEGER_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f INTEGER_decode_uper;
+per_type_encoder_f INTEGER_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f INTEGER_decode_aper;
+per_type_encoder_f INTEGER_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f INTEGER_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+/***********************************
+ * Some handy conversion routines. *
+ ***********************************/
+
+/*
+ * Natiwe size-independent conversion of native integers to/from INTEGER.
+ * (l_size) is in bytes.
+ * Returns 0 if it was possible to convert, -1 otherwise.
+ * -1/EINVAL: Mandatory argument missing
+ * -1/ERANGE: Value encoded is out of range for long representation
+ * -1/ENOMEM: Memory allocation failed (in asn_*2INTEGER()).
+ */
+int asn_INTEGER2imax(const INTEGER_t *i, intmax_t *l);
+int asn_INTEGER2umax(const INTEGER_t *i, uintmax_t *l);
+int asn_imax2INTEGER(INTEGER_t *i, intmax_t l);
+int asn_umax2INTEGER(INTEGER_t *i, uintmax_t l);
+
+/*
+ * Size-specific conversion helpers.
+ */
+int asn_INTEGER2long(const INTEGER_t *i, long *l);
+int asn_INTEGER2ulong(const INTEGER_t *i, unsigned long *l);
+int asn_long2INTEGER(INTEGER_t *i, long l);
+int asn_ulong2INTEGER(INTEGER_t *i, unsigned long l);
+int asn_INTEGER2int64(const INTEGER_t *i, int64_t *l);
+int asn_INTEGER2uint64(const INTEGER_t *i, uint64_t *l);
+int asn_int642INTEGER(INTEGER_t *i, int64_t l);
+int asn_uint642INTEGER(INTEGER_t *i, uint64_t l);
+
+/* A version of strtol/strtoimax(3) with nicer error reporting. */
+enum asn_strtox_result_e {
+    ASN_STRTOX_ERROR_RANGE = -3,  /* Input outside of supported numeric range */
+    ASN_STRTOX_ERROR_INVAL = -2,  /* Invalid data encountered (e.g., "+-") */
+    ASN_STRTOX_EXPECT_MORE = -1,  /* More data expected (e.g. "+") */
+    ASN_STRTOX_OK          =  0,  /* Conversion succeeded, number ends at (*end) */
+    ASN_STRTOX_EXTRA_DATA  =  1   /* Conversion succeeded, but the string has extra stuff */
+};
+enum asn_strtox_result_e asn_strtol_lim(const char *str, const char **end,
+                                        long *l);
+enum asn_strtox_result_e asn_strtoul_lim(const char *str, const char **end,
+                                         unsigned long *l);
+enum asn_strtox_result_e asn_strtoimax_lim(const char *str, const char **end,
+                                           intmax_t *l);
+enum asn_strtox_result_e asn_strtoumax_lim(const char *str, const char **end,
+                                           uintmax_t *l);
+
+/*
+ * Convert the integer value into the corresponding enumeration map entry.
+ */
+const asn_INTEGER_enum_map_t *INTEGER_map_value2enum(
+    const asn_INTEGER_specifics_t *specs, long value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _INTEGER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_aper.c
new file mode 100644
index 000000000..b35f8c002
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_aper.c
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+asn_dec_rval_t
+INTEGER_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                    const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+    const asn_INTEGER_specifics_t *specs = (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval = { RC_OK, 0 };
+    INTEGER_t *st = (INTEGER_t *)*sptr;
+    const asn_per_constraint_t *ct;
+    int repeat;
+
+    (void)opt_codec_ctx;
+
+    if(!st) {
+        st = (INTEGER_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    if(!constraints) constraints = td->encoding_constraints.per_constraints;
+    ct = constraints ? &constraints->value : 0;
+
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        int inext = per_get_few_bits(pd, 1);
+        if(inext < 0) ASN__DECODE_STARVED;
+        if(inext) ct = 0;
+    }
+
+    FREEMEM(st->buf);
+    st->buf = 0;
+    st->size = 0;
+    if(ct) {
+        if(ct->flags & APC_SEMI_CONSTRAINED) {
+            st->buf = (uint8_t *)CALLOC(1, 2);
+            if(!st->buf) ASN__DECODE_FAILED;
+            st->size = 1;
+        } else if(ct->flags & APC_CONSTRAINED && ct->range_bits >= 0) {
+            size_t size = (ct->range_bits + 7) >> 3;
+            st->buf = (uint8_t *)MALLOC(1 + size + 1);
+            if(!st->buf) ASN__DECODE_FAILED;
+            st->size = size;
+        }
+    }
+
+    /* X.691, #12.2.2 */
+    if(ct && ct->flags != APC_UNCONSTRAINED) {
+        /* #10.5.6 */
+        ASN_DEBUG("Integer with range %d bits", ct->range_bits);
+        if(ct->range_bits >= 0) {
+            if (ct->range_bits > 16) {
+                int max_range_bytes = (ct->range_bits >> 3) +
+                                      (((ct->range_bits % 8) > 0) ? 1 : 0);
+                int length = 0, i;
+                intmax_t value = 0;
+
+                for (i = 1; ; i++) {
+                    int upper = 1 << i;
+                    if (upper >= max_range_bytes)
+                        break;
+                }
+                ASN_DEBUG("Can encode %d (%d bytes) in %d bits", ct->range_bits,
+                          max_range_bytes, i);
+
+                if ((length = per_get_few_bits(pd, i)) < 0)
+                    ASN__DECODE_FAILED;
+
+                /* X.691 #12.2.6 length determinant + lb (1) */
+                length += 1;
+                ASN_DEBUG("Got length %d", length);
+                if (aper_get_align(pd) != 0)
+                    ASN__DECODE_FAILED;
+                while (length--) {
+                    int buf = per_get_few_bits(pd, 8);
+                    if (buf < 0)
+                        ASN__DECODE_FAILED;
+                    value += (((intmax_t)buf) << (8 * length));
+                }
+
+                value += ct->lower_bound;
+                if((specs && specs->field_unsigned)
+                        ? asn_umax2INTEGER(st, (uintmax_t)value)
+                        : asn_imax2INTEGER(st, value))
+                    ASN__DECODE_FAILED;
+                ASN_DEBUG("Got value %"ASN_PRIdMAX" + low %"ASN_PRIdMAX"",
+                          value, (intmax_t)ct->lower_bound);
+            } else {
+                intmax_t value = 0;
+                if (ct->range_bits < 8) {
+                    value = per_get_few_bits(pd, ct->range_bits);
+                    if(value < 0) ASN__DECODE_STARVED;
+                } else if (ct->range_bits == 8) {
+                    if (aper_get_align(pd) < 0)
+                        ASN__DECODE_FAILED;
+                    value = per_get_few_bits(pd, ct->range_bits);
+                    if(value < 0) ASN__DECODE_STARVED;
+                } else {
+                    /* Align */
+                    if (aper_get_align(pd) < 0)
+                        ASN__DECODE_FAILED;
+                    value = per_get_few_bits(pd, 16);
+                    if(value < 0) ASN__DECODE_STARVED;
+                }
+                value += ct->lower_bound;
+                if((specs && specs->field_unsigned)
+                        ? asn_umax2INTEGER(st, (uintmax_t)value)
+                        : asn_imax2INTEGER(st, value))
+                    ASN__DECODE_FAILED;
+                ASN_DEBUG("Got value %"ASN_PRIdMAX" + low %"ASN_PRIdMAX"",
+                          value, (intmax_t)ct->lower_bound);
+            }
+            return rval;
+        } else {
+            ASN__DECODE_FAILED;
+        }
+    } else {
+        ASN_DEBUG("Decoding unconstrained integer %s", td->name);
+    }
+
+    /* X.691, #12.2.3, #12.2.4 */
+    do {
+        ssize_t len;
+        void *p;
+        int ret;
+
+        /* Get the PER length */
+        len = aper_get_length(pd, -1, -1, -1, &repeat);
+        if(len < 0) ASN__DECODE_STARVED;
+
+        p = REALLOC(st->buf, st->size + len + 1);
+        if(!p) ASN__DECODE_FAILED;
+        st->buf = (uint8_t *)p;
+
+        ret = per_get_many_bits(pd, &st->buf[st->size], 0, 8 * len);
+        if(ret < 0) ASN__DECODE_STARVED;
+        st->size += len;
+    } while(repeat);
+    st->buf[st->size] = 0;  /* JIC */
+
+    /* #12.2.3 */
+    if(ct && ct->lower_bound) {
+        /*
+         * TODO: replace by in-place arithmetics.
+         */
+        long value;
+        if(asn_INTEGER2long(st, &value))
+            ASN__DECODE_FAILED;
+        if(asn_long2INTEGER(st, value + ct->lower_bound))
+            ASN__DECODE_FAILED;
+    }
+
+    return rval;
+}
+
+asn_enc_rval_t
+INTEGER_encode_aper(const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints,
+                    const void *sptr, asn_per_outp_t *po) {
+    const asn_INTEGER_specifics_t *specs = (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    const INTEGER_t *st = (const INTEGER_t *)sptr;
+    const uint8_t *buf;
+    const uint8_t *end;
+    const asn_per_constraint_t *ct;
+    intmax_t value = 0;
+
+    if(!st || st->size == 0) ASN__ENCODE_FAILED;
+
+    if(!constraints) constraints = td->encoding_constraints.per_constraints;
+    ct = constraints ? &constraints->value : 0;
+
+    er.encoded = 0;
+
+    if(ct) {
+        int inext = 0;
+        if(specs && specs->field_unsigned) {
+            uintmax_t uval;
+            if(asn_INTEGER2umax(st, &uval))
+                ASN__ENCODE_FAILED;
+            /* Check proper range */
+            if(ct->flags & APC_SEMI_CONSTRAINED) {
+                if(uval < (uintmax_t)ct->lower_bound)
+                    inext = 1;
+            } else if(ct->range_bits >= 0) {
+                if(uval < (uintmax_t)ct->lower_bound
+                        || uval > (uintmax_t)ct->upper_bound)
+                    inext = 1;
+            }
+            ASN_DEBUG("Value %"ASN_PRIdMAX" (%02x/%"ASN_PRI_SIZE") lb %"ASN_PRIdMAX" ub %"ASN_PRIdMAX" %s",
+                      uval, st->buf[0], st->size,
+                      (intmax_t)ct->lower_bound,
+                      (intmax_t)ct->upper_bound,
+                      inext ? "ext" : "fix");
+            value = uval;
+        } else {
+            if(asn_INTEGER2imax(st, &value)) ASN__ENCODE_FAILED;
+            /* Check proper range */
+            if(ct->flags & APC_SEMI_CONSTRAINED) {
+                if(value < ct->lower_bound)
+                    inext = 1;
+            } else if(ct->range_bits >= 0) {
+                if(value < ct->lower_bound
+                        || value > ct->upper_bound)
+                    inext = 1;
+            }
+            ASN_DEBUG("Value %"ASN_PRIdMAX" (%02x/%"ASN_PRI_SIZE") lb %"ASN_PRIdMAX" ub %"ASN_PRIdMAX" %s",
+                      value, st->buf[0], st->size,
+                      (intmax_t)ct->lower_bound,
+                      (intmax_t)ct->upper_bound,
+                      inext ? "ext" : "fix");
+        }
+        if(ct->flags & APC_EXTENSIBLE) {
+            if(per_put_few_bits(po, inext, 1))
+                ASN__ENCODE_FAILED;
+            if(inext) ct = 0;
+        } else if(inext) {
+            ASN__ENCODE_FAILED;
+        }
+    }
+
+    /* X.691, #12.2.2 */
+    if(ct && ct->range_bits >= 0) {
+        uintmax_t v;
+
+        /* #10.5.6 */
+        ASN_DEBUG("Encoding integer %"ASN_PRIdMAX" (%"ASN_PRIdMAX") with range %d bits",
+                  value, (intmax_t)(value - ct->lower_bound),
+                  ct->range_bits);
+
+        v = value - ct->lower_bound;
+
+        /* #12 <= 8 -> alignment ? */
+        int range = ct->upper_bound - ct->lower_bound + 1;
+        if (ct->range_bits < 8 || (ct->range_bits == 8 && range < 256)) {
+            if(per_put_few_bits(po, 0x00 | v, ct->range_bits))
+                ASN__ENCODE_FAILED;
+        } else if (ct->range_bits == 8) {
+            if(aper_put_align(po) < 0)
+                ASN__ENCODE_FAILED;
+            if(per_put_few_bits(po, 0x00 | v, ct->range_bits))
+                ASN__ENCODE_FAILED;
+        } else if (ct->range_bits <= 16) {
+            /* Consume the bytes to align on octet */
+            if(aper_put_align(po) < 0)
+                ASN__ENCODE_FAILED;
+            if(per_put_few_bits(po, 0x0000 | v, 16))
+                ASN__ENCODE_FAILED;
+        } else {
+            /* TODO: extend to >64 bits */
+            int64_t v64 = v;
+            int i, j;
+            int max_range_bytes = (ct->range_bits >> 3) +
+                                  (((ct->range_bits % 8) > 0) ? 1 : 0);
+
+            for (i = 1; ; i++) {
+                int upper = 1 << i;
+                if (upper >= max_range_bytes)
+                    break;
+            }
+
+            for (j = sizeof(int64_t) -1; j != 0; j--) {
+                int64_t val;
+                val = v64 >> (j * 8);
+                if (val != 0)
+                    break;
+            }
+
+            /* Putting length in the minimum number of bits ex: 5 = 3bits */
+            if (per_put_few_bits(po, j, i))
+                ASN__ENCODE_FAILED;
+
+            /* Consume the bits to align on octet */
+            if (aper_put_align(po) < 0)
+                ASN__ENCODE_FAILED;
+            /* Put the value */
+            for (i = 0; i <= j; i++) {
+                if(per_put_few_bits(po, (v64 >> (8 * (j - i))) & 0xff, 8))
+                    ASN__ENCODE_FAILED;
+            }
+        }
+        ASN__ENCODED_OK(er);
+    }
+
+    if(ct && ct->lower_bound) {
+        ASN_DEBUG("Adjust lower bound to %"ASN_PRIdMAX"", (intmax_t)ct->lower_bound);
+        /* TODO: adjust lower bound */
+        ASN__ENCODE_FAILED;
+    }
+
+    for(buf = st->buf, end = st->buf + st->size; buf < end;) {
+        int need_eom = 0;
+        ssize_t mayEncode = aper_put_length(po, -1, -1, end - buf, &need_eom);
+        if(mayEncode < 0)
+            ASN__ENCODE_FAILED;
+        if(per_put_many_bits(po, buf, 8 * mayEncode))
+            ASN__ENCODE_FAILED;
+        buf += mayEncode;
+        if(need_eom && (aper_put_length(po, -1, -1, 0, NULL) < 0))
+            ASN__ENCODE_FAILED;
+    }
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_ber.c
new file mode 100644
index 000000000..db380a5b4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_ber.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+/*
+ * Encode INTEGER type using DER.
+ */
+asn_enc_rval_t
+INTEGER_encode_der(const asn_TYPE_descriptor_t *td, const void *sptr,
+                   int tag_mode, ber_tlv_tag_t tag, asn_app_consume_bytes_f *cb,
+                   void *app_key) {
+    const INTEGER_t *st = (const INTEGER_t *)sptr;
+    asn_enc_rval_t rval;
+    INTEGER_t effective_integer;
+
+    ASN_DEBUG("%s %s as INTEGER (tm=%d)",
+              cb?"Encoding":"Estimating", td->name, tag_mode);
+
+    /*
+     * Canonicalize integer in the buffer.
+     * (Remove too long sign extension, remove some first 0x00 bytes)
+     */
+    if(st->buf) {
+        uint8_t *buf = st->buf;
+        uint8_t *end1 = buf + st->size - 1;
+        int shift;
+
+        /* Compute the number of superfluous leading bytes */
+        for(; buf < end1; buf++) {
+            /*
+             * If the contents octets of an integer value encoding
+             * consist of more than one octet, then the bits of the
+             * first octet and bit 8 of the second octet:
+             * a) shall not all be ones; and
+             * b) shall not all be zero.
+             */
+            switch(*buf) {
+            case 0x00: 
+	        if((buf[1] & 0x80) == 0) continue;
+                break;
+            case 0xff: 
+            	if((buf[1] & 0x80)) continue;
+                break;
+            }
+            break;
+        }
+
+        /* Remove leading superfluous bytes from the integer */
+        shift = buf - st->buf;
+        if(shift) {
+            union {
+                const uint8_t *c_buf;
+                uint8_t *nc_buf;
+            } unconst;
+            unconst.c_buf = st->buf;
+            effective_integer.buf = unconst.nc_buf + shift;
+            effective_integer.size = st->size - shift;
+
+            st = &effective_integer;
+        }
+    }
+
+    rval = der_encode_primitive(td, st, tag_mode, tag, cb, app_key);
+    if(rval.structure_ptr == &effective_integer) {
+        rval.structure_ptr = sptr;
+    }
+    return rval;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_jer.c
new file mode 100644
index 000000000..2606cebc8
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_jer.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+struct je2v_key {
+    const char *start;
+    const char *stop;
+    const asn_INTEGER_enum_map_t *vemap;
+    const unsigned int *evmap;
+};
+
+static int
+INTEGER_jer_st_prealloc(INTEGER_t *st, int min_size) {
+    void *p = MALLOC(min_size + 1);
+    if(p) {
+        void *b = st->buf;
+        st->size = 0;
+        st->buf = p;
+        FREEMEM(b);
+        return 0;
+    } else {
+        return -1;
+    }
+}
+/*
+ * Decode the chunk of JSON text encoding INTEGER.
+ */
+static enum jer_pbd_rval
+INTEGER__jer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,
+                         const void *chunk_buf, size_t chunk_size) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    INTEGER_t *st = (INTEGER_t *)sptr;
+    intmax_t dec_value;
+    const char *lp;
+    const char *lstart = (const char *)chunk_buf;
+    const char *lstop = lstart + chunk_size;
+    enum {
+        ST_LEADSPACE,
+        ST_WAITDIGITS,
+        ST_DIGITS,
+        ST_ZERO,
+        ST_DIGITS_TRAILSPACE,
+        ST_UNEXPECTED
+    } state = ST_LEADSPACE;
+    const char *dec_value_start = 0; /* INVARIANT: always !0 in ST_DIGITS */
+    const char *dec_value_end = 0;
+
+    if(chunk_size)
+        ASN_DEBUG("INTEGER body %ld 0x%2x..0x%2x",
+                  (long)chunk_size, *lstart, lstop[-1]);
+
+    if(INTEGER_jer_st_prealloc(st, (chunk_size/3) + 1))
+        return JPBD_SYSTEM_FAILURE;
+
+    /*
+     * We may have received a tag here. It will be processed inline.
+     * Use strtoul()-like code and serialize the result.
+     */
+    for(lp = lstart; lp < lstop; lp++) {
+        int lv = *lp;
+        switch(lv) {
+        case 0x09: case 0x0a: case 0x0d: case 0x20:
+            switch(state) {
+            case ST_LEADSPACE:
+            case ST_DIGITS_TRAILSPACE:
+                continue;
+            case ST_DIGITS:
+            case ST_ZERO:
+                dec_value_end = lp;
+                state = ST_DIGITS_TRAILSPACE;
+                continue;
+            default:
+                break;
+            }
+            break;
+        case 0x2d:  /* '-' */
+            if(state == ST_LEADSPACE) {
+                dec_value = 0;
+                dec_value_start = lp;
+                state = ST_WAITDIGITS;
+                continue;
+            }
+            break;
+        case 0x30: /* 0 */
+            switch(state) {
+            case ST_DIGITS: continue;
+            case ST_LEADSPACE:
+            case ST_WAITDIGITS:
+                dec_value = 0;
+                dec_value_start = lp;
+                state = ST_ZERO;
+                continue;
+            case ST_ZERO: /* forbidden leading zero */
+                return JPBD_BROKEN_ENCODING;
+            default:
+                break;
+            }
+            break;
+        /* [1-9] */
+        case 0x31: case 0x32: case 0x33: case 0x34:
+        case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:
+            switch(state) {
+            case ST_DIGITS: continue;
+            case ST_LEADSPACE:
+                dec_value = 0;
+                dec_value_start = lp;
+                /* FALL THROUGH */
+            case ST_WAITDIGITS:
+                state = ST_DIGITS;
+                continue;
+            case ST_ZERO: /* forbidden leading zero */
+                return JPBD_BROKEN_ENCODING;
+            default:
+                break;
+            }
+            break;
+        }
+
+        /* Found extra non-numeric stuff */
+        ASN_DEBUG("INTEGER :: Found non-numeric 0x%2x at %ld",
+                  lv, (long)(lp - lstart));
+        state = ST_UNEXPECTED;
+        break;
+    }
+
+    switch(state) {
+    case ST_DIGITS:
+    case ST_ZERO:
+        dec_value_end = lstop;
+        /* FALL THROUGH */
+    case ST_DIGITS_TRAILSPACE:
+        /* The last symbol encountered was a digit. */
+        switch(asn_strtoimax_lim(dec_value_start, &dec_value_end, &dec_value)) {
+        case ASN_STRTOX_OK:
+            if(specs && specs->field_unsigned && (uintmax_t) dec_value <= ULONG_MAX) {
+                break;
+            } else if(dec_value >= LONG_MIN && dec_value <= LONG_MAX) {
+                break;
+            } else {
+                /*
+                 * We model INTEGER on long for JER,
+                 * to avoid rewriting all the tests at once.
+                 */
+                ASN_DEBUG("INTEGER exceeds long range");
+            }
+            /* Fall through */
+        case ASN_STRTOX_ERROR_RANGE:
+            ASN_DEBUG("INTEGER decode %s hit range limit", td->name);
+            return JPBD_DECODER_LIMIT;
+        case ASN_STRTOX_ERROR_INVAL:
+        case ASN_STRTOX_EXPECT_MORE:
+        case ASN_STRTOX_EXTRA_DATA:
+            return JPBD_BROKEN_ENCODING;
+        }
+        break;
+    case ST_LEADSPACE:
+        /* Content not found */
+        return JPBD_NOT_BODY_IGNORE;
+    case ST_WAITDIGITS:
+    case ST_UNEXPECTED:
+        ASN_DEBUG("INTEGER: No useful digits (state %d)", state);
+        return JPBD_BROKEN_ENCODING;  /* No digits */
+    }
+
+    /*
+     * Convert the result of parsing of enumeration or a straight
+     * decimal value into a BER representation.
+     */
+    if(asn_imax2INTEGER(st, dec_value)) {
+                ASN_DEBUG("INTEGER decode %s conversion failed", td->name);
+        return JPBD_SYSTEM_FAILURE;
+        }
+
+    return JPBD_BODY_CONSUMED;
+}
+
+asn_dec_rval_t
+INTEGER_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_jer_constraints_t *constraints,
+                   void **sptr, const void *buf_ptr, size_t size) {
+    return jer_decode_primitive(opt_codec_ctx, td,
+        sptr, sizeof(INTEGER_t),
+        buf_ptr, size, INTEGER__jer_body_decode);
+}
+
+
+asn_enc_rval_t
+INTEGER_encode_jer(const asn_TYPE_descriptor_t *td,
+                   const asn_jer_constraints_t *constraints,
+                   const void *sptr, int ilevel, enum jer_encoder_flags_e flags,
+                   asn_app_consume_bytes_f *cb, void *app_key) {
+    const INTEGER_t *st = (const INTEGER_t *)sptr;
+    asn_enc_rval_t er = {0,0,0};
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!st || !st->buf)
+        ASN__ENCODE_FAILED;
+
+    er.encoded = INTEGER__dump(td, st, cb, app_key, 1);
+    if(er.encoded < 0) ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_oer.c
new file mode 100644
index 000000000..8e0db3244
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_oer.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+asn_dec_rval_t
+INTEGER_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_oer_constraints_t *constraints, void **sptr,
+                   const void *ptr, size_t size) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval = {RC_OK, 0};
+    INTEGER_t *st = (INTEGER_t *)*sptr;
+    struct asn_oer_constraint_number_s ct = {0, 0};
+    size_t req_bytes;
+
+    (void)opt_codec_ctx;
+    (void)specs;
+
+    if(!st) {
+        st = (INTEGER_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    FREEMEM(st->buf);
+    st->buf = 0;
+    st->size = 0;
+
+    if(!constraints) constraints = td->encoding_constraints.oer_constraints;
+    if(constraints) ct = constraints->value;
+
+    if(ct.width) {
+        req_bytes = ct.width;
+    } else {
+        /* No lower bound and no upper bound, effectively */
+
+        ssize_t consumed = oer_fetch_length(ptr, size, &req_bytes);
+        if(consumed == 0) {
+            ASN__DECODE_STARVED;
+        } else if(consumed == -1) {
+            ASN__DECODE_FAILED;
+        }
+        rval.consumed += consumed;
+        ptr = (const char *)ptr + consumed;
+        size -= consumed;
+    }
+
+    if(req_bytes > size) {
+        ASN__DECODE_STARVED;
+    }
+
+    if(ct.positive) {
+        /* X.969 08/2015 10.2(a) */
+        unsigned msb;   /* Most significant bit */
+        size_t useful_size;
+
+        /* Check most significant bit */
+        msb = *(const uint8_t *)ptr >> 7; /* yields 0 or 1 */
+        useful_size = msb + req_bytes;
+        st->buf = (uint8_t *)MALLOC(useful_size + 1);
+        if(!st->buf) {
+            ASN__DECODE_FAILED;
+        }
+
+        /*
+         * Record a large unsigned in a way not to confuse it
+         * with signed value.
+         */
+        st->buf[0] = '\0';
+        memcpy(st->buf + msb, ptr, req_bytes);
+        st->buf[useful_size] = '\0';    /* Just in case, 0-terminate */
+        st->size = useful_size;
+
+        rval.consumed += req_bytes;
+        return rval;
+    } else {
+        /* X.969 08/2015 10.2(b) */
+        st->buf = (uint8_t *)MALLOC(req_bytes + 1);
+        if(!st->buf) {
+            ASN__DECODE_FAILED;
+        }
+
+        memcpy(st->buf, ptr, req_bytes);
+        st->buf[req_bytes] = '\0'; /* Just in case, 0-terminate */
+        st->size = req_bytes;
+
+        rval.consumed += req_bytes;
+        return rval;
+    }
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+INTEGER_encode_oer(const asn_TYPE_descriptor_t *td,
+                   const asn_oer_constraints_t *constraints, const void *sptr,
+                   asn_app_consume_bytes_f *cb, void *app_key) {
+    const INTEGER_t *st = sptr;
+    asn_enc_rval_t er = {0,0,0};
+    struct asn_oer_constraint_number_s ct = {0, 0};
+    const uint8_t *buf;
+    const uint8_t *end;
+    size_t useful_bytes;
+    size_t req_bytes = 0;
+    int sign = 0;
+
+    if(!st || st->size == 0) ASN__ENCODE_FAILED;
+
+    if(!constraints) constraints = td->encoding_constraints.oer_constraints;
+    if(constraints) ct = constraints->value;
+
+    er.encoded = 0;
+
+    buf = st->buf;
+    end = buf + st->size;
+
+    sign = (buf && buf < end) ? buf[0] & 0x80 : 0;
+
+    /* Ignore 9 leading zeroes or ones */
+    if(ct.positive) {
+        if(sign) {
+            /* The value given is a signed value. Can't proceed. */
+            ASN__ENCODE_FAILED;
+        }
+        /* Remove leading zeros. */
+        for(; buf + 1 < end; buf++) {
+            if(buf[0] != 0x0) break;
+        }
+    } else {
+        for(; buf + 1 < end; buf++) {
+            if(buf[0] == 0x0 && (buf[1] & 0x80) == 0) {
+                continue;
+            } else if(buf[0] == 0xff && (buf[1] & 0x80) != 0) {
+                continue;
+            }
+            break;
+        }
+    }
+
+    useful_bytes = end - buf;
+    if(ct.width) {
+        req_bytes = ct.width;
+    } else {
+        ssize_t r = oer_serialize_length(useful_bytes, cb, app_key);
+        if(r < 0) {
+            ASN__ENCODE_FAILED;
+        }
+        er.encoded += r;
+        req_bytes = useful_bytes;
+    }
+
+    if(req_bytes < useful_bytes) {
+        ASN__ENCODE_FAILED;
+    }
+
+    er.encoded += req_bytes;
+
+    for(; req_bytes > useful_bytes; req_bytes--) {
+        if(cb(sign?"\xff":"\0", 1, app_key) < 0) {
+            ASN__ENCODE_FAILED;
+        }
+    }
+
+    if(cb(buf, useful_bytes, app_key) < 0) {
+        ASN__ENCODE_FAILED;
+    }
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_print.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_print.c
new file mode 100644
index 000000000..72b9a9e6b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_print.c
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+/*
+ * INTEGER specific human-readable output.
+ */
+int
+INTEGER_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+              asn_app_consume_bytes_f *cb, void *app_key) {
+    const INTEGER_t *st = (const INTEGER_t *)sptr;
+    ssize_t ret;
+
+    (void)ilevel;
+
+    if(!st || !st->buf)
+        ret = cb("<absent>", 8, app_key);
+    else
+        ret = INTEGER__dump(td, st, cb, app_key, 0);
+
+    return (ret < 0) ? -1 : 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_rfill.c
new file mode 100644
index 000000000..ccea71798
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_rfill.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+asn_random_fill_result_t
+INTEGER_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                    const asn_encoding_constraints_t *constraints,
+                    size_t max_length) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    INTEGER_t *st = *sptr;
+    const asn_INTEGER_enum_map_t *emap;
+    size_t emap_len;
+    intmax_t value;
+    int find_inside_map;
+
+    if(max_length == 0) return result_skipped;
+
+    if(st == NULL) {
+        st = (INTEGER_t *)CALLOC(1, sizeof(*st));
+        if(st == NULL) {
+            return result_failed;
+        }
+    }
+
+    if(specs) {
+        emap = specs->value2enum;
+        emap_len = specs->map_count;
+        if(specs->strict_enumeration) {
+            find_inside_map = emap_len > 0;
+        } else {
+            find_inside_map = emap_len ? asn_random_between(0, 1) : 0;
+        }
+    } else {
+        emap = 0;
+        emap_len = 0;
+        find_inside_map = 0;
+    }
+
+    if(find_inside_map) {
+        assert(emap_len > 0);
+        value = emap[asn_random_between(0, emap_len - 1)].nat_value;
+    } else {
+        static const long variants[] = {
+            -65536, -65535, -65534, -32769, -32768, -32767, -16385, -16384,
+            -16383, -257,   -256,   -255,   -254,   -129,   -128,   -127,
+            -126,   -1,     0,      1,      126,    127,    128,    129,
+            254,    255,    256,    257,    16383,  16384,  16385,  32767,
+            32768,  32769,  65534,  65535,  65536,  65537};
+        if(specs && specs->field_unsigned) {
+            assert(variants[18] == 0);
+            value = variants[asn_random_between(
+                18, sizeof(variants) / sizeof(variants[0]) - 1)];
+        } else {
+            value = variants[asn_random_between(
+                0, sizeof(variants) / sizeof(variants[0]) - 1)];
+        }
+
+        if(!constraints) constraints = &td->encoding_constraints;
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        const asn_per_constraints_t *ct;
+
+        ct = constraints ? constraints->per_constraints : 0;
+        if(ct && (ct->value.flags & APC_CONSTRAINED)) {
+            if(value < ct->value.lower_bound || value > ct->value.upper_bound) {
+                value = asn_random_between(ct->value.lower_bound,
+                                           ct->value.upper_bound);
+            }
+        }
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+    }
+
+    if(asn_imax2INTEGER(st, value)) {
+        if(st == *sptr) {
+            ASN_STRUCT_RESET(*td, st);
+        } else {
+            ASN_STRUCT_FREE(*td, st);
+        }
+        return result_failed;
+    } else {
+        *sptr = st;
+        result_ok.length = st->size;
+        return result_ok;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_uper.c
new file mode 100644
index 000000000..699205cea
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_uper.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+asn_dec_rval_t
+INTEGER_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                    const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints, void **sptr,
+                    asn_per_data_t *pd) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval = { RC_OK, 0 };
+    INTEGER_t *st = (INTEGER_t *)*sptr;
+    const asn_per_constraint_t *ct;
+    int repeat;
+
+    (void)opt_codec_ctx;
+
+    if(!st) {
+        st = (INTEGER_t *)(*sptr = CALLOC(1, sizeof(*st)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    if(!constraints) constraints = td->encoding_constraints.per_constraints;
+    ct = constraints ? &constraints->value : 0;
+
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        int inext = per_get_few_bits(pd, 1);
+        if(inext < 0) ASN__DECODE_STARVED;
+        if(inext) ct = 0;
+    }
+
+    FREEMEM(st->buf);
+    st->buf = 0;
+    st->size = 0;
+    if(ct) {
+        if(ct->flags & APC_SEMI_CONSTRAINED) {
+            st->buf = (uint8_t *)CALLOC(1, 2);
+            if(!st->buf) ASN__DECODE_FAILED;
+            st->size = 1;
+        } else if(ct->flags & APC_CONSTRAINED && ct->range_bits >= 0) {
+            size_t size = (ct->range_bits + 7) >> 3;
+            st->buf = (uint8_t *)MALLOC(1 + size + 1);
+            if(!st->buf) ASN__DECODE_FAILED;
+            st->size = size;
+        }
+    }
+
+    /* X.691-2008/11, #13.2.2, constrained whole number */
+    if(ct && ct->flags != APC_UNCONSTRAINED) {
+        /* #11.5.6 */
+        ASN_DEBUG("Integer with range %d bits", ct->range_bits);
+        if(ct->range_bits >= 0) {
+            if((size_t)ct->range_bits > 8 * sizeof(uintmax_t))
+                ASN__DECODE_FAILED;
+
+            if(specs && specs->field_unsigned) {
+                uintmax_t uvalue = 0;
+                if(uper_get_constrained_whole_number(pd,
+                    &uvalue, ct->range_bits))
+                    ASN__DECODE_STARVED;
+                ASN_DEBUG("Got value %"ASN_PRIuMAX" + low %"ASN_PRIdMAX"",
+                    uvalue, ct->lower_bound);
+                uvalue += ct->lower_bound;
+                if(asn_umax2INTEGER(st, uvalue))
+                    ASN__DECODE_FAILED;
+            } else {
+                uintmax_t uvalue = 0;
+                intmax_t svalue;
+                if(uper_get_constrained_whole_number(pd,
+                    &uvalue, ct->range_bits))
+                    ASN__DECODE_STARVED;
+                ASN_DEBUG("Got value %"ASN_PRIuMAX" + low %"ASN_PRIdMAX"",
+                uvalue, ct->lower_bound);
+                if(per_imax_range_unrebase(uvalue, ct->lower_bound,
+                                           ct->upper_bound, &svalue)
+                   || asn_imax2INTEGER(st, svalue)) {
+                    ASN__DECODE_FAILED;
+                }
+            }
+            return rval;
+        }
+    } else {
+        ASN_DEBUG("Decoding unconstrained integer %s", td->name);
+    }
+
+    /* X.691, #12.2.3, #12.2.4 */
+    do {
+        ssize_t len = 0;
+        void *p = NULL;
+        int ret = 0;
+
+        /* Get the PER length */
+        len = uper_get_length(pd, -1, 0, &repeat);
+        if(len < 0) ASN__DECODE_STARVED;
+
+        p = REALLOC(st->buf, st->size + len + 1);
+        if(!p) ASN__DECODE_FAILED;
+        st->buf = (uint8_t *)p;
+
+        ret = per_get_many_bits(pd, &st->buf[st->size], 0, 8 * len);
+        if(ret < 0) ASN__DECODE_STARVED;
+        st->size += len;
+    } while(repeat);
+    st->buf[st->size] = 0;  /* JIC */
+
+    /* #12.2.3 */
+    if(ct && ct->lower_bound) {
+        /*
+         * TODO: replace by in-place arithmetic.
+         */
+        long value = 0;
+        if(asn_INTEGER2long(st, &value))
+            ASN__DECODE_FAILED;
+        if(asn_imax2INTEGER(st, value + ct->lower_bound))
+            ASN__DECODE_FAILED;
+    }
+
+    return rval;
+}
+
+asn_enc_rval_t
+INTEGER_encode_uper(const asn_TYPE_descriptor_t *td,
+                    const asn_per_constraints_t *constraints, const void *sptr,
+                    asn_per_outp_t *po) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    const INTEGER_t *st = (const INTEGER_t *)sptr;
+    const uint8_t *buf;
+    const uint8_t *end;
+    const asn_per_constraint_t *ct;
+    union {
+        intmax_t s;
+        uintmax_t u;
+    } value;
+
+    if(!st || st->size == 0) ASN__ENCODE_FAILED;
+
+    if(!constraints) constraints = td->encoding_constraints.per_constraints;
+    ct = constraints ? &constraints->value : 0;
+
+    er.encoded = 0;
+
+    if(ct) {
+        int inext = 0;
+        if(specs && specs->field_unsigned) {
+            if(asn_INTEGER2umax(st, &value.u))
+                ASN__ENCODE_FAILED;
+            /* Check proper range */
+            if(ct->flags & APC_SEMI_CONSTRAINED) {
+                if(value.u < (uintmax_t)ct->lower_bound)
+                    inext = 1;
+            } else if(ct->range_bits >= 0) {
+                if(value.u < (uintmax_t)ct->lower_bound
+                || value.u > (uintmax_t)ct->upper_bound)
+                    inext = 1;
+            }
+            ASN_DEBUG("Value %"ASN_PRIuMAX" (%02x/%" ASN_PRI_SIZE ") lb %"ASN_PRIuMAX" ub %"ASN_PRIuMAX" %s",
+                      value.u, st->buf[0], st->size,
+                      (uintmax_t)ct->lower_bound, (uintmax_t)ct->upper_bound,
+                      inext ? "ext" : "fix");
+        } else {
+            if(asn_INTEGER2imax(st, &value.s))
+                ASN__ENCODE_FAILED;
+            /* Check proper range */
+            if(ct->flags & APC_SEMI_CONSTRAINED) {
+                if(value.s < ct->lower_bound)
+                    inext = 1;
+            } else if(ct->range_bits >= 0) {
+                if(value.s < ct->lower_bound
+                || value.s > ct->upper_bound)
+                    inext = 1;
+            }
+            ASN_DEBUG("Value %"ASN_PRIdMAX" (%02x/%" ASN_PRI_SIZE ") lb %"ASN_PRIdMAX" ub %"ASN_PRIdMAX" %s",
+                      value.s, st->buf[0], st->size,
+                      ct->lower_bound, ct->upper_bound,
+                      inext ? "ext" : "fix");
+        }
+        if(ct->flags & APC_EXTENSIBLE) {
+            if(per_put_few_bits(po, inext, 1))
+                ASN__ENCODE_FAILED;
+            if(inext) ct = 0;
+        } else if(inext) {
+            ASN__ENCODE_FAILED;
+        }
+    }
+
+    /* X.691-11/2008, #13.2.2, test if constrained whole number */
+    if(ct && ct->range_bits >= 0) {
+        uintmax_t v;
+        /* #11.5.6 -> #11.3 */
+        if(specs && specs->field_unsigned) {
+            if(((uintmax_t)ct->lower_bound > (uintmax_t)(ct->upper_bound)
+            || (value.u < (uintmax_t)ct->lower_bound))
+            || (value.u > (uintmax_t)ct->upper_bound)) {
+                ASN_DEBUG("Value %"ASN_PRIuMAX" to-be-encoded is outside the bounds [%"ASN_PRIuMAX", %"ASN_PRIuMAX"]!",
+                          value.u, (uintmax_t)ct->lower_bound, (uintmax_t)ct->upper_bound);
+                ASN__ENCODE_FAILED;
+            }
+            v = value.u - (uintmax_t)ct->lower_bound;
+        } else {
+            if(per_imax_range_rebase(value.s, ct->lower_bound, ct->upper_bound, &v)) {
+                ASN__ENCODE_FAILED;
+            }
+        }
+        ASN_DEBUG("Encoding integer %"ASN_PRIuMAX" with range %d bits",
+                  v, ct->range_bits);
+        if(uper_put_constrained_whole_number_u(po, v, ct->range_bits))
+            ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    }
+
+    if(ct && ct->lower_bound) {
+        ASN_DEBUG("Adjust lower bound to %"ASN_PRIdMAX"", ct->lower_bound);
+        /* TODO: adjust lower bound */
+        ASN__ENCODE_FAILED;
+    }
+
+    for(buf = st->buf, end = st->buf + st->size; buf < end;) {
+        int need_eom = 0;
+        ssize_t mayEncode = uper_put_length(po, end - buf, &need_eom);
+        if(mayEncode < 0)
+            ASN__ENCODE_FAILED;
+        if(per_put_many_bits(po, buf, 8 * mayEncode))
+            ASN__ENCODE_FAILED;
+        buf += mayEncode;
+        if(need_eom && uper_put_length(po, 0, 0)) ASN__ENCODE_FAILED;
+    }
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_xer.c
new file mode 100644
index 000000000..41f9f212e
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/INTEGER_xer.c
@@ -0,0 +1,351 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+
+struct e2v_key {
+    const char *start;
+    const char *stop;
+    const asn_INTEGER_enum_map_t *vemap;
+    const unsigned int *evmap;
+};
+static int
+INTEGER__compar_enum2value(const void *kp, const void *am) {
+    const struct e2v_key *key = (const struct e2v_key *)kp;
+    const asn_INTEGER_enum_map_t *el = (const asn_INTEGER_enum_map_t *)am;
+    const char *ptr, *end, *name;
+
+    /* Remap the element (sort by different criterion) */
+    el = key->vemap + key->evmap[el - key->vemap];
+
+    /* Compare strings */
+    for(ptr = key->start, end = key->stop, name = el->enum_name;
+            ptr < end; ptr++, name++) {
+        if(*ptr != *name || !*name)
+            return *(const unsigned char *)ptr - *(const unsigned char *)name;
+    }
+    return name[0] ? -1 : 0;
+}
+
+static const asn_INTEGER_enum_map_t *
+INTEGER_map_enum2value(const asn_INTEGER_specifics_t *specs, const char *lstart,
+                       const char *lstop) {
+    const asn_INTEGER_enum_map_t *el_found;
+    int count = specs ? specs->map_count : 0;
+    struct e2v_key key;
+    const char *lp;
+
+    if(!count) return NULL;
+
+    /* Guaranteed: assert(lstart < lstop); */
+    /* Figure out the tag name */
+    for(lstart++, lp = lstart; lp < lstop; lp++) {
+        switch(*lp) {
+        case 9: case 10: case 11: case 12: case 13: case 32: /* WSP */
+        case 0x2f: /* '/' */ case 0x3e: /* '>' */
+            break;
+        default:
+            continue;
+        }
+        break;
+    }
+    if(lp == lstop) return NULL;  /* No tag found */
+    lstop = lp;
+
+    key.start = lstart;
+    key.stop = lstop;
+    key.vemap = specs->value2enum;
+    key.evmap = specs->enum2value;
+    el_found = (asn_INTEGER_enum_map_t *)bsearch(&key,
+        specs->value2enum, count, sizeof(specs->value2enum[0]),
+        INTEGER__compar_enum2value);
+    if(el_found) {
+        /* Remap enum2value into value2enum */
+        el_found = key.vemap + key.evmap[el_found - key.vemap];
+    }
+    return el_found;
+}
+
+static int
+INTEGER_st_prealloc(INTEGER_t *st, int min_size) {
+    void *p = MALLOC(min_size + 1);
+    if(p) {
+        void *b = st->buf;
+        st->size = 0;
+        st->buf = p;
+        FREEMEM(b);
+        return 0;
+    } else {
+        return -1;
+    }
+}
+
+/*
+ * Decode the chunk of XML text encoding INTEGER.
+ */
+static enum xer_pbd_rval
+INTEGER__xer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,
+                         const void *chunk_buf, size_t chunk_size) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    INTEGER_t *st = (INTEGER_t *)sptr;
+    intmax_t dec_value;
+    intmax_t hex_value = 0;
+    const char *lp;
+    const char *lstart = (const char *)chunk_buf;
+    const char *lstop = lstart + chunk_size;
+    enum {
+        ST_LEADSPACE,
+        ST_SKIPSPHEX,
+        ST_WAITDIGITS,
+        ST_DIGITS,
+        ST_DIGITS_TRAILSPACE,
+        ST_HEXDIGIT1,
+        ST_HEXDIGIT2,
+        ST_HEXDIGITS_TRAILSPACE,
+        ST_HEXCOLON,
+        ST_END_ENUM,
+        ST_UNEXPECTED
+    } state = ST_LEADSPACE;
+    const char *dec_value_start = 0; /* INVARIANT: always !0 in ST_DIGITS */
+    const char *dec_value_end = 0;
+
+    if(chunk_size)
+        ASN_DEBUG("INTEGER body %ld 0x%2x..0x%2x",
+                  (long)chunk_size, *lstart, lstop[-1]);
+
+    if(INTEGER_st_prealloc(st, (chunk_size/3) + 1))
+        return XPBD_SYSTEM_FAILURE;
+
+    /*
+     * We may have received a tag here. It will be processed inline.
+     * Use strtoul()-like code and serialize the result.
+     */
+    for(lp = lstart; lp < lstop; lp++) {
+        int lv = *lp;
+        switch(lv) {
+        case 0x09: case 0x0a: case 0x0d: case 0x20:
+            switch(state) {
+            case ST_LEADSPACE:
+            case ST_DIGITS_TRAILSPACE:
+            case ST_HEXDIGITS_TRAILSPACE:
+            case ST_SKIPSPHEX:
+                continue;
+            case ST_DIGITS:
+                dec_value_end = lp;
+                state = ST_DIGITS_TRAILSPACE;
+                continue;
+            case ST_HEXCOLON:
+                state = ST_HEXDIGITS_TRAILSPACE;
+                continue;
+            default:
+                break;
+            }
+            break;
+        case 0x2d:  /* '-' */
+            if(state == ST_LEADSPACE) {
+                dec_value = 0;
+                dec_value_start = lp;
+                state = ST_WAITDIGITS;
+                continue;
+            }
+            break;
+        case 0x2b:  /* '+' */
+            if(state == ST_LEADSPACE) {
+                dec_value = 0;
+                dec_value_start = lp;
+                state = ST_WAITDIGITS;
+                continue;
+            }
+            break;
+        case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:
+        case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:
+            switch(state) {
+            case ST_DIGITS: continue;
+            case ST_SKIPSPHEX:  /* Fall through */
+            case ST_HEXDIGIT1:
+                hex_value = (lv - 0x30) << 4;
+                state = ST_HEXDIGIT2;
+                continue;
+            case ST_HEXDIGIT2:
+                hex_value += (lv - 0x30);
+                state = ST_HEXCOLON;
+                st->buf[st->size++] = (uint8_t)hex_value;
+                continue;
+            case ST_HEXCOLON:
+                return XPBD_BROKEN_ENCODING;
+            case ST_LEADSPACE:
+                dec_value = 0;
+                dec_value_start = lp;
+                /* FALL THROUGH */
+            case ST_WAITDIGITS:
+                state = ST_DIGITS;
+                continue;
+            default:
+                break;
+            }
+            break;
+        case 0x3c:  /* '<', start of XML encoded enumeration */
+            if(state == ST_LEADSPACE) {
+                const asn_INTEGER_enum_map_t *el;
+                el = INTEGER_map_enum2value(
+                    (const asn_INTEGER_specifics_t *)
+                    td->specifics, lstart, lstop);
+                if(el) {
+                    ASN_DEBUG("Found \"%s\" => %ld",
+                              el->enum_name, el->nat_value);
+                    dec_value = el->nat_value;
+                    state = ST_END_ENUM;
+                    lp = lstop - 1;
+                    continue;
+                }
+                ASN_DEBUG("Unknown identifier for INTEGER");
+            }
+            return XPBD_BROKEN_ENCODING;
+        case 0x3a:  /* ':' */
+            if(state == ST_HEXCOLON) {
+                /* This colon is expected */
+                state = ST_HEXDIGIT1;
+                continue;
+            } else if(state == ST_DIGITS) {
+                /* The colon here means that we have
+                 * decoded the first two hexadecimal
+                 * places as a decimal value.
+                 * Switch decoding mode. */
+                ASN_DEBUG("INTEGER re-evaluate as hex form");
+                state = ST_SKIPSPHEX;
+                dec_value_start = 0;
+                lp = lstart - 1;
+                continue;
+            } else {
+                ASN_DEBUG("state %d at %ld", state, (long)(lp - lstart));
+                break;
+            }
+        /* [A-Fa-f] */
+        case 0x41:case 0x42:case 0x43:case 0x44:case 0x45:case 0x46:
+        case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:case 0x66:
+            switch(state) {
+            case ST_SKIPSPHEX:
+            case ST_LEADSPACE: /* Fall through */
+            case ST_HEXDIGIT1:
+                hex_value = lv - ((lv < 0x61) ? 0x41 : 0x61);
+                hex_value += 10;
+                hex_value <<= 4;
+                state = ST_HEXDIGIT2;
+                continue;
+            case ST_HEXDIGIT2:
+                hex_value += lv - ((lv < 0x61) ? 0x41 : 0x61);
+                hex_value += 10;
+                st->buf[st->size++] = (uint8_t)hex_value;
+                state = ST_HEXCOLON;
+                continue;
+            case ST_DIGITS:
+                ASN_DEBUG("INTEGER re-evaluate as hex form");
+                state = ST_SKIPSPHEX;
+                dec_value_start = 0;
+                lp = lstart - 1;
+                continue;
+            default:
+                break;
+            }
+            break;
+        }
+
+        /* Found extra non-numeric stuff */
+        ASN_DEBUG("INTEGER :: Found non-numeric 0x%2x at %ld",
+                  lv, (long)(lp - lstart));
+        state = ST_UNEXPECTED;
+        break;
+    }
+
+    switch(state) {
+    case ST_END_ENUM:
+        /* Got a complete and valid enumeration encoded as a tag. */
+        break;
+    case ST_DIGITS:
+        dec_value_end = lstop;
+        /* FALL THROUGH */
+    case ST_DIGITS_TRAILSPACE:
+        /* The last symbol encountered was a digit. */
+        switch(asn_strtoimax_lim(dec_value_start, &dec_value_end, &dec_value)) {
+        case ASN_STRTOX_OK:
+            if(specs && specs->field_unsigned && (uintmax_t) dec_value <= ULONG_MAX) {
+                break;
+            } else if(dec_value >= LONG_MIN && dec_value <= LONG_MAX) {
+                break;
+            } else {
+                /*
+                 * We model INTEGER on long for XER,
+                 * to avoid rewriting all the tests at once.
+                 */
+                ASN_DEBUG("INTEGER exceeds long range");
+            }
+            /* Fall through */
+        case ASN_STRTOX_ERROR_RANGE:
+            ASN_DEBUG("INTEGER decode %s hit range limit", td->name);
+            return XPBD_DECODER_LIMIT;
+        case ASN_STRTOX_ERROR_INVAL:
+        case ASN_STRTOX_EXPECT_MORE:
+        case ASN_STRTOX_EXTRA_DATA:
+            return XPBD_BROKEN_ENCODING;
+        }
+        break;
+    case ST_HEXCOLON:
+    case ST_HEXDIGITS_TRAILSPACE:
+        st->buf[st->size] = 0;  /* Just in case termination */
+        return XPBD_BODY_CONSUMED;
+    case ST_HEXDIGIT1:
+    case ST_HEXDIGIT2:
+    case ST_SKIPSPHEX:
+        return XPBD_BROKEN_ENCODING;
+    case ST_LEADSPACE:
+        /* Content not found */
+        return XPBD_NOT_BODY_IGNORE;
+    case ST_WAITDIGITS:
+    case ST_UNEXPECTED:
+        ASN_DEBUG("INTEGER: No useful digits (state %d)", state);
+        return XPBD_BROKEN_ENCODING;  /* No digits */
+    }
+
+    /*
+     * Convert the result of parsing of enumeration or a straight
+     * decimal value into a BER representation.
+     */
+    if(asn_imax2INTEGER(st, dec_value)) {
+                ASN_DEBUG("INTEGER decode %s conversion failed", td->name);
+        return XPBD_SYSTEM_FAILURE;
+        }
+
+    return XPBD_BODY_CONSUMED;
+}
+
+asn_dec_rval_t
+INTEGER_decode_xer(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td, void **sptr,
+                   const char *opt_mname, const void *buf_ptr, size_t size) {
+    return xer_decode_primitive(opt_codec_ctx, td,
+        sptr, sizeof(INTEGER_t), opt_mname,
+        buf_ptr, size, INTEGER__xer_body_decode);
+}
+
+asn_enc_rval_t
+INTEGER_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                   int ilevel, enum xer_encoder_flags_e flags,
+                   asn_app_consume_bytes_f *cb, void *app_key) {
+    const INTEGER_t *st = (const INTEGER_t *)sptr;
+    asn_enc_rval_t er = {0,0,0};
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!st || !st->buf)
+        ASN__ENCODE_FAILED;
+
+    er.encoded = INTEGER__dump(td, st, cb, app_key, 1);
+    if(er.encoded < 0) ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/IPv6Socket.c /ext/source/modules/EVSE/EvseV2G/asn1/IPv6Socket.c
new file mode 100644
index 000000000..c12803bec
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/IPv6Socket.c
@@ -0,0 +1,169 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "IPv6Socket.h"
+
+static int
+memb_ipv6Address_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	size = st->size;
+	
+	if((size == 16UL)) {
+		/* Constraint check succeeded */
+		return 0;
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+static int
+memb_tcpPort_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	size = st->size;
+	
+	if((size == 4UL)) {
+		/* Constraint check succeeded */
+		return 0;
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_ipv6Address_constr_2 CC_NOTUSED = {
+	{ 0, 0 },
+	16	/* (SIZE(16..16)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_ipv6Address_constr_2 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_CONSTRAINED,	 0,  0,  16,  16 }	/* (SIZE(16..16)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_tcpPort_constr_3 CC_NOTUSED = {
+	{ 0, 0 },
+	4	/* (SIZE(4..4)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_tcpPort_constr_3 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_CONSTRAINED,	 0,  0,  4,  4 }	/* (SIZE(4..4)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_IPv6Socket_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct IPv6Socket, ipv6Address),
+		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
+		0,
+		&asn_DEF_OCTET_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_ipv6Address_constr_2,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_ipv6Address_constr_2,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_ipv6Address_constraint_1
+		},
+		0, 0, /* No default value */
+		"ipv6Address"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct IPv6Socket, tcpPort),
+		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
+		0,
+		&asn_DEF_OCTET_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_tcpPort_constr_3,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_tcpPort_constr_3,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_tcpPort_constraint_1
+		},
+		0, 0, /* No default value */
+		"tcpPort"
+		},
+};
+static const ber_tlv_tag_t asn_DEF_IPv6Socket_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_IPv6Socket_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)), 0, 0, 1 }, /* ipv6Address */
+    { (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)), 1, -1, 0 } /* tcpPort */
+};
+static asn_SEQUENCE_specifics_t asn_SPC_IPv6Socket_specs_1 = {
+	sizeof(struct IPv6Socket),
+	offsetof(struct IPv6Socket, _asn_ctx),
+	asn_MAP_IPv6Socket_tag2el_1,
+	2,	/* Count of tags in the map */
+	0, 0, 0,	/* Optional elements (not needed) */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_IPv6Socket = {
+	"IPv6Socket",
+	"IPv6Socket",
+	&asn_OP_SEQUENCE,
+	asn_DEF_IPv6Socket_tags_1,
+	sizeof(asn_DEF_IPv6Socket_tags_1)
+		/sizeof(asn_DEF_IPv6Socket_tags_1[0]), /* 1 */
+	asn_DEF_IPv6Socket_tags_1,	/* Same as above */
+	sizeof(asn_DEF_IPv6Socket_tags_1)
+		/sizeof(asn_DEF_IPv6Socket_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_IPv6Socket_1,
+	2,	/* Elements count */
+	&asn_SPC_IPv6Socket_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/IPv6Socket.h /ext/source/modules/EVSE/EvseV2G/asn1/IPv6Socket.h
new file mode 100644
index 000000000..a014a3e9b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/IPv6Socket.h
@@ -0,0 +1,39 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_IPv6Socket_H_
+#define	_IPv6Socket_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "OCTET_STRING.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* IPv6Socket */
+typedef struct IPv6Socket {
+	OCTET_STRING_t	 ipv6Address;
+	OCTET_STRING_t	 tcpPort;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} IPv6Socket_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_IPv6Socket;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _IPv6Socket_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/Makefile.am.libasncodec /ext/source/modules/EVSE/EvseV2G/asn1/Makefile.am.libasncodec
new file mode 100644
index 000000000..cea31a6be
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/Makefile.am.libasncodec
@@ -0,0 +1,259 @@
+ASN_MODULE_SRCS=	\
+	Extensions.c	\
+	StandardizedExtensions.c	\
+	StandardizedExtension.c	\
+	ExternalExtensions.c	\
+	ExternalExtension.c	\
+	ChargingInterface.c	\
+	BasicSignaling.c	\
+	BasicSignalingProtocol.c	\
+	IPv6Socket.c	\
+	HighLevelCommunication.c	\
+	HighLevelCommunicationTuple.c	\
+	SecurityProfileTuple.c	\
+	HLCProtocol.c	\
+	SecurityProfile.c	\
+	AuthorizationMethod.c	\
+	EnergyTransferMode.c	\
+	EMSPIdentifiers.c	\
+	EMSPIdentifier.c	\
+	DCChargingLimits.c	\
+	ConductiveChargingInterfaceLimitations.c	\
+	EVCharacteristics.c	\
+	ChargingStationCharacteristics.c	\
+	EXTERNAL.c
+
+ASN_MODULE_HDRS=	\
+	Extensions.h	\
+	StandardizedExtensions.h	\
+	StandardizedExtension.h	\
+	ExternalExtensions.h	\
+	ExternalExtension.h	\
+	ChargingInterface.h	\
+	BasicSignaling.h	\
+	BasicSignalingProtocol.h	\
+	IPv6Socket.h	\
+	HighLevelCommunication.h	\
+	HighLevelCommunicationTuple.h	\
+	SecurityProfileTuple.h	\
+	HLCProtocol.h	\
+	SecurityProfile.h	\
+	AuthorizationMethod.h	\
+	EnergyTransferMode.h	\
+	EMSPIdentifiers.h	\
+	EMSPIdentifier.h	\
+	DCChargingLimits.h	\
+	ConductiveChargingInterfaceLimitations.h	\
+	EVCharacteristics.h	\
+	ChargingStationCharacteristics.h	\
+	EXTERNAL.h
+
+ASN_MODULE_HDRS+=ANY.h
+ASN_MODULE_SRCS+=ANY.c
+ASN_MODULE_HDRS+=OCTET_STRING.h
+ASN_MODULE_HDRS+=OPEN_TYPE.h
+ASN_MODULE_SRCS+=OPEN_TYPE.c
+ASN_MODULE_HDRS+=constr_CHOICE.h
+ASN_MODULE_HDRS+=BOOLEAN.h
+ASN_MODULE_SRCS+=BOOLEAN.c
+ASN_MODULE_HDRS+=ENUMERATED.h
+ASN_MODULE_SRCS+=ENUMERATED.c
+ASN_MODULE_HDRS+=INTEGER.h
+ASN_MODULE_HDRS+=NativeEnumerated.h
+ASN_MODULE_HDRS+=GraphicString.h
+ASN_MODULE_SRCS+=GraphicString.c
+ASN_MODULE_SRCS+=INTEGER.c
+ASN_MODULE_SRCS+=NativeEnumerated.c
+ASN_MODULE_HDRS+=NativeInteger.h
+ASN_MODULE_SRCS+=NativeInteger.c
+ASN_MODULE_HDRS+=OBJECT_IDENTIFIER.h
+ASN_MODULE_SRCS+=OBJECT_IDENTIFIER.c
+ASN_MODULE_HDRS+=asn_codecs_prim.h
+ASN_MODULE_HDRS+=ObjectDescriptor.h
+ASN_MODULE_SRCS+=ObjectDescriptor.c
+ASN_MODULE_HDRS+=UTF8String.h
+ASN_MODULE_SRCS+=UTF8String.c
+ASN_MODULE_HDRS+=asn_SEQUENCE_OF.h
+ASN_MODULE_SRCS+=asn_SEQUENCE_OF.c
+ASN_MODULE_HDRS+=asn_SET_OF.h
+ASN_MODULE_SRCS+=asn_SET_OF.c
+ASN_MODULE_SRCS+=constr_CHOICE.c
+ASN_MODULE_HDRS+=constr_SEQUENCE.h
+ASN_MODULE_SRCS+=constr_SEQUENCE.c
+ASN_MODULE_HDRS+=constr_SEQUENCE_OF.h
+ASN_MODULE_SRCS+=constr_SEQUENCE_OF.c
+ASN_MODULE_HDRS+=constr_SET_OF.h
+ASN_MODULE_SRCS+=constr_SET_OF.c
+ASN_MODULE_HDRS+=asn_application.h
+ASN_MODULE_SRCS+=asn_application.c
+ASN_MODULE_HDRS+=asn_ioc.h
+ASN_MODULE_HDRS+=asn_system.h
+ASN_MODULE_HDRS+=asn_codecs.h
+ASN_MODULE_HDRS+=asn_internal.h
+ASN_MODULE_SRCS+=asn_internal.c
+ASN_MODULE_HDRS+=asn_bit_data.h
+ASN_MODULE_SRCS+=asn_bit_data.c
+ASN_MODULE_SRCS+=OCTET_STRING.c
+ASN_MODULE_HDRS+=BIT_STRING.h
+ASN_MODULE_SRCS+=BIT_STRING.c
+ASN_MODULE_SRCS+=asn_codecs_prim.c
+ASN_MODULE_HDRS+=ber_tlv_length.h
+ASN_MODULE_SRCS+=ber_tlv_length.c
+ASN_MODULE_HDRS+=ber_tlv_tag.h
+ASN_MODULE_SRCS+=ber_tlv_tag.c
+ASN_MODULE_HDRS+=constr_TYPE.h
+ASN_MODULE_SRCS+=constr_TYPE.c
+ASN_MODULE_HDRS+=constraints.h
+ASN_MODULE_SRCS+=constraints.c
+ASN_MODULE_HDRS+=ber_decoder.h
+ASN_MODULE_HDRS+=der_encoder.h
+ASN_MODULE_SRCS+=ber_decoder.c
+ASN_MODULE_SRCS+=der_encoder.c
+ASN_MODULE_SRCS+=ANY_ber.c
+ASN_MODULE_SRCS+=BOOLEAN_ber.c
+ASN_MODULE_SRCS+=INTEGER_ber.c
+ASN_MODULE_SRCS+=NativeInteger_ber.c
+ASN_MODULE_SRCS+=OCTET_STRING_ber.c
+ASN_MODULE_SRCS+=OPEN_TYPE_ber.c
+ASN_MODULE_SRCS+=asn_codecs_prim_ber.c
+ASN_MODULE_SRCS+=constr_CHOICE_ber.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_OF_ber.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_ber.c
+ASN_MODULE_SRCS+=constr_SET_OF_ber.c
+ASN_MODULE_HDRS+=xer_support.h
+ASN_MODULE_HDRS+=xer_decoder.h
+ASN_MODULE_HDRS+=xer_encoder.h
+ASN_MODULE_SRCS+=xer_support.c
+ASN_MODULE_SRCS+=xer_decoder.c
+ASN_MODULE_SRCS+=xer_encoder.c
+ASN_MODULE_SRCS+=ANY_xer.c
+ASN_MODULE_SRCS+=BIT_STRING_xer.c
+ASN_MODULE_SRCS+=BOOLEAN_xer.c
+ASN_MODULE_SRCS+=INTEGER_xer.c
+ASN_MODULE_SRCS+=NativeEnumerated_xer.c
+ASN_MODULE_SRCS+=NativeInteger_xer.c
+ASN_MODULE_SRCS+=OBJECT_IDENTIFIER_xer.c
+ASN_MODULE_SRCS+=OCTET_STRING_xer.c
+ASN_MODULE_SRCS+=OPEN_TYPE_xer.c
+ASN_MODULE_SRCS+=asn_codecs_prim_xer.c
+ASN_MODULE_SRCS+=constr_CHOICE_xer.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_OF_xer.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_xer.c
+ASN_MODULE_SRCS+=constr_SET_OF_xer.c
+ASN_MODULE_HDRS+=oer_decoder.h
+ASN_MODULE_HDRS+=oer_encoder.h
+ASN_MODULE_HDRS+=oer_support.h
+ASN_MODULE_SRCS+=oer_decoder.c
+ASN_MODULE_SRCS+=oer_encoder.c
+ASN_MODULE_SRCS+=oer_support.c
+ASN_MODULE_SRCS+=OPEN_TYPE_oer.c
+ASN_MODULE_SRCS+=INTEGER_oer.c
+ASN_MODULE_SRCS+=BIT_STRING_oer.c
+ASN_MODULE_SRCS+=OCTET_STRING_oer.c
+ASN_MODULE_SRCS+=NativeInteger_oer.c
+ASN_MODULE_SRCS+=NativeEnumerated_oer.c
+ASN_MODULE_SRCS+=constr_CHOICE_oer.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_oer.c
+ASN_MODULE_SRCS+=constr_SET_OF_oer.c
+ASN_MODULE_SRCS+=BOOLEAN_oer.c
+ASN_MODULE_SRCS+=ENUMERATED_oer.c
+ASN_MODULE_HDRS+=per_decoder.h
+ASN_MODULE_HDRS+=per_encoder.h
+ASN_MODULE_HDRS+=per_support.h
+ASN_MODULE_HDRS+=per_opentype.h
+ASN_MODULE_SRCS+=per_decoder.c
+ASN_MODULE_SRCS+=per_encoder.c
+ASN_MODULE_SRCS+=per_support.c
+ASN_MODULE_SRCS+=per_opentype.c
+ASN_MODULE_HDRS+=uper_decoder.h
+ASN_MODULE_HDRS+=uper_encoder.h
+ASN_MODULE_HDRS+=uper_support.h
+ASN_MODULE_HDRS+=uper_opentype.h
+ASN_MODULE_SRCS+=uper_decoder.c
+ASN_MODULE_SRCS+=uper_encoder.c
+ASN_MODULE_SRCS+=uper_support.c
+ASN_MODULE_SRCS+=uper_opentype.c
+ASN_MODULE_SRCS+=ANY_uper.c
+ASN_MODULE_SRCS+=BIT_STRING_uper.c
+ASN_MODULE_SRCS+=BOOLEAN_uper.c
+ASN_MODULE_SRCS+=ENUMERATED_uper.c
+ASN_MODULE_SRCS+=INTEGER_uper.c
+ASN_MODULE_SRCS+=NativeEnumerated_uper.c
+ASN_MODULE_SRCS+=NativeInteger_uper.c
+ASN_MODULE_SRCS+=OCTET_STRING_uper.c
+ASN_MODULE_SRCS+=OPEN_TYPE_uper.c
+ASN_MODULE_SRCS+=constr_CHOICE_uper.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_OF_uper.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_uper.c
+ASN_MODULE_SRCS+=constr_SET_OF_uper.c
+ASN_MODULE_HDRS+=aper_decoder.h
+ASN_MODULE_HDRS+=aper_encoder.h
+ASN_MODULE_HDRS+=aper_support.h
+ASN_MODULE_HDRS+=aper_opentype.h
+ASN_MODULE_SRCS+=aper_decoder.c
+ASN_MODULE_SRCS+=aper_encoder.c
+ASN_MODULE_SRCS+=aper_support.c
+ASN_MODULE_SRCS+=aper_opentype.c
+ASN_MODULE_SRCS+=ANY_aper.c
+ASN_MODULE_SRCS+=BOOLEAN_aper.c
+ASN_MODULE_SRCS+=ENUMERATED_aper.c
+ASN_MODULE_SRCS+=INTEGER_aper.c
+ASN_MODULE_SRCS+=NativeEnumerated_aper.c
+ASN_MODULE_SRCS+=NativeInteger_aper.c
+ASN_MODULE_SRCS+=OCTET_STRING_aper.c
+ASN_MODULE_SRCS+=OPEN_TYPE_aper.c
+ASN_MODULE_SRCS+=constr_CHOICE_aper.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_OF_aper.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_aper.c
+ASN_MODULE_SRCS+=constr_SET_OF_aper.c
+ASN_MODULE_SRCS+=BIT_STRING_print.c
+ASN_MODULE_SRCS+=BOOLEAN_print.c
+ASN_MODULE_SRCS+=INTEGER_print.c
+ASN_MODULE_SRCS+=NativeInteger_print.c
+ASN_MODULE_SRCS+=OBJECT_IDENTIFIER_print.c
+ASN_MODULE_SRCS+=OCTET_STRING_print.c
+ASN_MODULE_SRCS+=UTF8String_print.c
+ASN_MODULE_SRCS+=constr_CHOICE_print.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_print.c
+ASN_MODULE_SRCS+=constr_SET_OF_print.c
+ASN_MODULE_HDRS+=asn_random_fill.h
+ASN_MODULE_SRCS+=asn_random_fill.c
+ASN_MODULE_SRCS+=BIT_STRING_rfill.c
+ASN_MODULE_SRCS+=BOOLEAN_rfill.c
+ASN_MODULE_SRCS+=INTEGER_rfill.c
+ASN_MODULE_SRCS+=NativeInteger_rfill.c
+ASN_MODULE_SRCS+=OBJECT_IDENTIFIER_rfill.c
+ASN_MODULE_SRCS+=OCTET_STRING_rfill.c
+ASN_MODULE_SRCS+=UTF8String_rfill.c
+ASN_MODULE_SRCS+=constr_CHOICE_rfill.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_rfill.c
+ASN_MODULE_SRCS+=constr_SET_OF_rfill.c
+ASN_MODULE_HDRS+=jer_support.h
+ASN_MODULE_HDRS+=jer_decoder.h
+ASN_MODULE_HDRS+=jer_encoder.h
+ASN_MODULE_SRCS+=jer_support.c
+ASN_MODULE_SRCS+=jer_decoder.c
+ASN_MODULE_SRCS+=jer_encoder.c
+ASN_MODULE_SRCS+=ANY_jer.c
+ASN_MODULE_SRCS+=BIT_STRING_jer.c
+ASN_MODULE_SRCS+=BOOLEAN_jer.c
+ASN_MODULE_SRCS+=ENUMERATED_jer.c
+ASN_MODULE_SRCS+=INTEGER_jer.c
+ASN_MODULE_SRCS+=NativeEnumerated_jer.c
+ASN_MODULE_SRCS+=NativeInteger_jer.c
+ASN_MODULE_SRCS+=OBJECT_IDENTIFIER_jer.c
+ASN_MODULE_SRCS+=OCTET_STRING_jer.c
+ASN_MODULE_SRCS+=OPEN_TYPE_jer.c
+ASN_MODULE_SRCS+=asn_codecs_prim_jer.c
+ASN_MODULE_SRCS+=constr_CHOICE_jer.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_OF_jer.c
+ASN_MODULE_SRCS+=constr_SEQUENCE_jer.c
+ASN_MODULE_SRCS+=constr_SET_OF_jer.c
+
+ASN_MODULE_CFLAGS=
+
+lib_LTLIBRARIES+=libasncodec.la
+libasncodec_la_SOURCES=$(ASN_MODULE_SRCS) $(ASN_MODULE_HDRS)
+libasncodec_la_CPPFLAGS=-I$(top_srcdir)/
+libasncodec_la_CFLAGS=$(ASN_MODULE_CFLAGS)
+libasncodec_la_LDFLAGS=-lm
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated.c
new file mode 100644
index 000000000..0192c3b00
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated.c
@@ -0,0 +1,114 @@
+/*-
+ * Copyright (c) 2004, 2007 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * Read the NativeInteger.h for the explanation wrt. differences between
+ * INTEGER and NativeInteger.
+ * Basically, both are decoders and encoders of ASN.1 INTEGER type, but this
+ * implementation deals with the standard (machine-specific) representation
+ * of them instead of using the platform-independent buffer.
+ */
+#include "asn_internal.h"
+#include "NativeEnumerated.h"
+
+/*
+ * NativeEnumerated basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_NativeEnumerated_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_operation_t asn_OP_NativeEnumerated = {
+    NativeInteger_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    NativeInteger_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    NativeInteger_compare,
+    NativeInteger_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    NativeInteger_decode_ber,
+    NativeInteger_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    NativeInteger_decode_xer,
+    NativeEnumerated_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    NativeEnumerated_decode_jer,
+    NativeEnumerated_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    NativeEnumerated_decode_oer,
+    NativeEnumerated_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    NativeEnumerated_decode_uper,
+    NativeEnumerated_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    NativeEnumerated_decode_aper,
+    NativeEnumerated_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    NativeEnumerated_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_NativeEnumerated = {
+    "ENUMERATED",  /* The ASN.1 type is still ENUMERATED */
+    "ENUMERATED",
+    &asn_OP_NativeEnumerated,
+    asn_DEF_NativeEnumerated_tags,
+    sizeof(asn_DEF_NativeEnumerated_tags) / sizeof(asn_DEF_NativeEnumerated_tags[0]),
+    asn_DEF_NativeEnumerated_tags,  /* Same as above */
+    sizeof(asn_DEF_NativeEnumerated_tags) / sizeof(asn_DEF_NativeEnumerated_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_no_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+int
+NativeEnumerated__compar_value2enum(const void *ap, const void *bp) {
+    const asn_INTEGER_enum_map_t *a = ap;
+    const asn_INTEGER_enum_map_t *b = bp;
+    if(a->nat_value == b->nat_value)
+        return 0;
+    if(a->nat_value < b->nat_value)
+        return -1;
+    return 1;
+}
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated.h /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated.h
new file mode 100644
index 000000000..d916deb68
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * This type differs from the standard ENUMERATED in that it is modelled using
+ * the fixed machine type (long, int, short), so it can hold only values of
+ * limited length. There is no type (i.e., NativeEnumerated_t, any integer type
+ * will do).
+ * This type may be used when integer range is limited by subtype constraints.
+ */
+#ifndef	_NativeEnumerated_H_
+#define	_NativeEnumerated_H_
+
+#include "NativeInteger.h"
+#include "ENUMERATED.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern asn_TYPE_descriptor_t asn_DEF_NativeEnumerated;
+extern asn_TYPE_operation_t asn_OP_NativeEnumerated;
+
+#define NativeEnumerated_free NativeInteger_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+#define NativeEnumerated_print NativeInteger_print
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define NativeEnumerated_compare NativeInteger_compare
+#define NativeEnumerated_copy    NativeInteger_copy
+
+#define NativeEnumerated_constraint asn_generic_no_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define NativeEnumerated_decode_ber NativeInteger_decode_ber
+#define NativeEnumerated_encode_der NativeInteger_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define NativeEnumerated_decode_xer NativeInteger_decode_xer
+xer_type_encoder_f NativeEnumerated_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f NativeEnumerated_decode_jer;
+jer_type_encoder_f NativeEnumerated_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f NativeEnumerated_decode_oer;
+oer_type_encoder_f NativeEnumerated_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f NativeEnumerated_decode_uper;
+per_type_encoder_f NativeEnumerated_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f NativeEnumerated_decode_aper;
+per_type_encoder_f NativeEnumerated_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+#define NativeEnumerated_random_fill NativeInteger_random_fill
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+int NativeEnumerated__compar_value2enum(
+        const void *ap,
+        const void *bp);
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _NativeEnumerated_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_aper.c
new file mode 100644
index 000000000..c7ffdb12c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_aper.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeEnumerated.h"
+
+asn_dec_rval_t
+NativeEnumerated_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                             const asn_TYPE_descriptor_t *td,
+                             const asn_per_constraints_t *constraints,
+                             void **sptr, asn_per_data_t *pd) {
+    const asn_INTEGER_specifics_t *specs = (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval = { RC_OK, 0 };
+    long *native = (long *)*sptr;
+    const asn_per_constraint_t *ct;
+    long value;
+
+    (void)opt_codec_ctx;
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->value;
+    else ASN__DECODE_FAILED;  /* Mandatory! */
+    if(!specs) ASN__DECODE_FAILED;
+
+    if(!native) {
+        native = (long *)(*sptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    ASN_DEBUG("Decoding %s as NativeEnumerated", td->name);
+
+    if(ct->flags & APC_EXTENSIBLE) {
+        int inext = per_get_few_bits(pd, 1);
+        if(inext < 0) ASN__DECODE_STARVED;
+        if(inext) ct = 0;
+    }
+
+    /* Deal with APER padding */
+    if(ct && ct->upper_bound >= 255) {
+        int padding = 0;
+        padding = (8 - (pd->moved % 8)) % 8;
+        ASN_DEBUG("For NativeEnumerated %s,offset = %zu Padding bits = %d",
+                  td->name, pd->moved, padding);
+        ASN_DEBUG("For NativeEnumerated %s, upper bound = %llu",
+                  td->name, (unsigned long long)ct->upper_bound);
+        if(padding > 0)
+            per_get_few_bits(pd, padding);
+    }
+
+    if(ct && ct->range_bits >= 0) {
+        value = per_get_few_bits(pd, ct->range_bits);
+        if(value < 0) ASN__DECODE_STARVED;
+        if(value >= (specs->extension
+             ? specs->extension - 1 : specs->map_count))
+        ASN__DECODE_FAILED;
+    } else {
+        if(!specs->extension)
+            ASN__DECODE_FAILED;
+        /*
+         * X.691, #10.6: normally small non-negative whole number;
+         */
+
+        /* XXX handle indefinite index length > 64k */
+        value = aper_get_nsnnwn(pd);
+        if(value < 0) ASN__DECODE_STARVED;
+        value += specs->extension - 1;
+        //if(value >= specs->map_count)
+        //    ASN__DECODE_FAILED;
+        if(value >= specs->map_count) {
+            ASN_DEBUG("Decoded unknown index value %s = %ld", td->name, value);
+            /* unknown index. Workaround => set the first enumeration value */
+            *native = specs->value2enum[0].nat_value;
+            return rval;
+        }
+    }
+
+    *native = specs->value2enum[value].nat_value;
+    ASN_DEBUG("Decoded %s = %ld", td->name, *native);
+
+    return rval;
+}
+
+asn_enc_rval_t
+NativeEnumerated_encode_aper(const asn_TYPE_descriptor_t *td,
+                             const asn_per_constraints_t *constraints,
+                             const void *sptr, asn_per_outp_t *po) {
+    const asn_INTEGER_specifics_t *specs = (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    long native, value;
+    const asn_per_constraint_t *ct;
+    int inext = 0, range_bits = 1;
+    asn_INTEGER_enum_map_t key;
+    asn_INTEGER_enum_map_t *kf;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+    if(!specs) ASN__ENCODE_FAILED;
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->value;
+    else ASN__ENCODE_FAILED;  /* Mandatory! */
+
+    ASN_DEBUG("Encoding %s as NativeEnumerated", td->name);
+
+    er.encoded = 0;
+
+    native = *(const long *)sptr;
+    if(native < 0) ASN__ENCODE_FAILED;
+
+    key.nat_value = native;
+    kf = bsearch(&key, specs->value2enum, specs->map_count,
+                 sizeof(key), NativeEnumerated__compar_value2enum);
+    if(!kf) {
+        ASN_DEBUG("No element corresponds to %ld", native);
+        ASN__ENCODE_FAILED;
+    }
+    value = kf - specs->value2enum;
+
+    if(ct->range_bits >= 0) {
+        int cmpWith = specs->extension
+              ? specs->extension - 1 : specs->map_count;
+        if(value >= cmpWith)
+            inext = 1;
+    }
+    if(ct->flags & APC_EXTENSIBLE) {
+        if(per_put_few_bits(po, inext, 1))
+            ASN__ENCODE_FAILED;
+        if(inext) range_bits = 0;
+    } else if(inext) {
+        ASN__ENCODE_FAILED;
+    }
+
+    if(range_bits && ct && ct->range_bits >= 0) {
+        if(per_put_few_bits(po, value, ct->range_bits))
+            ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    }
+
+    if(!specs->extension)
+        ASN__ENCODE_FAILED;
+
+    /*
+     * X.691, #10.6: normally small non-negative whole number;
+     */
+    ASN_DEBUG("value = %ld, ext = %d, inext = %d, res = %ld",
+              value, specs->extension, inext,
+              value - (inext ? (specs->extension - 1) : 0));
+    if(aper_put_nsnnwn(po, value - (inext ? (specs->extension - 1) : 0)))
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_jer.c
new file mode 100644
index 000000000..23b4338ae
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_jer.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeEnumerated.h"
+
+/*
+ * Decode the chunk of JSON text encoding ENUMERATED.
+ */
+asn_dec_rval_t
+NativeEnumerated_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                         const asn_TYPE_descriptor_t *td,
+                         const asn_jer_constraints_t *constraints, void **sptr,
+                         const void *buf_ptr, size_t size) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval;
+    INTEGER_t st;
+    void *st_ptr = (void *)&st;
+    long *native = (long *)*sptr;
+
+    if(!native) {
+        native = (long *)(*sptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    memset(&st, 0, sizeof(st));
+    rval = ENUMERATED_decode_jer(opt_codec_ctx, td, constraints, &st_ptr, buf_ptr, size);
+    if(rval.code == RC_OK) {
+        long l;
+        if((specs&&specs->field_unsigned)
+            ? asn_INTEGER2ulong(&st, (unsigned long *)&l) /* sic */
+            : asn_INTEGER2long(&st, &l)) {
+            rval.code = RC_FAIL;
+            rval.consumed = 0;
+        } else {
+            *native = l;
+        }
+    } else {
+        /*
+         * Cannot restart from the middle;
+         * there is no place to save state in the native type.
+         * Request a continuation from the very beginning.
+         */
+        rval.consumed = 0;
+    }
+    ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &st);
+    return rval;
+}
+
+asn_enc_rval_t
+NativeEnumerated_encode_jer(const asn_TYPE_descriptor_t *td,
+                            const asn_jer_constraints_t *constraints,
+                            const void *sptr, int ilevel, enum jer_encoder_flags_e flags,
+                            asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    const long *native = (const long *)sptr;
+    const asn_INTEGER_enum_map_t *el;
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!native) ASN__ENCODE_FAILED;
+
+    el = INTEGER_map_value2enum(specs, *native);
+    if(el) {
+        er.encoded =
+            asn__format_to_callback(cb, app_key, "\"%s\"", el->enum_name);
+        if(er.encoded < 0) ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    } else {
+        ASN_DEBUG(
+            "ASN.1 forbids dealing with "
+            "unknown value of ENUMERATED type");
+        ASN__ENCODE_FAILED;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_oer.c
new file mode 100644
index 000000000..cda216577
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_oer.c
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeEnumerated.h"
+
+static long
+asn__nativeenumerated_convert(const uint8_t *b, const uint8_t *end) {
+    unsigned long value;
+
+    /* Perform the sign initialization */
+    /* Actually value = -(*b >> 7); gains nothing, yet unreadable! */
+    if((*b >> 7)) {
+        value = (unsigned long)(-1);
+    } else {
+        value = 0;
+    }
+
+    /* Conversion engine */
+    for(; b < end; b++) {
+        value = (value << 8) | *b;
+    }
+
+    return value;
+}
+
+asn_dec_rval_t
+NativeEnumerated_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                            const asn_TYPE_descriptor_t *td,
+                            const asn_oer_constraints_t *constraints,
+                            void **nint_ptr, const void *ptr, size_t size) {
+    asn_dec_rval_t rval = {RC_OK, 0};
+    long *native = (long *)*nint_ptr;
+    const uint8_t *b = ptr;
+
+    (void)opt_codec_ctx;
+    (void)constraints;
+
+    if(size < 1) {
+        ASN__DECODE_STARVED;
+    }
+
+    if((*b & 0x80) == 0) {
+        /*
+         * X.696 (08/2015) #11.2 Short form for Enumerated.
+         */
+        if(!native) {
+            native = (long *)(*nint_ptr = CALLOC(1, sizeof(*native)));
+            if(!native) ASN__DECODE_FAILED;
+        }
+
+        *native = *b;
+        rval.consumed = 1;
+    } else {
+        /*
+         * X.696 (08/2015) #11.4 Long form for Enumerated.
+         */
+        size_t length = *b & 0x7f;
+        const uint8_t *bend;
+        long value;
+
+        if(length < 1 || length > sizeof(*native)) {
+            ASN__DECODE_FAILED;
+        }
+        if((1 + length) > size) {
+            ASN__DECODE_STARVED;
+        }
+        b++;
+        bend = b + length;
+
+        value = asn__nativeenumerated_convert(b, bend);
+        if(value < 0) {
+            const asn_INTEGER_specifics_t *specs =
+                (const asn_INTEGER_specifics_t *)td->specifics;
+            if(specs && specs->field_unsigned) {
+                ASN__DECODE_FAILED;
+            }
+        }
+
+        if(!native) {
+            native = (long *)(*nint_ptr = CALLOC(1, sizeof(*native)));
+            if(!native) ASN__DECODE_FAILED;
+        }
+
+        *native = value;
+
+        rval.consumed = (1 + length);
+    }
+
+    return rval;
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+NativeEnumerated_encode_oer(const asn_TYPE_descriptor_t *td,
+                            const asn_oer_constraints_t *constraints,
+                            const void *sptr, asn_app_consume_bytes_f *cb,
+                            void *app_key) {
+    asn_enc_rval_t er = {0,0,0};
+    long native;
+
+    (void)constraints;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    native = *(const long *)sptr;
+
+    if(native >= 0 && native <= 127) {
+        /* #11.2 Short form */
+        uint8_t b = native;
+        er.encoded = 1;
+        if(cb(&b, er.encoded, app_key) < 0) {
+            ASN__ENCODE_FAILED;
+        }
+        ASN__ENCODED_OK(er);
+    } else {
+        /* #11.2 Long form */
+        uint8_t buf[1 + sizeof(native)];
+        uint8_t *b = &buf[sizeof(native)];  /* Last addressable */
+        long final_pattern = -1 * (native < 0);
+
+        for(;;) {
+            *b-- = native;
+            native >>= 8;
+            if(native == final_pattern) {
+                if(final_pattern) {
+                    if((b[1] & 0x80)) break;
+                } else {
+                    if(!(b[1] & 0x80)) break;
+                }
+            }
+        }
+        *b = 0x80 | (&buf[sizeof(native)] - b);
+        er.encoded = 1 + (&buf[sizeof(native)] - b);
+        if(cb(b, er.encoded, app_key) < 0) {
+            ASN__ENCODE_FAILED;
+        }
+        ASN__ENCODED_OK(er);
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_uper.c
new file mode 100644
index 000000000..c98a0f669
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_uper.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeEnumerated.h"
+
+asn_dec_rval_t
+NativeEnumerated_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                             const asn_TYPE_descriptor_t *td,
+                             const asn_per_constraints_t *constraints,
+                             void **sptr, asn_per_data_t *pd) {
+    const asn_INTEGER_specifics_t *specs = td->specifics;
+    asn_dec_rval_t rval = { RC_OK, 0 };
+    long *native = (long *)*sptr;
+    const asn_per_constraint_t *ct;
+    long value;
+
+    (void)opt_codec_ctx;
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->value;
+    else ASN__DECODE_FAILED;  /* Mandatory! */
+    if(!specs) ASN__DECODE_FAILED;
+
+    if(!native) {
+        native = (long *)(*sptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    ASN_DEBUG("Decoding %s as NativeEnumerated", td->name);
+
+    if(ct->flags & APC_EXTENSIBLE) {
+        int inext = per_get_few_bits(pd, 1);
+        if(inext < 0) ASN__DECODE_STARVED;
+        if(inext) ct = 0;
+    }
+
+    if(ct && ct->range_bits >= 0) {
+        value = per_get_few_bits(pd, ct->range_bits);
+        if(value < 0) ASN__DECODE_STARVED;
+        if(value >= (specs->extension
+            ? specs->extension - 1 : specs->map_count))
+            ASN__DECODE_FAILED;
+    } else {
+        if(!specs->extension)
+            ASN__DECODE_FAILED;
+        /*
+         * X.691, #10.6: normally small non-negative whole number;
+         */
+        value = uper_get_nsnnwn(pd);
+        if(value < 0) ASN__DECODE_STARVED;
+        value += specs->extension - 1;
+        if(value >= specs->map_count)
+            ASN__DECODE_FAILED;
+    }
+
+    *native = specs->value2enum[value].nat_value;
+    ASN_DEBUG("Decoded %s = %ld", td->name, *native);
+
+    return rval;
+}
+
+asn_enc_rval_t
+NativeEnumerated_encode_uper(const asn_TYPE_descriptor_t *td,
+                             const asn_per_constraints_t *constraints,
+                             const void *sptr, asn_per_outp_t *po) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    long native, value;
+    const asn_per_constraint_t *ct;
+    int inext = 0;
+    asn_INTEGER_enum_map_t key;
+    const asn_INTEGER_enum_map_t *kf;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+    if(!specs) ASN__ENCODE_FAILED;
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->value;
+    else ASN__ENCODE_FAILED;  /* Mandatory! */
+
+    ASN_DEBUG("Encoding %s as NativeEnumerated", td->name);
+
+    er.encoded = 0;
+
+    native = *(const long *)sptr;
+
+    key.nat_value = native;
+    kf = bsearch(&key, specs->value2enum, specs->map_count,
+        sizeof(key), NativeEnumerated__compar_value2enum);
+    if(!kf) {
+        ASN_DEBUG("No element corresponds to %ld", native);
+        ASN__ENCODE_FAILED;
+    }
+    value = kf - specs->value2enum;
+
+    if(ct->range_bits >= 0) {
+        int cmpWith = specs->extension
+            ? specs->extension - 1 : specs->map_count;
+        if(value >= cmpWith)
+            inext = 1;
+    }
+    if(ct->flags & APC_EXTENSIBLE) {
+        if(per_put_few_bits(po, inext, 1))
+            ASN__ENCODE_FAILED;
+        if(inext) ct = 0;
+    } else if(inext) {
+        ASN__ENCODE_FAILED;
+    }
+
+    if(ct && ct->range_bits >= 0) {
+        if(per_put_few_bits(po, value, ct->range_bits))
+            ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    }
+
+    if(!specs->extension)
+        ASN__ENCODE_FAILED;
+
+    /*
+     * X.691, #10.6: normally small non-negative whole number;
+     */
+    ASN_DEBUG("value = %ld, ext = %d, inext = %d, res = %ld",
+        value, specs->extension, inext,
+        value - (inext ? (specs->extension - 1) : 0));
+    if(uper_put_nsnnwn(po, value - (inext ? (specs->extension - 1) : 0)))
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_xer.c
new file mode 100644
index 000000000..ed9ded71a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeEnumerated_xer.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeEnumerated.h"
+
+asn_enc_rval_t
+NativeEnumerated_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                            int ilevel, enum xer_encoder_flags_e flags,
+                            asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    const long *native = (const long *)sptr;
+    const asn_INTEGER_enum_map_t *el;
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!native) ASN__ENCODE_FAILED;
+
+    el = INTEGER_map_value2enum(specs, *native);
+    if(el) {
+        er.encoded =
+            asn__format_to_callback(cb, app_key, "<%s/>", el->enum_name);
+        if(er.encoded < 0) ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    } else {
+        ASN_DEBUG(
+            "ASN.1 forbids dealing with "
+            "unknown value of ENUMERATED type");
+        ASN__ENCODE_FAILED;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger.c
new file mode 100644
index 000000000..9920a20d6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger.c
@@ -0,0 +1,185 @@
+/*-
+ * Copyright (c) 2004, 2005, 2006 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * Read the NativeInteger.h for the explanation wrt. differences between
+ * INTEGER and NativeInteger.
+ * Basically, both are decoders and encoders of ASN.1 INTEGER type, but this
+ * implementation deals with the standard (machine-specific) representation
+ * of them instead of using the platform-independent buffer.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+/*
+ * NativeInteger basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_NativeInteger_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
+};
+asn_TYPE_operation_t asn_OP_NativeInteger = {
+    NativeInteger_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    NativeInteger_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    NativeInteger_compare,
+    NativeInteger_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    NativeInteger_decode_ber,
+    NativeInteger_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    NativeInteger_decode_xer,
+    NativeInteger_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    NativeInteger_decode_jer,
+    NativeInteger_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    NativeInteger_decode_oer,  /* OER decoder */
+    NativeInteger_encode_oer,  /* Canonical OER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    NativeInteger_decode_uper,  /* Unaligned PER decoder */
+    NativeInteger_encode_uper,  /* Unaligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    NativeInteger_decode_aper,  /* Aligned PER decoder */
+    NativeInteger_encode_aper,  /* Aligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    NativeInteger_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_NativeInteger = {
+    "INTEGER",  /* The ASN.1 type is still INTEGER */
+    "INTEGER",
+    &asn_OP_NativeInteger,
+    asn_DEF_NativeInteger_tags,
+    sizeof(asn_DEF_NativeInteger_tags) / sizeof(asn_DEF_NativeInteger_tags[0]),
+    asn_DEF_NativeInteger_tags,  /* Same as above */
+    sizeof(asn_DEF_NativeInteger_tags) / sizeof(asn_DEF_NativeInteger_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_no_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
+
+void
+NativeInteger_free(const asn_TYPE_descriptor_t *td, void *ptr,
+                   enum asn_struct_free_method method) {
+    if(!td || !ptr)
+		return;
+
+	ASN_DEBUG("Freeing %s as INTEGER (%d, %p, Native)",
+		td->name, method, ptr);
+
+    switch(method) {
+    case ASFM_FREE_EVERYTHING:
+        FREEMEM(ptr);
+        break;
+    case ASFM_FREE_UNDERLYING:
+        break;
+    case ASFM_FREE_UNDERLYING_AND_RESET:
+        memset(ptr, 0, sizeof(long));
+        break;
+    }
+}
+
+int
+NativeInteger_compare(const asn_TYPE_descriptor_t *td, const void *aptr, const void *bptr) {
+    (void)td;
+
+    if(aptr && bptr) {
+        const asn_INTEGER_specifics_t *specs =
+            (const asn_INTEGER_specifics_t *)td->specifics;
+        if(specs && specs->field_unsigned) {
+            const unsigned long *a = aptr;
+            const unsigned long *b = bptr;
+            if(*a < *b) {
+                return -1;
+            } else if(*a > *b) {
+                return 1;
+            } else {
+                return 0;
+            }
+        } else {
+            const long *a = aptr;
+            const long *b = bptr;
+            if(*a < *b) {
+                return -1;
+            } else if(*a > *b) {
+                return 1;
+            } else {
+                return 0;
+            }
+        }
+    } else if(!aptr) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+int
+NativeInteger_copy(const asn_TYPE_descriptor_t *td, void **aptr, const void *bptr) {
+    unsigned long *a = *aptr;
+    const unsigned long *b = bptr;
+
+    (void)td;
+
+    /* Check if source has data */
+    if(!b) {
+        /* Clear destination */
+        if(a) {
+            FREEMEM(a);
+            *aptr = 0;
+        }
+        return 0;
+    }
+
+    if(!a) {
+        a = *aptr = MALLOC(sizeof(*a));
+        if(!a) return -1;
+    }
+
+    *a = *b;
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger.h /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger.h
new file mode 100644
index 000000000..4a98ea31a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger.h
@@ -0,0 +1,73 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * This type differs from the standard INTEGER in that it is modelled using
+ * the fixed machine type (long, int, short), so it can hold only values of
+ * limited length. There is no type (i.e., NativeInteger_t, any integer type
+ * will do).
+ * This type may be used when integer range is limited by subtype constraints.
+ */
+#ifndef	_NativeInteger_H_
+#define	_NativeInteger_H_
+
+#include "asn_application.h"
+#include "INTEGER.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern asn_TYPE_descriptor_t asn_DEF_NativeInteger;
+extern asn_TYPE_operation_t asn_OP_NativeInteger;
+
+asn_struct_free_f NativeInteger_free;
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f NativeInteger_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f NativeInteger_compare;
+asn_struct_copy_f    NativeInteger_copy;
+
+#define NativeInteger_constraint asn_generic_no_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+ber_type_decoder_f NativeInteger_decode_ber;
+der_type_encoder_f NativeInteger_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f NativeInteger_decode_xer;
+xer_type_encoder_f NativeInteger_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f NativeInteger_decode_jer;
+jer_type_encoder_f NativeInteger_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f NativeInteger_decode_oer;
+oer_type_encoder_f NativeInteger_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f NativeInteger_decode_uper;
+per_type_encoder_f NativeInteger_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f NativeInteger_decode_aper;
+per_type_encoder_f NativeInteger_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f NativeInteger_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _NativeInteger_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_aper.c
new file mode 100644
index 000000000..32924e25f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_aper.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+asn_dec_rval_t
+NativeInteger_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                          const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+
+    const asn_INTEGER_specifics_t *specs = (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval;
+    long *native = (long *)*sptr;
+    INTEGER_t tmpint;
+    void *tmpintptr = &tmpint;
+
+    (void)opt_codec_ctx;
+    ASN_DEBUG("Decoding NativeInteger %s (APER)", td->name);
+
+    if(!native) {
+        native = (long *)(*sptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    memset(&tmpint, 0, sizeof tmpint);
+    rval = INTEGER_decode_aper(opt_codec_ctx, td, constraints,
+                               &tmpintptr, pd);
+    if(rval.code == RC_OK) {
+        if((specs&&specs->field_unsigned)
+                ? asn_INTEGER2ulong(&tmpint, (unsigned long *)native)
+                : asn_INTEGER2long(&tmpint, native))
+            rval.code = RC_FAIL;
+        else
+            ASN_DEBUG("NativeInteger %s got value %ld",
+                      td->name, *native);
+    }
+    ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+
+    return rval;
+}
+
+asn_enc_rval_t
+NativeInteger_encode_aper(const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints,
+                          const void *sptr, asn_per_outp_t *po) {
+
+    const asn_INTEGER_specifics_t *specs = (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    long native;
+    INTEGER_t tmpint;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    native = *(const long *)sptr;
+
+    ASN_DEBUG("Encoding NativeInteger %s %ld (APER)", td->name, native);
+
+    memset(&tmpint, 0, sizeof(tmpint));
+    if((specs&&specs->field_unsigned)
+            ? asn_ulong2INTEGER(&tmpint, (unsigned long)native)
+            : asn_long2INTEGER(&tmpint, native))
+        ASN__ENCODE_FAILED;
+    er = INTEGER_encode_aper(td, constraints, &tmpint, po);
+    ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+    return er;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_ber.c
new file mode 100644
index 000000000..b8674f91c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_ber.c
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+#include "INTEGER.h"
+
+/*
+ * Decode INTEGER type.
+ */
+asn_dec_rval_t
+NativeInteger_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,
+                         const asn_TYPE_descriptor_t *td, void **nint_ptr,
+                         const void *buf_ptr, size_t size, int tag_mode) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    long *native = (long *)*nint_ptr;
+    asn_dec_rval_t rval;
+    ber_tlv_len_t length;
+
+    /*
+     * If the structure is not there, allocate it.
+     */
+    if(native == NULL) {
+        native = (long *)(*nint_ptr = CALLOC(1, sizeof(*native)));
+        if(native == NULL) {
+            rval.code = RC_FAIL;
+            rval.consumed = 0;
+            return rval;
+        }
+    }
+
+    ASN_DEBUG("Decoding %s as INTEGER (tm=%d)",
+              td->name, tag_mode);
+
+    /*
+     * Check tags.
+     */
+    rval = ber_check_tags(opt_codec_ctx, td, 0, buf_ptr, size,
+                          tag_mode, 0, &length, 0);
+    if(rval.code != RC_OK)
+        return rval;
+
+    ASN_DEBUG("%s length is %d bytes", td->name, (int)length);
+
+    /*
+     * Make sure we have this length.
+     */
+    buf_ptr = ((const char *)buf_ptr) + rval.consumed;
+    size -= rval.consumed;
+    if(length > (ber_tlv_len_t)size) {
+        rval.code = RC_WMORE;
+        rval.consumed = 0;
+        return rval;
+    }
+
+    /*
+     * ASN.1 encoded INTEGER: buf_ptr, length
+     * Fill the native, at the same time checking for overflow.
+     * If overflow occurred, return with RC_FAIL.
+     */
+    {
+        INTEGER_t tmp;
+        union {
+            const void *constbuf;
+            void *nonconstbuf;
+        } unconst_buf;
+        long l;
+
+        unconst_buf.constbuf = buf_ptr;
+        tmp.buf = (uint8_t *)unconst_buf.nonconstbuf;
+        tmp.size = length;
+
+        if((specs&&specs->field_unsigned)
+            ? asn_INTEGER2ulong(&tmp, (unsigned long *)&l) /* sic */
+            : asn_INTEGER2long(&tmp, &l)) {
+            rval.code = RC_FAIL;
+            rval.consumed = 0;
+            return rval;
+        }
+
+        *native = l;
+    }
+
+    rval.code = RC_OK;
+    rval.consumed += length;
+
+    ASN_DEBUG("Took %ld/%ld bytes to encode %s (%ld)",
+              (long)rval.consumed, (long)length, td->name, (long)*native);
+
+    return rval;
+}
+
+/*
+ * Encode the NativeInteger using the standard INTEGER type DER encoder.
+ */
+asn_enc_rval_t
+NativeInteger_encode_der(const asn_TYPE_descriptor_t *sd, const void *ptr,
+                         int tag_mode, ber_tlv_tag_t tag,
+                         asn_app_consume_bytes_f *cb, void *app_key) {
+    unsigned long native = *(const unsigned long *)ptr; /* Disable sign ext. */
+    asn_enc_rval_t erval = {0,0,0};
+    INTEGER_t tmp;
+
+#ifdef WORDS_BIGENDIAN  /* Opportunistic optimization */
+
+    tmp.buf = (uint8_t *)&native;
+    tmp.size = sizeof(native);
+
+#else  /* Works even if WORDS_BIGENDIAN is not set where should've been */
+    uint8_t buf[sizeof(native)];
+    uint8_t *p;
+
+    /* Prepare a fake INTEGER */
+    for(p = buf + sizeof(buf) - 1; p >= buf; p--, native >>= 8)
+        *p = (uint8_t)native;
+
+    tmp.buf = buf;
+    tmp.size = sizeof(buf);
+#endif  /* WORDS_BIGENDIAN */
+
+    /* Encode fake INTEGER */
+    erval = INTEGER_encode_der(sd, &tmp, tag_mode, tag, cb, app_key);
+    if(erval.structure_ptr == &tmp) {
+        erval.structure_ptr = ptr;
+    }
+    return erval;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_jer.c
new file mode 100644
index 000000000..999b93e0d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_jer.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+/*
+ * Decode the chunk of JSON text encoding INTEGER.
+ */
+asn_dec_rval_t
+NativeInteger_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                         const asn_TYPE_descriptor_t *td,
+                         const asn_jer_constraints_t* constraints,
+                         void **sptr, const void *buf_ptr,
+                         size_t size) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval;
+    INTEGER_t st;
+    void *st_ptr = (void *)&st;
+    long *native = (long *)*sptr;
+
+    if(!native) {
+        native = (long *)(*sptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    memset(&st, 0, sizeof(st));
+    rval = INTEGER_decode_jer(opt_codec_ctx, td, constraints, &st_ptr, buf_ptr, size);
+    if(rval.code == RC_OK) {
+        long l;
+        if((specs&&specs->field_unsigned)
+            ? asn_INTEGER2ulong(&st, (unsigned long *)&l) /* sic */
+            : asn_INTEGER2long(&st, &l)) {
+            rval.code = RC_FAIL;
+            rval.consumed = 0;
+        } else {
+            *native = l;
+        }
+    } else {
+        /*
+         * Cannot restart from the middle;
+         * there is no place to save state in the native type.
+         * Request a continuation from the very beginning.
+         */
+        rval.consumed = 0;
+    }
+    ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &st);
+    return rval;
+}
+
+asn_enc_rval_t
+NativeInteger_encode_jer(const asn_TYPE_descriptor_t *td,
+                         const asn_jer_constraints_t* constraints,
+                         const void *sptr, int ilevel,
+                         enum jer_encoder_flags_e flags,
+                         asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    char scratch[32];  /* Enough for 64-bit int */
+    asn_enc_rval_t er = {0,0,0};
+    const long *native = (const long *)sptr;
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!native) ASN__ENCODE_FAILED;
+
+    er.encoded = snprintf(scratch, sizeof(scratch),
+                          (specs && specs->field_unsigned)
+                              ? "%lu" : "%ld", *native);
+    if(er.encoded <= 0 || (size_t)er.encoded >= sizeof(scratch)
+        || cb(scratch, er.encoded, app_key) < 0)
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_oer.c
new file mode 100644
index 000000000..3332eeec3
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_oer.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+asn_dec_rval_t
+NativeInteger_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                         const asn_TYPE_descriptor_t *td,
+                         const asn_oer_constraints_t *constraints,
+                         void **nint_ptr, const void *ptr, size_t size) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval = {RC_OK, 0};
+    long *native = (long *)*nint_ptr;
+    INTEGER_t tmpint;
+    INTEGER_t *tmpintptr = &tmpint;
+
+    memset(&tmpint, 0, sizeof(tmpint));
+
+    if(!native) {
+        native = (long *)(*nint_ptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    /*
+     * OPTIMIZATION: Encode directly rather than passing through INTEGER.
+     * Saves a memory allocation.
+     */
+    rval = INTEGER_decode_oer(opt_codec_ctx, td, constraints,
+                              (void **)&tmpintptr, ptr, size);
+    if(rval.code != RC_OK) {
+        ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+        return rval;
+    }
+
+    if(specs && specs->field_unsigned) {
+        unsigned long ul;
+        int ok = asn_INTEGER2ulong(&tmpint, &ul) == 0;
+        ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+        if(ok) {
+            *native = ul;
+        } else {
+            rval.code = RC_FAIL;
+            return rval;
+        }
+    } else {
+        long l;
+        int ok = asn_INTEGER2long(&tmpint, &l) == 0;
+        ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+        if(ok) {
+            *native = l;
+        } else {
+            rval.code = RC_FAIL;
+            return rval;
+        }
+    }
+
+    return rval;
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+NativeInteger_encode_oer(const asn_TYPE_descriptor_t *td,
+                         const asn_oer_constraints_t *constraints,
+                         const void *sptr, asn_app_consume_bytes_f *cb,
+                         void *app_key) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    INTEGER_t tmpint;
+    long native;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    native = *(const long *)sptr;
+    memset(&tmpint, 0, sizeof(tmpint));
+
+    ASN_DEBUG("Encoding %s %ld as NativeInteger", td ? td->name : "", native);
+
+    if((specs && specs->field_unsigned) ? asn_ulong2INTEGER(&tmpint, native)
+                                        : asn_long2INTEGER(&tmpint, native)) {
+        ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+        ASN__ENCODE_FAILED;
+    } else {
+        asn_enc_rval_t er =
+            INTEGER_encode_oer(td, constraints, &tmpint, cb, app_key);
+        ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+        return er;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_print.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_print.c
new file mode 100644
index 000000000..c939c7384
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_print.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+/*
+ * INTEGER specific human-readable output.
+ */
+int
+NativeInteger_print(const asn_TYPE_descriptor_t *td, const void *sptr,
+                    int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    const long *native = (const long *)sptr;
+    char scratch[32];  /* Enough for 64-bit int */
+    int ret;
+
+    (void)td;      /* Unused argument */
+    (void)ilevel;  /* Unused argument */
+
+    if(native) {
+        long value = *native;
+        ret = snprintf(scratch, sizeof(scratch),
+                       (specs && specs->field_unsigned) ? "%lu" : "%ld", value);
+        assert(ret > 0 && (size_t)ret < sizeof(scratch));
+        if(cb(scratch, ret, app_key) < 0) return -1;
+        if(specs && (value >= 0 || !specs->field_unsigned)) {
+            const asn_INTEGER_enum_map_t *el =
+                INTEGER_map_value2enum(specs, value);
+            if(el) {
+                if(cb(" (", 2, app_key) < 0) return -1;
+                if(cb(el->enum_name, el->enum_len, app_key) < 0) return -1;
+                if(cb(")", 1, app_key) < 0) return -1;
+            }
+        }
+        return 0;
+    } else {
+        return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_rfill.c
new file mode 100644
index 000000000..cd8623a25
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_rfill.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+asn_random_fill_result_t
+NativeInteger_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                          const asn_encoding_constraints_t *constraints,
+                          size_t max_length) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    long *st = *sptr;
+    const asn_INTEGER_enum_map_t *emap;
+    size_t emap_len;
+    intmax_t value;
+    int find_inside_map;
+
+    if(max_length == 0) return result_skipped;
+
+    if(st == NULL) {
+        st = (long *)CALLOC(1, sizeof(*st));
+        if(st == NULL) {
+            return result_failed;
+        }
+    }
+
+    if(specs) {
+        emap = specs->value2enum;
+        emap_len = specs->map_count;
+        if(specs->strict_enumeration) {
+            find_inside_map = emap_len > 0;
+        } else {
+            find_inside_map = emap_len ? asn_random_between(0, 1) : 0;
+        }
+    } else {
+        emap = 0;
+        emap_len = 0;
+        find_inside_map = 0;
+    }
+
+    if(find_inside_map) {
+        assert(emap_len > 0);
+        value = emap[asn_random_between(0, emap_len - 1)].nat_value;
+    } else {
+        static const long variants[] = {
+            -65536, -65535, -65534, -32769, -32768, -32767, -16385, -16384,
+            -16383, -257,   -256,   -255,   -254,   -129,   -128,   -127,
+            -126,   -1,     0,      1,      126,    127,    128,    129,
+            254,    255,    256,    257,    16383,  16384,  16385,  32767,
+            32768,  32769,  65534,  65535,  65536,  65537};
+        if(specs && specs->field_unsigned) {
+            assert(variants[18] == 0);
+            value = variants[asn_random_between(
+                18, sizeof(variants) / sizeof(variants[0]) - 1)];
+        } else {
+            value = variants[asn_random_between(
+                0, sizeof(variants) / sizeof(variants[0]) - 1)];
+        }
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        if(!constraints || !constraints->per_constraints) 
+            constraints = &td->encoding_constraints;
+      
+        const asn_per_constraints_t *ct;
+
+        ct = constraints ? constraints->per_constraints : 0;
+        if(ct && (ct->value.flags & APC_CONSTRAINED)) {
+            if(value < ct->value.lower_bound || value > ct->value.upper_bound) {
+                value = asn_random_between(ct->value.lower_bound,
+                                           ct->value.upper_bound);
+            }
+        }
+#else
+      if(!constraints) constraints = &td->encoding_constraints;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+    }
+
+    *sptr = st;
+    *st = value;
+    return result_ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_uper.c
new file mode 100644
index 000000000..bd3eb0776
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_uper.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+asn_dec_rval_t
+NativeInteger_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                          const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints, void **sptr,
+                          asn_per_data_t *pd) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval;
+    long *native = (long *)*sptr;
+    INTEGER_t tmpint;
+    void *tmpintptr = &tmpint;
+
+    (void)opt_codec_ctx;
+    ASN_DEBUG("Decoding NativeInteger %s (UPER)", td->name);
+
+    if(!native) {
+        native = (long *)(*sptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    memset(&tmpint, 0, sizeof tmpint);
+    rval = INTEGER_decode_uper(opt_codec_ctx, td, constraints,
+                               &tmpintptr, pd);
+    if(rval.code == RC_OK) {
+        if((specs&&specs->field_unsigned)
+            ? asn_INTEGER2ulong(&tmpint, (unsigned long *)native)
+            : asn_INTEGER2long(&tmpint, native))
+            rval.code = RC_FAIL;
+        else
+            ASN_DEBUG("NativeInteger %s got value %ld",
+                      td->name, *native);
+    }
+    ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+
+    return rval;
+}
+
+asn_enc_rval_t
+NativeInteger_encode_uper(const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints,
+                          const void *sptr, asn_per_outp_t *po) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    long native;
+    INTEGER_t tmpint;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    native = *(const long *)sptr;
+
+    ASN_DEBUG("Encoding NativeInteger %s %ld (UPER)", td->name, native);
+
+    memset(&tmpint, 0, sizeof(tmpint));
+    if((specs&&specs->field_unsigned)
+        ? asn_ulong2INTEGER(&tmpint, native)
+        : asn_long2INTEGER(&tmpint, native))
+        ASN__ENCODE_FAILED;
+    er = INTEGER_encode_uper(td, constraints, &tmpint, po);
+    ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &tmpint);
+    return er;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_xer.c
new file mode 100644
index 000000000..b79148144
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/NativeInteger_xer.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "NativeInteger.h"
+
+/*
+ * Decode the chunk of XML text encoding INTEGER.
+ */
+asn_dec_rval_t
+NativeInteger_decode_xer(const asn_codec_ctx_t *opt_codec_ctx,
+                         const asn_TYPE_descriptor_t *td, void **sptr,
+                         const char *opt_mname, const void *buf_ptr,
+                         size_t size) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    asn_dec_rval_t rval;
+    INTEGER_t st;
+    void *st_ptr = (void *)&st;
+    long *native = (long *)*sptr;
+
+    if(!native) {
+        native = (long *)(*sptr = CALLOC(1, sizeof(*native)));
+        if(!native) ASN__DECODE_FAILED;
+    }
+
+    memset(&st, 0, sizeof(st));
+    rval = INTEGER_decode_xer(opt_codec_ctx, td, &st_ptr,
+                              opt_mname, buf_ptr, size);
+    if(rval.code == RC_OK) {
+        long l;
+        if((specs&&specs->field_unsigned)
+            ? asn_INTEGER2ulong(&st, (unsigned long *)&l) /* sic */
+            : asn_INTEGER2long(&st, &l)) {
+            rval.code = RC_FAIL;
+            rval.consumed = 0;
+        } else {
+            *native = l;
+        }
+    } else {
+        /*
+         * Cannot restart from the middle;
+         * there is no place to save state in the native type.
+         * Request a continuation from the very beginning.
+         */
+        rval.consumed = 0;
+    }
+    ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &st);
+    return rval;
+}
+
+
+asn_enc_rval_t
+NativeInteger_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                         int ilevel, enum xer_encoder_flags_e flags,
+                         asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_INTEGER_specifics_t *specs =
+        (const asn_INTEGER_specifics_t *)td->specifics;
+    char scratch[32];  /* Enough for 64-bit int */
+    asn_enc_rval_t er = {0,0,0};
+    const long *native = (const long *)sptr;
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!native) ASN__ENCODE_FAILED;
+
+    er.encoded = snprintf(scratch, sizeof(scratch),
+                          (specs && specs->field_unsigned)
+                              ? "%lu" : "%ld", *native);
+    if(er.encoded <= 0 || (size_t)er.encoded >= sizeof(scratch)
+        || cb(scratch, er.encoded, app_key) < 0)
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER.c /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER.c
new file mode 100644
index 000000000..645f82751
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER.c
@@ -0,0 +1,538 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "INTEGER.h"
+#include "OBJECT_IDENTIFIER.h"
+#include "asn_codecs_prim.h"
+#include <limits.h>	/* for CHAR_BIT */
+#include <errno.h>
+#include <inttypes.h>
+
+/*
+ * OBJECT IDENTIFIER basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_OBJECT_IDENTIFIER_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (6 << 2))
+};
+asn_TYPE_operation_t asn_OP_OBJECT_IDENTIFIER = {
+    ASN__PRIMITIVE_TYPE_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    OBJECT_IDENTIFIER_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    OCTET_STRING_compare,   /* Implemented in terms of a string comparison */
+    OCTET_STRING_copy,      /* Implemented in terms of a string copy */
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    ber_decode_primitive,
+    der_encode_primitive,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OBJECT_IDENTIFIER_decode_xer,
+    OBJECT_IDENTIFIER_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    OBJECT_IDENTIFIER_decode_jer,
+    OBJECT_IDENTIFIER_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    OBJECT_IDENTIFIER_decode_oer,
+    OBJECT_IDENTIFIER_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    OCTET_STRING_decode_uper,
+    OCTET_STRING_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    OCTET_STRING_decode_aper,
+    OCTET_STRING_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    OBJECT_IDENTIFIER_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_OBJECT_IDENTIFIER = {
+    "OBJECT IDENTIFIER",
+    "OBJECT_IDENTIFIER",
+    &asn_OP_OBJECT_IDENTIFIER,
+    asn_DEF_OBJECT_IDENTIFIER_tags,
+    sizeof(asn_DEF_OBJECT_IDENTIFIER_tags)
+        / sizeof(asn_DEF_OBJECT_IDENTIFIER_tags[0]),
+    asn_DEF_OBJECT_IDENTIFIER_tags,  /* Same as above */
+    sizeof(asn_DEF_OBJECT_IDENTIFIER_tags)
+        / sizeof(asn_DEF_OBJECT_IDENTIFIER_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        OBJECT_IDENTIFIER_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
+
+int
+OBJECT_IDENTIFIER_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
+                             asn_app_constraint_failed_f *ctfailcb,
+                             void *app_key) {
+    const OBJECT_IDENTIFIER_t *st = (const OBJECT_IDENTIFIER_t *)sptr;
+
+	if(st && st->buf) {
+		if(st->size < 1) {
+			ASN__CTFAIL(app_key, td, sptr,
+				"%s: at least one numerical value "
+				"expected (%s:%d)",
+				td->name, __FILE__, __LINE__);
+			return -1;
+		}
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static ssize_t
+OBJECT_IDENTIFIER_get_first_arcs(const uint8_t *arcbuf, size_t arcbuf_len,
+                                 asn_oid_arc_t *arc0, asn_oid_arc_t *arc1) {
+    asn_oid_arc_t value;
+
+    ssize_t rd = OBJECT_IDENTIFIER_get_single_arc(arcbuf, arcbuf_len, &value);
+    if(rd <= 0) return rd;
+
+    if(value >= 80) {
+        *arc0 = 2;
+        *arc1 = value - 80;
+    } else if(value >= 40) {
+        *arc0 = 1;
+        *arc1 = value - 40;
+    } else {
+        *arc0 = 0;
+        *arc1 = value;
+    }
+
+    return rd;
+}
+
+ssize_t
+OBJECT_IDENTIFIER_get_single_arc(const uint8_t *arcbuf, size_t arcbuf_len,
+                                 asn_oid_arc_t *ret_value) {
+    const uint8_t *b = arcbuf;
+    const uint8_t *arcend = arcbuf + arcbuf_len; /* End of arc */
+
+    if(arcbuf == arcend) {
+        return 0;
+    } else {
+        asn_oid_arc_t accum;
+	asn_oid_arc_t upper_limit = (ASN_OID_ARC_MAX >> 7);
+	/* When the value reaches "upper_limit", it can take */
+	/* at most one more digit. If it exceeds "upper_limit" */
+	/* but there are more digits - it's an Overflow condition */
+        /* Gather all bits into the accumulator */
+        for(accum = 0; b < arcend; b++) {
+            accum = (accum << 7) | (*b & ~0x80);
+            if((*b & 0x80) == 0) { // no more digits
+                if(accum <= ASN_OID_ARC_MAX) {
+                    *ret_value = accum;
+                    return 1 + (b - arcbuf);
+                } else {
+                    errno = ERANGE; /* Overflow */
+                    return -1;
+                }
+            } else { // to make sure we aren't wrapping around
+	      if(accum > upper_limit) {
+		    errno = ERANGE; /* Overflow */
+		    return -1;
+	      }
+	    }
+        }
+        errno = EINVAL;
+        return -1;
+    }
+
+}
+
+ssize_t
+OBJECT_IDENTIFIER__dump_body(const OBJECT_IDENTIFIER_t *st,
+                             asn_app_consume_bytes_f *cb, void *app_key) {
+    char scratch[32];
+    asn_oid_arc_t arc0 = 0;
+    asn_oid_arc_t arc1 = 0;
+    size_t produced = 0;
+    size_t off = 0;
+    ssize_t rd;
+    int ret;
+
+    rd = OBJECT_IDENTIFIER_get_first_arcs(st->buf, st->size, &arc0, &arc1);
+    if(rd <= 0) {
+        return -1;
+    }
+
+    ret = snprintf(scratch, sizeof(scratch), "%"PRIu32".%"PRIu32, arc0, arc1);
+    if(ret >= (ssize_t)sizeof(scratch)) {
+        return -1;
+    }
+    produced += ret;
+    if(cb(scratch, ret, app_key) < 0)
+        return -1;
+
+    for(off = rd; ; ) {
+        asn_oid_arc_t arc;
+        rd = OBJECT_IDENTIFIER_get_single_arc(st->buf + off, st->size - off,
+                                              &arc);
+        if(rd < 0) {
+            return -1;
+        } else if(rd == 0) {
+            /* No more arcs. */
+            break;
+        } else {
+            off += rd;
+            assert(off <= st->size);
+            ret = snprintf(scratch, sizeof(scratch), ".%" PRIu32, arc);
+            if(ret >= (ssize_t)sizeof(scratch)) {
+                return -1;
+            }
+            produced += ret;
+            if(cb(scratch, ret, app_key) < 0) return -1;
+        }
+    }
+
+    if(off != st->size) {
+        ASN_DEBUG("Could not scan to the end of Object Identifier");
+        return -1;
+    }
+
+	return produced;
+}
+
+ssize_t
+OBJECT_IDENTIFIER_get_arcs(const OBJECT_IDENTIFIER_t *st, asn_oid_arc_t *arcs,
+                           size_t arc_slots) {
+    asn_oid_arc_t arc0 = 0;
+    asn_oid_arc_t arc1 = 0;
+    size_t num_arcs = 0;
+    size_t off;
+    ssize_t rd;
+
+    if(!st || !st->buf) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    rd = OBJECT_IDENTIFIER_get_first_arcs(st->buf, st->size, &arc0, &arc1);
+    if(rd <= 0) {
+        return -1;
+    }
+    num_arcs = 2;
+    switch(arc_slots) {
+    default:
+    case 2:
+        arcs[1] = arc1;
+        /* Fall through */
+    case 1:
+        arcs[0] = arc0;
+        /* Fall through */
+    case 0:
+        break;
+    }
+
+    for(off = rd; ; ) {
+        asn_oid_arc_t arc;
+        rd = OBJECT_IDENTIFIER_get_single_arc(st->buf + off, st->size - off,
+                                              &arc);
+        if(rd < 0) {
+            return -1;
+        } else if(rd == 0) {
+            /* No more arcs. */
+            break;
+        } else {
+            off += rd;
+            if(num_arcs < arc_slots) {
+                arcs[num_arcs] = arc;
+            }
+            num_arcs++;
+        }
+    }
+
+    if(off != st->size) {
+        return -1;
+    }
+
+    return num_arcs;
+}
+
+
+/*
+ * Save the single value as an object identifier arc.
+ */
+ssize_t
+OBJECT_IDENTIFIER_set_single_arc(uint8_t *arcbuf, size_t arcbuf_len,
+                                 asn_oid_arc_t value) {
+    /*
+	 * The following conditions must hold:
+	 * assert(arcbuf);
+	 */
+    uint8_t scratch[((sizeof(value) * CHAR_BIT + 6) / 7)];
+    uint8_t *scratch_end = &scratch[sizeof(scratch)-1];
+    uint8_t *b;
+    size_t result_len;
+    uint8_t mask;
+
+    for(b = scratch_end, mask = 0; ; mask = 0x80, b--) {
+        *b = mask | (value & 0x7f);
+        value >>= 7;
+        if(!value) {
+            break;
+        }
+    }
+
+    result_len = (scratch_end - b) + 1;
+
+    if(result_len > arcbuf_len) {
+        return -1;
+    }
+
+    memcpy(arcbuf, b, result_len);
+
+	return result_len;
+}
+
+int
+OBJECT_IDENTIFIER_set_arcs(OBJECT_IDENTIFIER_t *st, const asn_oid_arc_t *arcs,
+                           size_t arc_slots) {
+    uint8_t *buf;
+    uint8_t *bp;
+    ssize_t wrote;
+    asn_oid_arc_t arc0;
+    asn_oid_arc_t arc1;
+    size_t size;
+    size_t i;
+
+    if(!st || !arcs || arc_slots < 2) {
+        errno = EINVAL;
+		return -1;
+	}
+
+    arc0 = arcs[0];
+    arc1 = arcs[1];
+
+	if(arc0 <= 1) {
+		if(arc1 >= 40) {
+			/* 8.19.4: At most 39 subsequent values (including 0) */
+			errno = ERANGE;
+			return -1;
+		}
+    } else if(arc0 == 2) {
+        if(arc1 > ASN_OID_ARC_MAX - 80) {
+            errno = ERANGE;
+            return -1;
+        }
+    } else if(arc0 > 2) {
+        /* 8.19.4: Only three values are allocated from the root node */
+        errno = ERANGE;
+        return -1;
+    }
+
+    /*
+	 * After above tests it is known that the value of arc0 is completely
+	 * trustworthy (0..2). However, the arc1's value is still meaningless.
+	 */
+
+    /*
+     * Roughly estimate the maximum size necessary to encode these arcs.
+     * This estimation implicitly takes in account the following facts,
+     * that cancel each other:
+     * 	* the first two arcs are encoded in a single value.
+     * 	* the first value may require more space (+1 byte)
+     * 	* the value of the first arc which is in range (0..2)
+     */
+    size = ((sizeof(asn_oid_arc_t) * CHAR_BIT + 6) / 7) * arc_slots;
+    bp = buf = (uint8_t *)MALLOC(size + 1);
+    if(!buf) {
+        /* ENOMEM */
+        return -1;
+    }
+
+    wrote = OBJECT_IDENTIFIER_set_single_arc(bp, size, arc0 * 40 + arc1);
+    if(wrote <= 0) {
+        FREEMEM(buf);
+        return -1;
+    }
+    assert((size_t)wrote <= size);
+    bp += wrote;
+    size -= wrote;
+
+    for(i = 2; i < arc_slots; i++) {
+		wrote = OBJECT_IDENTIFIER_set_single_arc(bp, size, arcs[i]);
+        if(wrote <= 0) {
+            FREEMEM(buf);
+            return -1;
+        }
+        assert((size_t)wrote <= size);
+        bp += wrote;
+        size -= wrote;
+    }
+
+    /*
+	 * Replace buffer.
+	 */
+	st->size = bp - buf;
+	bp = st->buf;
+	st->buf = buf;
+	st->buf[st->size] = '\0';
+	if(bp) FREEMEM(bp);
+
+	return 0;
+}
+
+ssize_t
+OBJECT_IDENTIFIER_parse_arcs(const char *oid_text, ssize_t oid_txt_length,
+                             asn_oid_arc_t *arcs, size_t arcs_count,
+                             const char **opt_oid_text_end) {
+    size_t num_arcs = 0;
+    const char *oid_end;
+	enum {
+		ST_LEADSPACE,
+		ST_TAILSPACE,
+		ST_AFTERVALUE,	/* Next character ought to be '.' or a space */
+		ST_WAITDIGITS 	/* Next character is expected to be a digit */
+	} state = ST_LEADSPACE;
+
+	if(!oid_text || oid_txt_length < -1 || (arcs_count && !arcs)) {
+		if(opt_oid_text_end) *opt_oid_text_end = oid_text;
+		errno = EINVAL;
+		return -1;
+	}
+
+	if(oid_txt_length == -1)
+		oid_txt_length = strlen(oid_text);
+
+#define _OID_CAPTURE_ARC(oid_text, oid_end)                       \
+    do {                                                          \
+        const char *endp = oid_end;                               \
+        unsigned long value;                                      \
+        switch(asn_strtoul_lim(oid_text, &endp, &value)) {        \
+        case ASN_STRTOX_EXTRA_DATA:                               \
+        case ASN_STRTOX_OK:                                       \
+            if(value <= ASN_OID_ARC_MAX) {                        \
+                if(num_arcs < arcs_count) arcs[num_arcs] = value; \
+                num_arcs++;                                       \
+                oid_text = endp - 1;                              \
+                break;                                            \
+            }                                                     \
+            /* Fall through */                                    \
+        case ASN_STRTOX_ERROR_RANGE:                              \
+            if(opt_oid_text_end) *opt_oid_text_end = oid_text;    \
+            errno = ERANGE;                                       \
+            return -1;                                            \
+        case ASN_STRTOX_ERROR_INVAL:                              \
+        case ASN_STRTOX_EXPECT_MORE:                              \
+            if(opt_oid_text_end) *opt_oid_text_end = oid_text;    \
+            errno = EINVAL;                                       \
+            return -1;                                            \
+        }                                                         \
+    } while(0)
+
+    for(oid_end = oid_text + oid_txt_length; oid_text<oid_end; oid_text++) {
+	    switch(*oid_text) {
+	    case 0x09: case 0x0a: case 0x0d: case 0x20:	/* whitespace */
+		switch(state) {
+		case ST_LEADSPACE:
+		case ST_TAILSPACE:
+			continue;
+		case ST_AFTERVALUE:
+			state = ST_TAILSPACE;
+			continue;
+		case ST_WAITDIGITS:
+			break;	/* Digits expected after ".", got whitespace */
+		}
+		break;
+	    case 0x2e:	/* '.' */
+		switch(state) {
+		case ST_LEADSPACE:
+		case ST_TAILSPACE:
+		case ST_WAITDIGITS:
+			if(opt_oid_text_end)
+				*opt_oid_text_end = oid_text;
+			errno = EINVAL;	/* Broken OID */
+			return -1;
+			break;
+		case ST_AFTERVALUE:
+			state = ST_WAITDIGITS;
+			continue;
+		}
+		break;
+	    case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:
+	    case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:
+		switch(state) {
+		case ST_TAILSPACE:
+		case ST_AFTERVALUE:
+			if(opt_oid_text_end)
+				*opt_oid_text_end = oid_text;
+			errno = EINVAL;	/* "1. 1" => broken OID */
+			return -1;
+		case ST_LEADSPACE:
+		case ST_WAITDIGITS:
+			_OID_CAPTURE_ARC(oid_text, oid_end);
+			state = ST_AFTERVALUE;
+			continue;
+		}
+		break;
+	    default:
+		/* Unexpected symbols */
+		state = ST_WAITDIGITS;
+		break;
+	    } /* switch() */
+	    break;
+	} /* for() */
+
+
+	if(opt_oid_text_end) *opt_oid_text_end = oid_text;
+
+	/* Finalize last arc */
+	switch(state) {
+	case ST_LEADSPACE:
+		return 0; /* No OID found in input data */
+	case ST_WAITDIGITS:
+		errno = EINVAL;	/* Broken OID */
+		return -1;
+	case ST_AFTERVALUE:
+	case ST_TAILSPACE:
+		return num_arcs;
+	}
+
+	errno = EINVAL;	/* Broken OID */
+	return -1;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER.h /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER.h
new file mode 100644
index 000000000..54a94fbb0
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_OBJECT_IDENTIFIER_H_
+#define	_OBJECT_IDENTIFIER_H_
+
+#include "asn_application.h"
+#include "asn_codecs_prim.h"
+#include "OCTET_STRING.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef uint32_t asn_oid_arc_t;
+#define ASN_OID_ARC_MAX (~((asn_oid_arc_t)0))
+
+typedef ASN__PRIMITIVE_TYPE_t OBJECT_IDENTIFIER_t;
+
+extern asn_TYPE_descriptor_t asn_DEF_OBJECT_IDENTIFIER;
+extern asn_TYPE_operation_t asn_OP_OBJECT_IDENTIFIER;
+
+ssize_t OBJECT_IDENTIFIER__dump_body(const OBJECT_IDENTIFIER_t *st,
+                                     asn_app_consume_bytes_f *cb,
+                                     void *app_key);
+
+#define OBJECT_IDENTIFIER_free ASN__PRIMITIVE_TYPE_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f OBJECT_IDENTIFIER_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define OBJECT_IDENTIFIER_compare OCTET_STRING_compare
+#define OBJECT_IDENTIFIER_copy    OCTET_STRING_copy
+
+asn_constr_check_f OBJECT_IDENTIFIER_constraint;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define OBJECT_IDENTIFIER_decode_ber ber_decode_primitive
+#define OBJECT_IDENTIFIER_encode_der der_encode_primitive
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f OBJECT_IDENTIFIER_decode_xer;
+xer_type_encoder_f OBJECT_IDENTIFIER_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f OBJECT_IDENTIFIER_decode_jer;
+jer_type_encoder_f OBJECT_IDENTIFIER_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+#define OBJECT_IDENTIFIER_decode_oer oer_decode_primitive
+#define OBJECT_IDENTIFIER_encode_oer oer_encode_primitive
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+#define OBJECT_IDENTIFIER_decode_uper OCTET_STRING_decode_uper
+#define OBJECT_IDENTIFIER_encode_uper OCTET_STRING_encode_uper
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+#define OBJECT_IDENTIFIER_decode_aper OCTET_STRING_decode_aper
+#define OBJECT_IDENTIFIER_encode_aper OCTET_STRING_encode_aper
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f  OBJECT_IDENTIFIER_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+/**********************************
+ * Some handy conversion routines *
+ **********************************/
+
+/*
+ * This function fills an (arcs) array with OBJECT IDENTIFIER arcs
+ * up to specified (arc_slots) elements.
+ *
+ * EXAMPLE:
+ * 	void print_arcs(OBJECT_IDENTIFIER_t *oid) {
+ * 		asn_oid_arc_t fixed_arcs[10];	// Try with fixed space first
+ * 		asn_oid_arc_t *arcs = fixed_arcs;
+ * 		size_t arc_slots = sizeof(fixed_arcs)/sizeof(fixed_arcs[0]); // 10
+ * 		ssize_t count;	// Real number of arcs.
+ * 		int i;
+ *
+ * 		count = OBJECT_IDENTIFIER_get_arcs(oid, arcs, arc_slots);
+ * 		// If necessary, reallocate arcs array and try again.
+ * 		if(count > arc_slots) {
+ * 			arc_slots = count;
+ * 			arcs = malloc(sizeof(asn_oid_arc_t) * arc_slots);
+ * 			if(!arcs) return;
+ * 			count = OBJECT_IDENTIFIER_get_arcs(oid, arcs, arc_slots);
+ * 			assert(count == arc_slots);
+ * 		}
+ *
+ * 		// Print the contents of the arcs array.
+ * 		for(i = 0; i < count; i++)
+ * 			printf("%"PRIu32"\n", arcs[i]);
+ *
+ * 		// Avoid memory leak.
+ * 		if(arcs != fixed_arcs) free(arcs);
+ * 	}
+ *
+ * RETURN VALUES:
+ * -1/EINVAL:	Invalid arguments (oid is missing)
+ * -1/ERANGE:	One or more arcs have value out of array cell type range.
+ * >=0:		Number of arcs contained in the OBJECT IDENTIFIER
+ *
+ * WARNING: The function always returns the actual number of arcs,
+ * even if there is no sufficient (arc_slots) provided.
+ */
+ssize_t OBJECT_IDENTIFIER_get_arcs(const OBJECT_IDENTIFIER_t *oid,
+                                   asn_oid_arc_t *arcs, size_t arc_slots);
+
+/*
+ * This functions initializes the OBJECT IDENTIFIER object with
+ * the given set of arcs.
+ * The minimum of two arcs must be present; some restrictions apply.
+ * RETURN VALUES:
+ * -1/EINVAL:	Invalid arguments
+ * -1/ERANGE:	The first two arcs do not conform to ASN.1 restrictions.
+ * -1/ENOMEM:	Memory allocation failed
+ * 0:		The object was initialized with new arcs.
+ */
+int OBJECT_IDENTIFIER_set_arcs(OBJECT_IDENTIFIER_t *oid,
+                               const asn_oid_arc_t *arcs, size_t arcs_count);
+
+
+/*
+ * Parse the OBJECT IDENTIFIER textual representation ("1.3.6.1.4.1.9363").
+ * No arc can exceed the (0..ASN_OID_ARC_MAX, which is the same as UINT32_MAX).
+ * This function is not specific to OBJECT IDENTIFIER, it may be used to parse
+ * the RELATIVE-OID data, or any other data consisting of dot-separated
+ * series of numeric values.
+ *
+ * If (oid_txt_length == -1), the strlen() will be invoked to determine the
+ * size of the (oid_text) string.
+ * 
+ * After return, the optional (opt_oid_text_end) is set to the character after
+ * the last parsed one. (opt_oid_text_end) is never less than (oid_text).
+ * 
+ * RETURN VALUES:
+ *   -1:	Parse error.
+ * >= 0:	Number of arcs contained in the OBJECT IDENTIFIER.
+ * 
+ * WARNING: The function always returns the real number of arcs,
+ * even if there is no sufficient (arc_slots) provided.
+ * This is useful for (arc_slots) value estimation.
+ */
+ssize_t OBJECT_IDENTIFIER_parse_arcs(const char *oid_text,
+                                     ssize_t oid_txt_length,
+                                     asn_oid_arc_t *arcs, size_t arcs_count,
+                                     const char **opt_oid_text_end);
+
+/*
+ * Internal functions.
+ * Used by RELATIVE-OID implementation in particular.
+ */
+
+/*
+ * Retrieve a single arc of size from the (arcbuf) buffer.
+ * RETURN VALUES:
+ *  -1: Failed to retrieve the value from the (arcbuf).
+ *  >0: Number of bytes consumed from the (arcbuf), <= (arcbuf_len).
+ */
+ssize_t OBJECT_IDENTIFIER_get_single_arc(const uint8_t *arcbuf,
+                                         size_t arcbuf_len,
+                                         asn_oid_arc_t *ret_value);
+
+/*
+ * Write the unterminated arc value into the (arcbuf) which has the size at
+ * least (arcbuf_len).
+ * RETURN VALUES:
+ *   -1: (arcbuf_len) size is not sufficient to write the value.
+ *  <n>: Number of bytes appended to the arcbuf (<= arcbuf_len).
+ */
+ssize_t OBJECT_IDENTIFIER_set_single_arc(uint8_t *arcbuf, size_t arcbuf_len,
+                                         asn_oid_arc_t arc_value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _OBJECT_IDENTIFIER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_jer.c
new file mode 100644
index 000000000..2b6ed6f48
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_jer.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OBJECT_IDENTIFIER.h"
+
+#define CQUOTE 0x22
+
+static enum jer_pbd_rval
+OBJECT_IDENTIFIER__jer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,
+                                   const void *chunk_buf, size_t chunk_size) {
+    OBJECT_IDENTIFIER_t *st = (OBJECT_IDENTIFIER_t *)sptr;
+    const char *chunk_end = (const char *)chunk_buf + chunk_size;
+    const char *p = (const char *)chunk_buf;
+    const char *endptr;
+    asn_oid_arc_t s_arcs[10];
+    asn_oid_arc_t *arcs = s_arcs;
+    ssize_t num_arcs;
+    ssize_t ret;
+
+    (void)td;
+
+    /* Strip quotes */
+    for (; p < chunk_end; ++p) {
+        if (*p == CQUOTE) {
+            ++p;
+            break;
+        }
+    }
+    --chunk_end;
+    for (; chunk_end >= p; --chunk_end) {
+        if (*chunk_end == CQUOTE)
+            break;
+    }
+    if (chunk_end - p < 0)
+        return JPBD_BROKEN_ENCODING;
+    chunk_size = chunk_end - p;
+    chunk_buf = p;
+
+    num_arcs = OBJECT_IDENTIFIER_parse_arcs(
+        (const char *)chunk_buf, chunk_size, arcs,
+        sizeof(s_arcs) / sizeof(s_arcs[0]), &endptr);
+    if(num_arcs < 0) {
+        /* Expecting more than zero arcs */
+        return JPBD_BROKEN_ENCODING;
+    } else if(num_arcs == 0) {
+        return JPBD_NOT_BODY_IGNORE;
+    }
+    (void)chunk_end;
+    assert(endptr == chunk_end);
+
+    if((size_t)num_arcs > sizeof(s_arcs)/sizeof(s_arcs[0])) {
+        arcs = (asn_oid_arc_t *)MALLOC(num_arcs * sizeof(asn_oid_arc_t));
+        if(!arcs) return JPBD_SYSTEM_FAILURE;
+        ret = OBJECT_IDENTIFIER_parse_arcs((const char *)chunk_buf, chunk_size,
+                                           arcs, num_arcs, &endptr);
+        if(ret != num_arcs)
+            return JPBD_SYSTEM_FAILURE;  /* assert?.. */
+    }
+
+    /*
+     * Convert arcs into BER representation.
+     */
+    ret = OBJECT_IDENTIFIER_set_arcs(st, arcs, num_arcs);
+    if(arcs != s_arcs) FREEMEM(arcs);
+
+    return ret ? JPBD_SYSTEM_FAILURE : JPBD_BODY_CONSUMED;
+}
+
+asn_dec_rval_t
+OBJECT_IDENTIFIER_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                             const asn_TYPE_descriptor_t *td,
+                             const asn_jer_constraints_t *constraints,
+                             void **sptr, const void *buf_ptr,
+                             size_t size) {
+    return jer_decode_primitive(opt_codec_ctx, td,
+        sptr, sizeof(OBJECT_IDENTIFIER_t),
+        buf_ptr, size, OBJECT_IDENTIFIER__jer_body_decode);
+}
+
+asn_enc_rval_t
+OBJECT_IDENTIFIER_encode_jer(const asn_TYPE_descriptor_t *td,
+                             const asn_jer_constraints_t *constraints,
+                             const void *sptr, int ilevel,
+                             enum jer_encoder_flags_e flags,
+                             asn_app_consume_bytes_f *cb, void *app_key) {
+    const OBJECT_IDENTIFIER_t *st = (const OBJECT_IDENTIFIER_t *)sptr;
+    asn_enc_rval_t er = {0,0,0};
+    ssize_t oid_encoded = 0;
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!st || !st->buf) {
+        ASN__ENCODE_FAILED;
+    }
+
+    ASN__CALLBACK("\"", 1);
+    oid_encoded = OBJECT_IDENTIFIER__dump_body(st, cb, app_key);
+    if(oid_encoded < 0) goto cb_failed;
+    er.encoded += oid_encoded;
+    ASN__CALLBACK("\"", 1);
+
+    ASN__ENCODED_OK(er);
+
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_print.c /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_print.c
new file mode 100644
index 000000000..ec954ada4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_print.c
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OBJECT_IDENTIFIER.h"
+
+int
+OBJECT_IDENTIFIER_print(const asn_TYPE_descriptor_t *td, const void *sptr,
+                        int ilevel, asn_app_consume_bytes_f *cb,
+                        void *app_key) {
+    const OBJECT_IDENTIFIER_t *st = (const OBJECT_IDENTIFIER_t *)sptr;
+
+    (void)td;  /* Unused argument */
+    (void)ilevel;  /* Unused argument */
+
+    if(!st || !st->buf)
+        return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+
+    /* Dump preamble */
+    if(cb("{ ", 2, app_key) < 0)
+        return -1;
+
+    if(OBJECT_IDENTIFIER__dump_body(st, cb, app_key) < 0) {
+        return -1;
+    }
+
+    return (cb(" }", 2, app_key) < 0) ? -1 : 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_rfill.c
new file mode 100644
index 000000000..cf41019ab
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_rfill.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OBJECT_IDENTIFIER.h"
+
+/*
+ * Generate values from the list of interesting values, or just a random
+ * value up to the upper limit.
+ */
+static asn_oid_arc_t
+OBJECT_IDENTIFIER__biased_random_arc(asn_oid_arc_t upper_bound) {
+    const asn_oid_arc_t values[] = {0, 1, 127, 128, 129, 254, 255, 256};
+    size_t idx;
+
+    switch(asn_random_between(0, 2)) {
+    case 0:
+        idx = asn_random_between(0, sizeof(values) / sizeof(values[0]) - 1);
+        if(values[idx] < upper_bound) {
+            return values[idx];
+        }
+        /* Fall through */
+    case 1:
+        return asn_random_between(0, upper_bound);
+    case 2:
+    default:
+        return upper_bound;
+    }
+}
+
+asn_random_fill_result_t
+OBJECT_IDENTIFIER_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                              const asn_encoding_constraints_t *constraints,
+                              size_t max_length) {
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    OBJECT_IDENTIFIER_t *st;
+    asn_oid_arc_t arcs[5];
+    size_t arcs_len = asn_random_between(2, 5);
+    size_t i;
+
+    (void)constraints;
+
+    if(max_length < arcs_len) return result_skipped;
+
+    if(*sptr) {
+        st = *sptr;
+    } else {
+        st = CALLOC(1, sizeof(*st));
+    }
+
+    arcs[0] = asn_random_between(0, 2);
+    arcs[1] = OBJECT_IDENTIFIER__biased_random_arc(
+        arcs[0] <= 1 ? 39 : (ASN_OID_ARC_MAX - 80));
+    for(i = 2; i < arcs_len; i++) {
+        arcs[i] = OBJECT_IDENTIFIER__biased_random_arc(ASN_OID_ARC_MAX);
+    }
+
+    if(OBJECT_IDENTIFIER_set_arcs(st, arcs, arcs_len)) {
+        if(st != *sptr) {
+            ASN_STRUCT_FREE(*td, st);
+        }
+        return result_failed;
+    }
+
+    *sptr = st;
+
+    result_ok.length = st->size;
+    return result_ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_xer.c
new file mode 100644
index 000000000..d0e19dbf8
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OBJECT_IDENTIFIER_xer.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OBJECT_IDENTIFIER.h"
+
+static enum xer_pbd_rval
+OBJECT_IDENTIFIER__xer_body_decode(const asn_TYPE_descriptor_t *td, void *sptr,
+                                   const void *chunk_buf, size_t chunk_size) {
+    OBJECT_IDENTIFIER_t *st = (OBJECT_IDENTIFIER_t *)sptr;
+    const char *chunk_end = (const char *)chunk_buf + chunk_size;
+    const char *endptr;
+    asn_oid_arc_t s_arcs[10];
+    asn_oid_arc_t *arcs = s_arcs;
+    ssize_t num_arcs;
+    ssize_t ret;
+
+    (void)td;
+
+    num_arcs = OBJECT_IDENTIFIER_parse_arcs(
+        (const char *)chunk_buf, chunk_size, arcs,
+        sizeof(s_arcs) / sizeof(s_arcs[0]), &endptr);
+    if(num_arcs < 0) {
+        /* Expecting more than zero arcs */
+        return XPBD_BROKEN_ENCODING;
+    } else if(num_arcs == 0) {
+        return XPBD_NOT_BODY_IGNORE;
+    }
+    (void)chunk_end;
+    assert(endptr == chunk_end);
+
+    if((size_t)num_arcs > sizeof(s_arcs)/sizeof(s_arcs[0])) {
+        arcs = (asn_oid_arc_t *)MALLOC(num_arcs * sizeof(asn_oid_arc_t));
+        if(!arcs) return XPBD_SYSTEM_FAILURE;
+        ret = OBJECT_IDENTIFIER_parse_arcs((const char *)chunk_buf, chunk_size,
+                                           arcs, num_arcs, &endptr);
+        if(ret != num_arcs)
+            return XPBD_SYSTEM_FAILURE;  /* assert?.. */
+    }
+
+    /*
+     * Convert arcs into BER representation.
+     */
+    ret = OBJECT_IDENTIFIER_set_arcs(st, arcs, num_arcs);
+    if(arcs != s_arcs) FREEMEM(arcs);
+
+    return ret ? XPBD_SYSTEM_FAILURE : XPBD_BODY_CONSUMED;
+}
+
+asn_dec_rval_t
+OBJECT_IDENTIFIER_decode_xer(const asn_codec_ctx_t *opt_codec_ctx,
+                             const asn_TYPE_descriptor_t *td, void **sptr,
+                             const char *opt_mname, const void *buf_ptr,
+                             size_t size) {
+    return xer_decode_primitive(opt_codec_ctx, td,
+        sptr, sizeof(OBJECT_IDENTIFIER_t), opt_mname,
+            buf_ptr, size, OBJECT_IDENTIFIER__xer_body_decode);
+}
+
+asn_enc_rval_t
+OBJECT_IDENTIFIER_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                             int ilevel, enum xer_encoder_flags_e flags,
+                             asn_app_consume_bytes_f *cb, void *app_key) {
+    const OBJECT_IDENTIFIER_t *st = (const OBJECT_IDENTIFIER_t *)sptr;
+    asn_enc_rval_t er = {0,0,0};
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!st || !st->buf) {
+        ASN__ENCODE_FAILED;
+    }
+
+    er.encoded = OBJECT_IDENTIFIER__dump_body(st, cb, app_key);
+    if(er.encoded < 0) ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING.c
new file mode 100644
index 000000000..0fcdbf9d5
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING.c
@@ -0,0 +1,426 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+#include <errno.h>
+
+/*
+ * OCTET STRING basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_OCTET_STRING_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (4 << 2))
+};
+asn_OCTET_STRING_specifics_t asn_SPC_OCTET_STRING_specs = {
+    sizeof(OCTET_STRING_t),
+    offsetof(OCTET_STRING_t, _asn_ctx),
+    ASN_OSUBV_STR
+};
+asn_TYPE_operation_t asn_OP_OCTET_STRING = {
+    OCTET_STRING_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    OCTET_STRING_print,  /* OCTET STRING generally means a non-ascii sequence */
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    OCTET_STRING_compare,
+    OCTET_STRING_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    OCTET_STRING_decode_ber,
+    OCTET_STRING_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OCTET_STRING_decode_xer_hex,
+    OCTET_STRING_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    OCTET_STRING_decode_jer_hex,
+    OCTET_STRING_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    OCTET_STRING_decode_oer,
+    OCTET_STRING_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    OCTET_STRING_decode_uper,  /* Unaligned PER decoder */
+    OCTET_STRING_encode_uper,  /* Unaligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    OCTET_STRING_decode_aper,  /* Aligned PER decoder */
+    OCTET_STRING_encode_aper,  /* Aligned PER encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    OCTET_STRING_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_OCTET_STRING = {
+    "OCTET STRING",  /* Canonical name */
+    "OCTET_STRING",  /* XML tag name */
+    &asn_OP_OCTET_STRING,
+    asn_DEF_OCTET_STRING_tags,
+    sizeof(asn_DEF_OCTET_STRING_tags)
+        / sizeof(asn_DEF_OCTET_STRING_tags[0]),
+    asn_DEF_OCTET_STRING_tags,	/* Same as above */
+    sizeof(asn_DEF_OCTET_STRING_tags)
+        / sizeof(asn_DEF_OCTET_STRING_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_no_constraint
+    },
+    0, 0,  /* No members */
+    &asn_SPC_OCTET_STRING_specs
+};
+
+void
+OCTET_STRING_free(const asn_TYPE_descriptor_t *td, void *sptr,
+                  enum asn_struct_free_method method) {
+	OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;
+
+	if(!td || !st)
+		return;
+
+	ASN_DEBUG("Freeing %s as OCTET STRING", td->name);
+
+	if(st->buf) {
+		FREEMEM(st->buf);
+		st->buf = 0;
+	}
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    const asn_OCTET_STRING_specifics_t *specs;
+    asn_struct_ctx_t *ctx;
+
+    specs = td->specifics
+            ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+            : &asn_SPC_OCTET_STRING_specs;
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Remove decode-time stack.
+     */
+    struct _stack *stck;
+    stck = (struct _stack *)ctx->ptr;
+    if(stck) {
+        while(stck->tail) {
+            struct _stack_el *sel = stck->tail;
+            stck->tail = sel->prev;
+            FREEMEM(sel);
+        }
+        FREEMEM(stck);
+    }
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+    switch(method) {
+    case ASFM_FREE_EVERYTHING:
+        FREEMEM(sptr);
+        break;
+    case ASFM_FREE_UNDERLYING:
+        break;
+    case ASFM_FREE_UNDERLYING_AND_RESET:
+        memset(sptr, 0,
+               td->specifics
+                   ? ((const asn_OCTET_STRING_specifics_t *)(td->specifics))
+                         ->struct_size
+                   : sizeof(OCTET_STRING_t));
+        break;
+    }
+}
+
+/*
+ * Conversion routines.
+ */
+int
+OCTET_STRING_fromBuf(OCTET_STRING_t *st, const char *str, int len) {
+	void *buf;
+
+	if(st == 0 || (str == 0 && len)) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	/*
+	 * Clear the OCTET STRING.
+	 */
+	if(str == NULL) {
+		FREEMEM(st->buf);
+		st->buf = 0;
+		st->size = 0;
+		return 0;
+	}
+
+	/* Determine the original string size, if not explicitly given */
+	if(len < 0)
+		len = strlen(str);
+
+	/* Allocate and fill the memory */
+	buf = MALLOC(len + 1);
+	if(buf == NULL)
+		return -1;
+
+	memcpy(buf, str, len);
+	((uint8_t *)buf)[len] = '\0';	/* Couldn't use memcpy(len+1)! */
+	FREEMEM(st->buf);
+	st->buf = (uint8_t *)buf;
+	st->size = len;
+
+	return 0;
+}
+
+OCTET_STRING_t *
+OCTET_STRING_new_fromBuf(const asn_TYPE_descriptor_t *td, const char *str,
+                         int len) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_OCTET_STRING_specs;
+    OCTET_STRING_t *st;
+
+	st = (OCTET_STRING_t *)CALLOC(1, specs->struct_size);
+	if(st && str && OCTET_STRING_fromBuf(st, str, len)) {
+		FREEMEM(st);
+		st = NULL;
+	}
+
+	return st;
+}
+
+/*
+ * Lexicographically compare the common prefix of both strings,
+ * and if it is the same return -1 for the smallest string.
+ */
+int
+OCTET_STRING_compare(const asn_TYPE_descriptor_t *td, const void *aptr,
+                     const void *bptr) {
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics;
+    const OCTET_STRING_t *a = aptr;
+    const OCTET_STRING_t *b = bptr;
+
+    (void)specs;
+    assert(!specs || specs->subvariant != ASN_OSUBV_BIT);
+
+    if(a && b) {
+        size_t common_prefix_size = a->size <= b->size ? a->size : b->size;
+        int ret = memcmp(a->buf, b->buf, common_prefix_size);
+        if(ret == 0) {
+            /* Figure out which string with equal prefixes is longer. */
+            if(a->size < b->size) {
+                return -1;
+            } else if(a->size > b->size) {
+                return 1;
+            } else {
+                return 0;
+            }
+        } else {
+            return ret < 0 ? -1 : 1;
+        }
+    } else if(!a && !b) {
+        return 0;
+    } else if(!a) {
+        return -1;
+    } else {
+        return 1;
+    }
+
+}
+
+int
+OCTET_STRING_copy(const asn_TYPE_descriptor_t *td, void **aptr,
+                     const void *bptr) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_OCTET_STRING_specs;
+    OCTET_STRING_t *a = *aptr;
+    const OCTET_STRING_t *b = bptr;
+
+    if(!b) {
+        if(a) {
+            FREEMEM(a->buf);
+            a->buf = 0;
+            a->size = 0;
+            FREEMEM(a);
+        }
+        *aptr = 0;
+        return 0;
+    }
+
+    if(!a) {
+        a = *aptr = (OCTET_STRING_t *)CALLOC(1, specs->struct_size);
+        if(!a) return -1;
+    }
+
+    void *buf = MALLOC(b->size + 1);
+    if(!buf) return -1;
+    memcpy(buf, b->buf, b->size);
+    ((uint8_t *)buf)[b->size] = '\0';
+
+    FREEMEM(a->buf);
+    a->buf = (uint8_t *)buf;
+    a->size = b->size;
+
+    return 0;
+}
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+int
+OCTET_STRING_per_get_characters(asn_per_data_t *po, uint8_t *buf,
+                                size_t units, unsigned int bpc, unsigned int unit_bits,
+                                long lb, long ub, const asn_per_constraints_t *pc) {
+    uint8_t *end = buf + units * bpc;
+
+    ASN_DEBUG("Expanding %d characters into (%ld..%ld):%d",
+              (int)units, lb, ub, unit_bits);
+
+    /* X.691: 27.5.4 */
+    if((unsigned long)ub <= ((unsigned long)2 << (unit_bits - 1))) {
+        /* Decode without translation */
+        lb = 0;
+    } else if(pc && pc->code2value) {
+        if(unit_bits > 16)
+            return 1;  /* FATAL: can't have constrained
+                        * UniversalString with more than
+                        * 16 million code points */
+        for(; buf < end; buf += bpc) {
+            int value;
+            int code = per_get_few_bits(po, unit_bits);
+            if(code < 0) return -1;  /* WMORE */
+            value = pc->code2value(code);
+            if(value < 0) {
+                ASN_DEBUG("Code %d (0x%02x) is"
+                          " not in map (%ld..%ld)",
+                          code, code, lb, ub);
+                return 1;  /* FATAL */
+            }
+            switch(bpc) {
+            case 1: *buf = value; break;
+            case 2: buf[0] = value >> 8; buf[1] = value; break;
+            case 4: buf[0] = value >> 24; buf[1] = value >> 16;
+                buf[2] = value >> 8; buf[3] = value; break;
+            }
+        }
+        return 0;
+    }
+
+    /* Shortcut the no-op copying to the aligned structure */
+    if(lb == 0 && (unit_bits == 8 * bpc)) {
+        return per_get_many_bits(po, buf, 0, unit_bits * units);
+    }
+
+    for(; buf < end; buf += bpc) {
+        int32_t code = per_get_few_bits(po, unit_bits);
+        int32_t ch = code + lb;
+        if(code < 0) return -1;  /* WMORE */
+        if(ch > ub) {
+            ASN_DEBUG("Code %d is out of range (%ld..%ld)",
+                      ch, lb, ub);
+            return 1;  /* FATAL */
+        }
+        switch(bpc) {
+        case 1: *buf = ch; break;
+        case 2: buf[0] = ch >> 8; buf[1] = ch; break;
+        case 4: buf[0] = ch >> 24; buf[1] = ch >> 16;
+            buf[2] = ch >> 8; buf[3] = ch; break;
+        }
+    }
+
+    return 0;
+}
+
+int
+OCTET_STRING_per_put_characters(asn_per_outp_t *po, const uint8_t *buf,
+                                size_t units, unsigned int bpc, unsigned int unit_bits,
+                                long lb, long ub, const asn_per_constraints_t *pc) {
+    const uint8_t *end = buf + units * bpc;
+
+    ASN_DEBUG("Squeezing %d characters into (%ld..%ld):%d (%d bpc)",
+              (int)units, lb, ub, unit_bits, bpc);
+
+    /* X.691: 27.5.4 */
+    if((unsigned long)ub <= ((unsigned long)2 << (unit_bits - 1))) {
+        /* Encode as is */
+        lb = 0;
+    } else if(pc && pc->value2code) {
+        for(; buf < end; buf += bpc) {
+            int code;
+            uint32_t value;
+            switch(bpc) {
+            case 1: value = *(const uint8_t *)buf; break;
+            case 2: value = (buf[0] << 8) | buf[1]; break;
+            case 4: value = (buf[0] << 24) | (buf[1] << 16)
+                | (buf[2] << 8) | buf[3]; break;
+            default: return -1;
+            }
+            code = pc->value2code(value);
+            if(code < 0) {
+                ASN_DEBUG("Character %d (0x%02x) is"
+                          " not in map (%ld..%ld)",
+                          *buf, *buf, lb, ub);
+                return -1;
+            }
+            if(per_put_few_bits(po, code, unit_bits))
+    return -1;
+        }
+    }
+
+    /* Shortcut the no-op copying to the aligned structure */
+    if(lb == 0 && (unit_bits == 8 * bpc)) {
+        return per_put_many_bits(po, buf, unit_bits * units);
+    }
+
+    for(ub -= lb; buf < end; buf += bpc) {
+        int ch;
+        uint32_t value;
+        switch(bpc) {
+        case 1:
+            value = *(const uint8_t *)buf;
+            break;
+        case 2:
+            value = (buf[0] << 8) | buf[1];
+            break;
+        case 4:
+            value = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+            break;
+        default:
+            return -1;
+        }
+        ch = value - lb;
+        if(ch < 0 || ch > ub) {
+            ASN_DEBUG("Character %d (0x%02x) is out of range (%ld..%ld)", *buf,
+                      value, lb, ub + lb);
+            return -1;
+        }
+        if(per_put_few_bits(po, ch, unit_bits)) return -1;
+    }
+
+    return 0;
+}
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING.h /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING.h
new file mode 100644
index 000000000..50d1f732f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING.h
@@ -0,0 +1,168 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_OCTET_STRING_H_
+#define	_OCTET_STRING_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct OCTET_STRING {
+	uint8_t *buf;	/* Buffer with consecutive OCTET_STRING bits */
+	size_t size;	/* Size of the buffer */
+
+	asn_struct_ctx_t _asn_ctx;	/* Parsing across buffer boundaries */
+} OCTET_STRING_t;
+
+extern asn_TYPE_descriptor_t asn_DEF_OCTET_STRING;
+extern asn_TYPE_operation_t asn_OP_OCTET_STRING;
+
+asn_struct_free_f OCTET_STRING_free;
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f OCTET_STRING_print;
+asn_struct_print_f OCTET_STRING_print_utf8;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f OCTET_STRING_compare;
+asn_struct_copy_f    OCTET_STRING_copy;
+
+#define OCTET_STRING_constraint asn_generic_no_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+ber_type_decoder_f OCTET_STRING_decode_ber;
+der_type_encoder_f OCTET_STRING_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f OCTET_STRING_decode_xer_hex;     /* Hexadecimal */
+xer_type_decoder_f OCTET_STRING_decode_xer_binary;  /* 01010111010 */
+xer_type_decoder_f OCTET_STRING_decode_xer_utf8;    /* ASCII/UTF-8 */
+xer_type_encoder_f OCTET_STRING_encode_xer;
+xer_type_encoder_f OCTET_STRING_encode_xer_utf8;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f OCTET_STRING_decode_jer_hex;     /* Hexadecimal */
+jer_type_decoder_f OCTET_STRING_decode_jer_utf8;    /* ASCII/UTF-8 */
+jer_type_encoder_f OCTET_STRING_encode_jer;
+jer_type_encoder_f OCTET_STRING_encode_jer_utf8;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f OCTET_STRING_decode_oer;
+oer_type_encoder_f OCTET_STRING_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f OCTET_STRING_decode_uper;
+per_type_encoder_f OCTET_STRING_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f OCTET_STRING_decode_aper;
+per_type_encoder_f OCTET_STRING_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f  OCTET_STRING_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+int OCTET_STRING_per_get_characters(
+        asn_per_data_t *po,
+        uint8_t *buf,
+        size_t units,
+        unsigned int bpc,
+        unsigned int unit_bits,
+        long lb,
+        long ub,
+        const asn_per_constraints_t *pc);
+
+int OCTET_STRING_per_put_characters(
+        asn_per_outp_t *po,
+        const uint8_t *buf,
+        size_t units,
+        unsigned int bpc,
+        unsigned int unit_bits,
+        long lb,
+        long ub,
+        const asn_per_constraints_t *pc);
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+/******************************
+ * Handy conversion routines. *
+ ******************************/
+
+/*
+ * This function clears the previous value of the OCTET STRING (if any)
+ * and then allocates a new memory with the specified content (str/size).
+ * If size = -1, the size of the original string will be determined
+ * using strlen(str).
+ * If str equals to NULL, the function will silently clear the
+ * current contents of the OCTET STRING.
+ * Returns 0 if it was possible to perform operation, -1 otherwise.
+ */
+int OCTET_STRING_fromBuf(OCTET_STRING_t *s, const char *str, int size);
+
+/* Handy conversion from the C string into the OCTET STRING. */
+#define	OCTET_STRING_fromString(s, str)	OCTET_STRING_fromBuf(s, str, -1)
+
+/*
+ * Allocate and fill the new OCTET STRING and return a pointer to the newly
+ * allocated object. NULL is permitted in str: the function will just allocate
+ * empty OCTET STRING.
+ */
+OCTET_STRING_t *OCTET_STRING_new_fromBuf(const asn_TYPE_descriptor_t *td,
+                                         const char *str, int size);
+
+/****************************
+ * Internally useful stuff. *
+ ****************************/
+
+typedef struct asn_OCTET_STRING_specifics_s {
+    /*
+     * Target structure description.
+     */
+    unsigned struct_size;   /* Size of the structure */
+    unsigned ctx_offset;    /* Offset of the asn_struct_ctx_t member */
+
+    enum asn_OS_Subvariant {
+        ASN_OSUBV_ANY, /* The open type (ANY) */
+        ASN_OSUBV_BIT, /* BIT STRING */
+        ASN_OSUBV_STR, /* String types, not {BMP,Universal}String  */
+        ASN_OSUBV_U16, /* 16-bit character (BMPString) */
+        ASN_OSUBV_U32  /* 32-bit character (UniversalString) */
+    } subvariant;
+} asn_OCTET_STRING_specifics_t;
+
+extern asn_OCTET_STRING_specifics_t asn_SPC_OCTET_STRING_specs;
+
+size_t OCTET_STRING_random_length_constrained(
+    const asn_TYPE_descriptor_t *, const asn_encoding_constraints_t *,
+    size_t max_length);
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+struct _stack_el {
+    ber_tlv_len_t left;   /* What's left to read (or -1) */
+    ber_tlv_len_t got;    /* What was actually processed */
+    unsigned cont_level;  /* Depth of subcontainment */
+    int want_nulls;       /* Want null "end of content" octets? */
+    int bits_chopped;     /* Flag in BIT STRING mode */
+    ber_tlv_tag_t tag;    /* For debugging purposes */
+    struct _stack_el *prev;
+    struct _stack_el *next;
+};
+struct _stack {
+    struct _stack_el *tail;
+    struct _stack_el *cur_ptr;
+};
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _OCTET_STRING_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_aper.c
new file mode 100644
index 000000000..738069634
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_aper.c
@@ -0,0 +1,439 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+#include "BIT_STRING.h"  /* for .bits_unused member */
+
+#undef RETURN
+#define RETURN(_code) do {\
+        asn_dec_rval_t tmprval;\
+        tmprval.code = _code;\
+        tmprval.consumed = consumed_myself;\
+        return tmprval;\
+    } while(0)
+
+static asn_per_constraints_t asn_DEF_OCTET_STRING_constraints = {
+    { APC_CONSTRAINED, 8, 8, 0, 255 },
+    { APC_SEMI_CONSTRAINED, -1, -1, 0, 0 },
+    0, 0
+};
+
+asn_dec_rval_t
+OCTET_STRING_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                         const asn_TYPE_descriptor_t *td,
+                         const asn_per_constraints_t *constraints,
+                         void **sptr, asn_per_data_t *pd) {
+
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    const asn_per_constraints_t *pc = constraints
+        ? constraints
+        : td->encoding_constraints.per_constraints;
+    const asn_per_constraint_t *cval;
+    const asn_per_constraint_t *csiz;
+    asn_dec_rval_t rval = { RC_OK, 0 };
+    BIT_STRING_t *st = (BIT_STRING_t *)*sptr;
+    ssize_t consumed_myself = 0;
+    int repeat;
+    enum {
+        OS__BPC_BIT = 0,
+        OS__BPC_CHAR = 1,
+        OS__BPC_U16 = 2,
+        OS__BPC_U32 = 4
+    } bpc;  /* Bytes per character */
+    unsigned int unit_bits;
+    unsigned int canonical_unit_bits;
+
+    (void)opt_codec_ctx;
+
+    if(pc) {
+        cval = &pc->value;
+        csiz = &pc->size;
+    } else {
+        cval = &asn_DEF_OCTET_STRING_constraints.value;
+        csiz = &asn_DEF_OCTET_STRING_constraints.size;
+    }
+
+    switch(specs->subvariant) {
+    case ASN_OSUBV_ANY:
+    case ASN_OSUBV_STR:
+        canonical_unit_bits = unit_bits = 8;
+        if(cval->flags & APC_CONSTRAINED) {
+            /* follow power of 2 rule */
+            if (cval->range_bits <= 2) {
+        		unit_bits = 2;
+            } else {
+        	if (cval->range_bits <= 4) {
+           		unit_bits = 4;
+           		/* otherwise, unit_bits = 8; */
+        	}
+	   }
+           /* unit_bits = cval->range_bits; */
+           ASN_DEBUG("APER decoding ASN_OSUBV_STR range_bits = %d unit_bits = %d\n",
+            	cval->range_bits, unit_bits);
+        }
+        bpc = OS__BPC_CHAR;
+        break;
+    case ASN_OSUBV_U16:
+        canonical_unit_bits = unit_bits = 16;
+        if(cval->flags & APC_CONSTRAINED) {
+            unit_bits = cval->range_bits;
+            ASN_DEBUG("APER decoding ASN_OSUBV_U16 range_bits = %d\n", cval->range_bits);
+        }
+        bpc = OS__BPC_U16;
+        break;
+    case ASN_OSUBV_U32:
+        canonical_unit_bits = unit_bits = 32;
+        if(cval->flags & APC_CONSTRAINED) {
+            unit_bits = cval->range_bits;
+            ASN_DEBUG("APER decoding ASN_OSUBV_U32 range_bits = %d\n", cval->range_bits);
+        }
+        bpc = OS__BPC_U32;
+        break;
+/*
+    case ASN_OSUBV_ANY:
+        ASN_DEBUG("Unrecognized subvariant %d", specs->subvariant);
+        RETURN(RC_FAIL);
+*/
+    case ASN_OSUBV_BIT:
+    default:
+        canonical_unit_bits = unit_bits = 1;
+        bpc = OS__BPC_BIT;
+        break;
+    }
+
+    /*
+     * Allocate the string.
+     */
+    if(!st) {
+        st = (BIT_STRING_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) RETURN(RC_FAIL);
+    }
+
+    ASN_DEBUG("PER Decoding %s size %lld .. %lld bits %d",
+              csiz->flags & APC_EXTENSIBLE ? "extensible" : "non-extensible",
+              (long long int)csiz->lower_bound, (long long int)csiz->upper_bound,
+              csiz->effective_bits);
+
+    if(csiz->flags & APC_EXTENSIBLE) {
+        int inext = per_get_few_bits(pd, 1);
+        if(inext < 0) RETURN(RC_WMORE);
+        if(inext) {
+            csiz = &asn_DEF_OCTET_STRING_constraints.size;
+            cval = &asn_DEF_OCTET_STRING_constraints.value;
+            unit_bits = canonical_unit_bits;
+        }
+    }
+
+    if(csiz->effective_bits >= 0) {
+        FREEMEM(st->buf);
+        if(bpc) {
+            st->size = csiz->upper_bound * bpc;
+        } else {
+            st->size = (csiz->upper_bound + 7) >> 3;
+        }
+        st->buf = (uint8_t *)MALLOC(st->size + 1);
+        if(!st->buf) { st->size = 0; RETURN(RC_FAIL); }
+    }
+
+    /* X.691, #16.5: zero-length encoding */
+    /* X.691, #16.6: short fixed length encoding (up to 2 octets) */
+    /* X.691, #16.7: long fixed length encoding (up to 64K octets) */
+    if(csiz->effective_bits == 0) {
+        int ret;
+        /* X.691 #16 NOTE 1 for fixed length (<= 16 bits) strings */
+        if (st->size > 2 || csiz->range_bits != 0) {
+            if (aper_get_align(pd) < 0)
+                RETURN(RC_FAIL);
+        }
+        if(bpc) {
+            ASN_DEBUG("Decoding OCTET STRING size %lld",
+                      (long long int)csiz->upper_bound);
+            ret = OCTET_STRING_per_get_characters(pd, st->buf,
+                                                  csiz->upper_bound,
+                                                  bpc, unit_bits,
+                                                  cval->lower_bound,
+                                                  cval->upper_bound,
+                                                  pc);
+            if(ret > 0) RETURN(RC_FAIL);
+        } else {
+            ASN_DEBUG("Decoding BIT STRING size %lld",
+                      (long long int)csiz->upper_bound);
+            ret = per_get_many_bits(pd, st->buf, 0,
+                                    unit_bits * csiz->upper_bound);
+        }
+        if(ret < 0) RETURN(RC_WMORE);
+        consumed_myself += unit_bits * csiz->upper_bound;
+        st->buf[st->size] = 0;
+        if(bpc == 0) {
+            int ubs = (csiz->upper_bound & 0x7);
+            st->bits_unused = ubs ? 8 - ubs : 0;
+        }
+        RETURN(RC_OK);
+    }
+
+    st->size = 0;
+    do {
+        ssize_t raw_len;
+        ssize_t len_bytes;
+        ssize_t len_bits;
+        void *p;
+        int ret;
+
+        repeat = 0;
+        /* Get the PER length */
+        if (csiz->upper_bound - csiz->lower_bound == 0)
+            /* Indefinite length case */
+            raw_len = aper_get_length(pd, -1, -1, csiz->effective_bits, &repeat);
+        else
+            raw_len = aper_get_length(pd, csiz->lower_bound, csiz->upper_bound,
+                                      csiz->effective_bits, &repeat);
+        if(raw_len < 0) RETURN(RC_WMORE);
+
+        ASN_DEBUG("Got PER length eb %ld, len %ld, %s (%s)",
+                  (long)csiz->effective_bits, (long)raw_len,
+                  repeat ? "repeat" : "once", td->name);
+
+        /* X.691 #16 NOTE 1  for fixed length (<=16 bits) strings */
+        if ((raw_len > 2) || (csiz->upper_bound > 2) || (csiz->range_bits != 0))
+        {
+            if (aper_get_align(pd) < 0)
+                RETURN(RC_FAIL);
+        }
+
+        if(bpc) {
+            len_bytes = raw_len * bpc;
+            len_bits = len_bytes * unit_bits;
+        } else {
+            len_bits = raw_len;
+            len_bytes = (len_bits + 7) >> 3;
+            if(len_bits & 0x7)
+                st->bits_unused = 8 - (len_bits & 0x7);
+            /* len_bits be multiple of 16K if repeat is set */
+        }
+        p = REALLOC(st->buf, st->size + len_bytes + 1);
+        if(!p) RETURN(RC_FAIL);
+        st->buf = (uint8_t *)p;
+
+        if(bpc) {
+            ret = OCTET_STRING_per_get_characters(pd,
+                                                  &st->buf[st->size],
+                                                  raw_len, bpc,
+                                                  unit_bits,
+                                                  cval->lower_bound,
+                                                  cval->upper_bound,
+                                                  pc);
+            if(ret > 0) RETURN(RC_FAIL);
+        } else {
+            ret = per_get_many_bits(pd, &st->buf[st->size],
+                                    0, len_bits);
+        }
+        if(ret < 0) RETURN(RC_WMORE);
+        st->size += len_bytes;
+    } while(repeat);
+    st->buf[st->size] = 0;  /* nul-terminate */
+
+    return rval;
+}
+
+asn_enc_rval_t
+OCTET_STRING_encode_aper(const asn_TYPE_descriptor_t *td,
+                         const asn_per_constraints_t *constraints,
+                         const void *sptr, asn_per_outp_t *po) {
+
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    const asn_per_constraints_t *pc = constraints
+        ? constraints
+        : td->encoding_constraints.per_constraints;
+    const asn_per_constraint_t *cval;
+    const asn_per_constraint_t *csiz;
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+    int inext = 0;  /* Lies not within extension root */
+    unsigned int unit_bits;
+    unsigned int canonical_unit_bits;
+    unsigned int sizeinunits;
+    const uint8_t *buf;
+    int ret;
+    enum {
+        OS__BPC_BIT  = 0,
+        OS__BPC_CHAR = 1,
+        OS__BPC_U16  = 2,
+        OS__BPC_U32  = 4
+    } bpc;  /* Bytes per character */
+    int ct_extensible;
+
+    if(!st || (!st->buf && st->size))
+        ASN__ENCODE_FAILED;
+
+    if(pc) {
+        cval = &pc->value;
+        csiz = &pc->size;
+    } else {
+        cval = &asn_DEF_OCTET_STRING_constraints.value;
+        csiz = &asn_DEF_OCTET_STRING_constraints.size;
+    }
+    ct_extensible = csiz->flags & APC_EXTENSIBLE;
+
+    switch(specs->subvariant) {
+    case ASN_OSUBV_ANY:
+    case ASN_OSUBV_STR:
+        canonical_unit_bits = unit_bits = 8;
+        if(cval->flags & APC_CONSTRAINED) {
+        	/* follow power of 2 rule */
+        	if (cval->range_bits <= 2) {
+        		unit_bits = 2;
+        	} else {
+        		if (cval->range_bits <= 4)
+        			unit_bits = 4;
+        		/* otherwise, unit_bits = 8; */
+        	}
+            	/* unit_bits = cval->range_bits; */
+            	ASN_DEBUG("APER encoding ASN_OSUBV_STR range_bits = %d unit_bits = %d\n", 
+            		cval->range_bits, unit_bits);
+        }
+        bpc = OS__BPC_CHAR;
+        sizeinunits = st->size;
+        break;
+    case ASN_OSUBV_U16:
+        canonical_unit_bits = unit_bits = 16;
+        if(cval->flags & APC_CONSTRAINED) {
+            unit_bits = cval->range_bits;
+            ASN_DEBUG("APER encoding ASN_OSUBV_U16 range_bits = %d\n", cval->range_bits);
+        }
+        bpc = OS__BPC_U16;
+        sizeinunits = st->size / 2;
+        break;
+    case ASN_OSUBV_U32:
+        canonical_unit_bits = unit_bits = 32;
+        if(cval->flags & APC_CONSTRAINED) {
+            unit_bits = cval->range_bits;
+            ASN_DEBUG("APER encoding ASN_OSUBV_U32 range_bits = %d\n", cval->range_bits);
+        }
+        bpc = OS__BPC_U32;
+        sizeinunits = st->size / 4;
+        break;
+/*
+    case ASN_OSUBV_ANY:
+        ASN__ENCODE_FAILED;
+*/
+    case ASN_OSUBV_BIT:
+    default:
+        canonical_unit_bits = unit_bits = 1;
+        bpc = OS__BPC_BIT;
+        sizeinunits = st->size * 8 - (st->bits_unused & 0x07);
+        ASN_DEBUG("BIT STRING of %d bytes", sizeinunits);
+        break;
+    }
+
+    ASN_DEBUG("Encoding %s into %d units of %d bits"
+              " (%lld..%lld, effective %d)%s",
+              td->name, sizeinunits, unit_bits,
+              (long long int)csiz->lower_bound,
+              (long long int)csiz->upper_bound,
+              csiz->effective_bits, ct_extensible ? " EXT" : "");
+
+    /* Figure out wheter size lies within PER visible constraint */
+
+    if(csiz->effective_bits >= 0) {
+        if((int)sizeinunits < csiz->lower_bound
+        || (int)sizeinunits > csiz->upper_bound) {
+            if(ct_extensible) {
+                cval = &asn_DEF_OCTET_STRING_constraints.value;
+                csiz = &asn_DEF_OCTET_STRING_constraints.size;
+                unit_bits = canonical_unit_bits;
+                inext = 1;
+            } else
+                ASN__ENCODE_FAILED;
+        }
+    } else {
+        inext = 0;
+    }
+
+    if(ct_extensible) {
+        /* Declare whether length is [not] within extension root */
+        if(per_put_few_bits(po, inext, 1))
+            ASN__ENCODE_FAILED;
+    }
+
+    /* X.691, #16.5: zero-length encoding */
+    /* X.691, #16.6: short fixed length encoding (up to 2 octets) */
+    /* X.691, #16.7: long fixed length encoding (up to 64K octets) */
+    if(csiz->effective_bits >= 0) {
+        ASN_DEBUG("Encoding %zu bytes (%lld), length in %d bits",
+                  st->size, (long long int)(sizeinunits - csiz->lower_bound),
+                  csiz->effective_bits);
+        if (csiz->effective_bits > 0) {
+                ret = aper_put_length(po, csiz->lower_bound, csiz->upper_bound,
+                                      sizeinunits - csiz->lower_bound, NULL);
+                if(ret < 0) ASN__ENCODE_FAILED;
+        }
+        if (csiz->effective_bits > 0 || (st->size > 2)
+            || (csiz->upper_bound > (2 * 8 / unit_bits))
+            || (csiz->range_bits != 0))
+        { /* X.691 #16 NOTE 1 for fixed length (<=16 bits) strings*/
+            if (aper_put_align(po) < 0)
+                ASN__ENCODE_FAILED;
+        }
+        if(bpc) {
+            ret = OCTET_STRING_per_put_characters(po, st->buf,
+                                                  sizeinunits,
+                                                  bpc, unit_bits,
+                                                  cval->lower_bound,
+                                                  cval->upper_bound,
+                                                  pc);
+        } else {
+            ret = per_put_many_bits(po, st->buf,
+                                    sizeinunits * unit_bits);
+        }
+        if(ret) ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    }
+
+    ASN_DEBUG("Encoding %zu bytes", st->size);
+
+    if(sizeinunits == 0) {
+        if(aper_put_length(po, -1, -1, 0, NULL) < 0)
+            ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    }
+
+    buf = st->buf;
+    while(sizeinunits) {
+        int need_eom = 0;
+        ssize_t maySave = aper_put_length(po, -1, -1, sizeinunits, &need_eom);
+
+        if(maySave < 0) ASN__ENCODE_FAILED;
+
+        ASN_DEBUG("Encoding %ld of %ld",
+                  (long)maySave, (long)sizeinunits);
+
+        if(bpc) {
+            ret = OCTET_STRING_per_put_characters(po, buf, maySave,
+                                                  bpc, unit_bits,
+                                                  cval->lower_bound,
+                                                  cval->upper_bound,
+                                                  pc);
+        } else {
+            ret = per_put_many_bits(po, buf, maySave * unit_bits);
+        }
+        if(ret) ASN__ENCODE_FAILED;
+
+        if(bpc)
+            buf += maySave * bpc;
+        else
+            buf += maySave >> 3;
+        sizeinunits -= maySave;
+        assert(!(maySave & 0x07) || !sizeinunits);
+        if(need_eom && (aper_put_length(po, -1, -1, 0, NULL) < 0))
+            ASN__ENCODE_FAILED; /* End of Message length */
+    }
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_ber.c
new file mode 100644
index 000000000..c9956a3ed
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_ber.c
@@ -0,0 +1,525 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+#include "BIT_STRING.h" /* for .bits_unused member */
+
+#undef _CH_PHASE
+#define _CH_PHASE(ctx, inc) do {\
+        if(ctx->phase == 0)\
+            ctx->context = 0;\
+        ctx->phase += inc;\
+    } while(0)
+
+#undef NEXT_PHASE
+#define NEXT_PHASE(ctx) _CH_PHASE(ctx, +1)
+#undef PREV_PHASE
+#define PREV_PHASE(ctx) _CH_PHASE(ctx, -1)
+
+#undef ADVANCE
+#define ADVANCE(num_bytes) do {\
+        size_t num = (num_bytes);\
+        buf_ptr = ((const char *)buf_ptr) + num;\
+        size -= num;\
+        consumed_myself += num;\
+    } while(0)
+
+#undef RETURN
+#define RETURN(_code) do {\
+        asn_dec_rval_t tmprval;\
+        tmprval.code = _code;\
+        tmprval.consumed = consumed_myself;\
+        return tmprval;\
+    } while(0)
+
+#undef APPEND
+#define APPEND(bufptr, bufsize) do {\
+        size_t _bs = (bufsize);  /* Append size */\
+        size_t _ns = ctx->context;  /* Allocated now */\
+        size_t _es = st->size + _bs;  /* Expected size */\
+        /* int is really a typeof(st->size): */\
+        if((int)_es < 0) RETURN(RC_FAIL);\
+        if(_ns <= _es) {\
+            void *ptr;\
+            /* Be nice and round to the memory allocator */\
+            do { _ns = _ns ? _ns << 1 : 16; }\
+                while(_ns <= _es);\
+            /* int is really a typeof(st->size): */\
+            if((int)_ns < 0) RETURN(RC_FAIL);\
+            ptr = REALLOC(st->buf, _ns);\
+            if(ptr) {\
+                st->buf = (uint8_t *)ptr;\
+                ctx->context = _ns;\
+            } else {\
+                RETURN(RC_FAIL);\
+            }\
+            ASN_DEBUG("Reallocating into %ld", (long)_ns);\
+        }\
+        memcpy(st->buf + st->size, bufptr, _bs);\
+        /* Convenient nul-termination */\
+        st->buf[_es] = '\0';\
+        st->size = _es;\
+    } while(0)
+
+/*
+ * The main reason why ASN.1 is still alive is that too much time and effort
+ * is necessary for learning it more or less adequately, thus creating a gut
+ * necessity to demonstrate that acquired skill everywhere afterwards.
+ * No, I am not going to explain what the following stuff is.
+ */
+static struct _stack_el *
+OS__add_stack_el(struct _stack *st) {
+    struct _stack_el *nel;
+
+    /*
+     * Reuse the old stack frame or allocate a new one.
+     */
+    if(st->cur_ptr && st->cur_ptr->next) {
+        nel = st->cur_ptr->next;
+        nel->bits_chopped = 0;
+        nel->got = 0;
+        /* Retain the nel->cont_level, it's correct. */
+    } else {
+        nel = (struct _stack_el *)CALLOC(1, sizeof(struct _stack_el));
+        if(nel == NULL)
+            return NULL;
+
+        if(st->tail) {
+            /* Increase a subcontainment depth */
+            nel->cont_level = st->tail->cont_level + 1;
+            st->tail->next = nel;
+        }
+        nel->prev = st->tail;
+        st->tail = nel;
+    }
+
+    st->cur_ptr = nel;
+
+    return nel;
+}
+
+static struct _stack *
+_new_stack(void) {
+    return (struct _stack *)CALLOC(1, sizeof(struct _stack));
+}
+
+/*
+ * Decode OCTET STRING type.
+ */
+asn_dec_rval_t
+OCTET_STRING_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,
+                        const asn_TYPE_descriptor_t *td, void **sptr,
+                        const void *buf_ptr, size_t size, int tag_mode) {
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    BIT_STRING_t *st = (BIT_STRING_t *)*sptr;
+    asn_dec_rval_t rval;
+    asn_struct_ctx_t *ctx;
+    ssize_t consumed_myself = 0;
+    struct _stack *stck;  /* Expectations stack structure */
+    struct _stack_el *sel = 0;  /* Stack element */
+    int tlv_constr;
+    enum asn_OS_Subvariant type_variant = specs->subvariant;
+
+    ASN_DEBUG("Decoding %s as %s (frame %ld)",
+        td->name,
+        (type_variant == ASN_OSUBV_STR) ?
+            "OCTET STRING" : "OS-SpecialCase",
+        (long)size);
+
+    /*
+     * Create the string if does not exist.
+     */
+    if(st == NULL) {
+        st = (BIT_STRING_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(st == NULL) RETURN(RC_FAIL);
+    }
+
+    /* Restore parsing context */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    switch(ctx->phase) {
+    case 0:
+        /*
+         * Check tags.
+         */
+        rval = ber_check_tags(opt_codec_ctx, td, ctx,
+            buf_ptr, size, tag_mode, -1,
+            &ctx->left, &tlv_constr);
+        if(rval.code != RC_OK)
+            return rval;
+
+        if(tlv_constr) {
+            /*
+             * Complex operation, requires stack of expectations.
+             */
+            ctx->ptr = _new_stack();
+            if(!ctx->ptr) {
+                RETURN(RC_FAIL);
+            }
+        } else {
+            /*
+             * Jump into stackless primitive decoding.
+             */
+            _CH_PHASE(ctx, 3);
+            if(type_variant == ASN_OSUBV_ANY && tag_mode != 1)
+                APPEND(buf_ptr, rval.consumed);
+            ADVANCE(rval.consumed);
+            goto phase3;
+        }
+
+        NEXT_PHASE(ctx);
+        /* Fall through */
+    case 1:
+    phase1:
+        /*
+         * Fill the stack with expectations.
+         */
+        stck = (struct _stack *)ctx->ptr;
+        sel = stck->cur_ptr;
+        do {
+            ber_tlv_tag_t tlv_tag;
+            ber_tlv_len_t tlv_len;
+            ber_tlv_tag_t expected_tag;
+            ssize_t tl, ll, tlvl;
+            /* This one works even if (sel->left == -1) */
+            size_t Left = ((!sel||(size_t)sel->left >= size)
+                ?size:(size_t)sel->left);
+
+
+            ASN_DEBUG("%p, s->l=%ld, s->wn=%ld, s->g=%ld\n", (void *)sel,
+                      (long)(sel?sel->left:0),
+                      (long)(sel?sel->want_nulls:0),
+                      (long)(sel?sel->got:0)
+            );
+            if(sel && sel->left <= 0 && sel->want_nulls == 0) {
+                if(sel->prev) {
+                    struct _stack_el *prev = sel->prev;
+                    if(prev->left != -1) {
+                        if(prev->left < sel->got)
+                            RETURN(RC_FAIL);
+                        prev->left -= sel->got;
+                    }
+                    prev->got += sel->got;
+                    sel = stck->cur_ptr = prev;
+                    if(!sel) break;
+                    tlv_constr = 1;
+                    continue;
+                } else {
+                    sel = stck->cur_ptr = 0;
+                    break;  /* Nothing to wait */
+                }
+            }
+
+            tl = ber_fetch_tag(buf_ptr, Left, &tlv_tag);
+            ASN_DEBUG("fetch tag(size=%ld,L=%ld), %sstack, left=%ld, wn=%ld, tl=%ld",
+                      (long)size, (long)Left, sel?"":"!",
+                      (long)(sel?sel->left:0),
+                      (long)(sel?sel->want_nulls:0),
+                      (long)tl);
+            switch(tl) {
+            case -1: RETURN(RC_FAIL);
+            case 0: RETURN(RC_WMORE);
+            }
+
+            tlv_constr = BER_TLV_CONSTRUCTED(buf_ptr);
+
+            ll = ber_fetch_length(tlv_constr,
+                                  (const char *)buf_ptr + tl,Left - tl,&tlv_len);
+            ASN_DEBUG("Got tag=%s, tc=%d, left=%ld, tl=%ld, len=%ld, ll=%ld",
+                      ber_tlv_tag_string(tlv_tag), tlv_constr,
+                      (long)Left, (long)tl, (long)tlv_len, (long)ll);
+            switch(ll) {
+            case -1: RETURN(RC_FAIL);
+            case 0: RETURN(RC_WMORE);
+            }
+
+            if(sel && sel->want_nulls
+                && ((const uint8_t *)buf_ptr)[0] == 0
+                && ((const uint8_t *)buf_ptr)[1] == 0)
+            {
+                ASN_DEBUG("Eat EOC; wn=%d--", sel->want_nulls);
+
+                if(type_variant == ASN_OSUBV_ANY
+                && (tag_mode != 1 || sel->cont_level))
+                    APPEND("\0\0", 2);
+
+                ADVANCE(2);
+                sel->got += 2;
+                if(sel->left != -1) {
+                    sel->left -= 2;  /* assert(sel->left >= 2) */
+                }
+
+                sel->want_nulls--;
+                if(sel->want_nulls == 0) {
+                    /* Move to the next expectation */
+                    sel->left = 0;
+                    tlv_constr = 1;
+                }
+
+                continue;
+            }
+
+            /*
+             * Set up expected tags,
+             * depending on ASN.1 type being decoded.
+             */
+            switch(type_variant) {
+            case ASN_OSUBV_BIT:
+                /* X.690: 8.6.4.1, NOTE 2 */
+                /* Fall through */
+            case ASN_OSUBV_STR:
+            default:
+                if(sel) {
+                    unsigned level = sel->cont_level;
+                    if(level < td->all_tags_count) {
+                        expected_tag = td->all_tags[level];
+                        break;
+                    } else if(td->all_tags_count) {
+                        expected_tag = td->all_tags
+                            [td->all_tags_count - 1];
+                        break;
+                    }
+                    /* else, Fall through */
+                }
+                /* Fall through */
+            case ASN_OSUBV_ANY:
+                expected_tag = tlv_tag;
+                break;
+            }
+
+            if(tlv_tag != expected_tag) {
+                char buf[2][32];
+                ber_tlv_tag_snprint(tlv_tag,
+                                    buf[0], sizeof(buf[0]));
+                ber_tlv_tag_snprint(td->tags[td->tags_count-1],
+                                    buf[1], sizeof(buf[1]));
+                ASN_DEBUG("Tag does not match expectation: %s != %s",
+                          buf[0], buf[1]);
+                RETURN(RC_FAIL);
+            }
+
+            tlvl = tl + ll;  /* Combined length of T and L encoding */
+            if((tlv_len + tlvl) < 0) {
+                /* tlv_len value is too big */
+                ASN_DEBUG("TLV encoding + length (%ld) is too big",
+                          (long)tlv_len);
+                RETURN(RC_FAIL);
+            }
+
+            /*
+             * Append a new expectation.
+             */
+            sel = OS__add_stack_el(stck);
+            if(!sel) RETURN(RC_FAIL);
+
+            sel->tag = tlv_tag;
+
+            sel->want_nulls = (tlv_len==-1);
+            if(sel->prev && sel->prev->left != -1) {
+                /* Check that the parent frame is big enough */
+                if(sel->prev->left < tlvl + (tlv_len==-1?0:tlv_len))
+                    RETURN(RC_FAIL);
+                if(tlv_len == -1)
+                    sel->left = sel->prev->left - tlvl;
+                else
+                    sel->left = tlv_len;
+            } else {
+                sel->left = tlv_len;
+            }
+            if(type_variant == ASN_OSUBV_ANY
+            && (tag_mode != 1 || sel->cont_level))
+                APPEND(buf_ptr, tlvl);
+            sel->got += tlvl;
+            ADVANCE(tlvl);
+
+            ASN_DEBUG("+EXPECT2 got=%ld left=%ld, wn=%d, clvl=%u",
+                      (long)sel->got, (long)sel->left,
+                      sel->want_nulls, sel->cont_level);
+
+        } while(tlv_constr);
+        if(sel == NULL) {
+            /* Finished operation, "phase out" */
+            ASN_DEBUG("Phase out");
+            _CH_PHASE(ctx, +3);
+            break;
+        }
+
+        NEXT_PHASE(ctx);
+        /* Fall through */
+    case 2:
+        stck = (struct _stack *)ctx->ptr;
+        sel = stck->cur_ptr;
+        ASN_DEBUG("Phase 2: Need %ld bytes, size=%ld, alrg=%ld, wn=%d",
+                  (long)sel->left, (long)size, (long)sel->got,
+                  sel->want_nulls);
+        {
+        ber_tlv_len_t len;
+
+        assert(sel->left >= 0);
+
+        len = ((ber_tlv_len_t)size < sel->left)
+            ? (ber_tlv_len_t)size : sel->left;
+        if(len > 0) {
+            if(type_variant == ASN_OSUBV_BIT
+            && sel->bits_chopped == 0) {
+                /* Put the unused-bits-octet away */
+                st->bits_unused = *(const uint8_t *)buf_ptr;
+                APPEND(((const char *)buf_ptr+1), (len - 1));
+                sel->bits_chopped = 1;
+            } else {
+                APPEND(buf_ptr, len);
+            }
+            ADVANCE(len);
+            sel->left -= len;
+            sel->got += len;
+        }
+
+        if(sel->left) {
+            ASN_DEBUG("OS left %ld, size = %ld, wn=%d\n",
+                      (long)sel->left, (long)size, sel->want_nulls);
+            RETURN(RC_WMORE);
+        }
+
+        PREV_PHASE(ctx);
+        goto phase1;
+        }
+        break;
+    case 3:
+    phase3:
+        /*
+         * Primitive form, no stack required.
+         */
+        assert(ctx->left >= 0);
+
+        if(size < (size_t)ctx->left) {
+            if(!size) RETURN(RC_WMORE);
+            if(type_variant == ASN_OSUBV_BIT && !ctx->context) {
+                st->bits_unused = *(const uint8_t *)buf_ptr;
+                ctx->left--;
+                ADVANCE(1);
+            }
+            APPEND(buf_ptr, size);
+            assert(ctx->context > 0);
+            ctx->left -= size;
+            ADVANCE(size);
+            RETURN(RC_WMORE);
+        } else {
+            if(type_variant == ASN_OSUBV_BIT
+            && !ctx->context && ctx->left) {
+                st->bits_unused = *(const uint8_t *)buf_ptr;
+                ctx->left--;
+                ADVANCE(1);
+            }
+            APPEND(buf_ptr, ctx->left);
+            ADVANCE(ctx->left);
+            ctx->left = 0;
+
+            NEXT_PHASE(ctx);
+        }
+        break;
+    }
+
+    if(sel) {
+        ASN_DEBUG("3sel p=%p, wn=%d, l=%ld, g=%ld, size=%ld",
+                  (void *)sel->prev, sel->want_nulls,
+                  (long)sel->left, (long)sel->got, (long)size);
+        if(sel->prev || sel->want_nulls > 1 || sel->left > 0) {
+            RETURN(RC_WMORE);
+        }
+    }
+
+    /*
+     * BIT STRING-specific processing.
+     */
+    if(type_variant == ASN_OSUBV_BIT) {
+        if(st->size) {
+            if(st->bits_unused < 0 || st->bits_unused > 7) {
+                RETURN(RC_FAIL);
+            }
+            /* Finalize BIT STRING: zero out unused bits. */
+            st->buf[st->size-1] &= 0xff << st->bits_unused;
+        } else {
+            if(st->bits_unused) {
+                RETURN(RC_FAIL);
+            }
+        }
+    }
+
+    ASN_DEBUG("Took %ld bytes to encode %s: [%s]:%ld",
+              (long)consumed_myself, td->name,
+              (type_variant == ASN_OSUBV_STR) ? (char *)st->buf : "<data>",
+              (long)st->size);
+
+
+    RETURN(RC_OK);
+}
+
+/*
+ * Encode OCTET STRING type using DER.
+ */
+asn_enc_rval_t
+OCTET_STRING_encode_der(const asn_TYPE_descriptor_t *td, const void *sptr,
+                        int tag_mode, ber_tlv_tag_t tag,
+                        asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = { 0, 0, 0 };
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;
+    enum asn_OS_Subvariant type_variant = specs->subvariant;
+    int fix_last_byte = 0;
+
+    ASN_DEBUG("%s %s as OCTET STRING",
+              cb?"Estimating":"Encoding", td->name);
+
+    /*
+     * Write tags.
+     */
+    if(type_variant != ASN_OSUBV_ANY || tag_mode == 1) {
+        er.encoded = der_write_tags(td,
+                                    (type_variant == ASN_OSUBV_BIT) + st->size,
+                                    tag_mode, type_variant == ASN_OSUBV_ANY, tag,
+                                    cb, app_key);
+        if(er.encoded == -1) {
+            er.failed_type = td;
+            er.structure_ptr = sptr;
+            return er;
+        }
+    } else {
+        /* Disallow: [<tag>] IMPLICIT ANY */
+        assert(type_variant != ASN_OSUBV_ANY || tag_mode != -1);
+        er.encoded = 0;
+    }
+
+    if(!cb) {
+        er.encoded += (type_variant == ASN_OSUBV_BIT) + st->size;
+        ASN__ENCODED_OK(er);
+    }
+
+    /*
+     * Prepare to deal with the last octet of BIT STRING.
+     */
+    if(type_variant == ASN_OSUBV_BIT) {
+        uint8_t b = st->bits_unused & 0x07;
+        if(b && st->size) fix_last_byte = 1;
+        ASN__CALLBACK(&b, 1);
+    }
+
+    /* Invoke callback for the main part of the buffer */
+    ASN__CALLBACK(st->buf, st->size - fix_last_byte);
+
+    /* The last octet should be stripped off the unused bits */
+    if(fix_last_byte) {
+        uint8_t b = st->buf[st->size-1] & (0xff << st->bits_unused);
+        ASN__CALLBACK(&b, 1);
+    }
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_jer.c
new file mode 100644
index 000000000..a2b80c91d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_jer.c
@@ -0,0 +1,581 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+#include "BIT_STRING.h"  /* for .bits_unused member */
+
+asn_enc_rval_t
+OCTET_STRING_encode_jer(const asn_TYPE_descriptor_t *td,
+                        const asn_jer_constraints_t *constraints,
+                        const void *sptr, int ilevel,
+                        enum jer_encoder_flags_e flags,
+                        asn_app_consume_bytes_f *cb, void *app_key) {
+    const char * const h2c = "0123456789ABCDEF";
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+    char scratch[16 * 3 + 4];
+    char *p = scratch;
+    uint8_t *buf;
+    uint8_t *end;
+    size_t i;
+
+    (void)ilevel;
+    (void)flags;
+
+    if(!st || (!st->buf && st->size))
+        ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    /*
+     * Dump the contents of the buffer in hexadecimal.
+     */
+    buf = st->buf;
+    end = buf + st->size;
+    ASN__CALLBACK("\"", 1);
+    for(i = 0; buf < end; buf++, i++) {
+      if(!(i % 16) && (i || st->size > 16)) {
+        ASN__CALLBACK(scratch, p-scratch);
+        p = scratch;
+      }
+      *p++ = h2c[(*buf >> 4) & 0x0F];
+      *p++ = h2c[*buf & 0x0F];
+    }
+    if(p - scratch) {
+      ASN__CALLBACK(scratch, p-scratch);  /* Dump the rest */
+    }
+    ASN__CALLBACK("\"", 1);
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
+
+static const struct OCTET_STRING__jer_escape_table_s {
+    const char *string;
+    int size;
+} OCTET_STRING__jer_escape_table[] = {
+#define OSXBT(s)  { "\\"s"", sizeof(s) + 1 - 1 }
+#define OSXUT(s)  { "\\u00"s"", sizeof(s) + 4 - 1 }
+    OSXUT("00"),  /* NULL */
+    OSXUT("01"),  /* Start of header */
+    OSXUT("02"),  /* Start of text */
+    OSXUT("03"),  /* End of text */
+    OSXUT("04"),  /* End of transmission */
+    OSXUT("05"),  /* Enquiry */
+    OSXUT("06"),  /* Ack */
+    OSXUT("07"),  /* Bell */
+    OSXBT("b"),   /* \b */
+    OSXBT("t"),   /* \t */
+    OSXBT("n"),   /* \n */
+    OSXUT("0b"),  /* Vertical tab */
+    OSXBT("f"),   /* \f */
+    OSXBT("r"),   /* \r */
+    OSXUT("0e"),  /* Shift out */
+    OSXUT("0f"),  /* Shift in */
+    OSXUT("10"),  /* Data link escape */
+    OSXUT("11"),  /* Device control 1 */
+    OSXUT("12"),  /* Device control 2 */
+    OSXUT("13"),  /* Device control 3 */
+    OSXUT("14"),  /* Device control 4 */
+    OSXUT("15"),  /* Negative ack */
+    OSXUT("16"),  /* Synchronous idle */
+    OSXUT("17"),  /* End of transmission block */
+    OSXUT("18"),  /* Cancel */
+    OSXUT("19"),  /* End of medium */
+    OSXUT("1a"),  /* Substitute */
+    OSXUT("1b"),  /* Escape */
+    OSXUT("1c"),  /* File separator */
+    OSXUT("1d"),  /* Group separator */
+    OSXUT("1e"),  /* Record separator */
+    OSXUT("1f"),  /* Unit separator */
+    { 0, 0 },                           /* " " */
+    { 0, 0 },                           /* ! */
+    OSXBT("\""),                  /* \" */
+    { 0, 0 },                           /* # */
+    { 0, 0 },                           /* $ */
+    { 0, 0 },                           /* % */
+    { 0, 0 },  /* &amp; */
+    { 0, 0 },                           /* ' */
+    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},  /* ()*+,-./ */
+    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},  /* 01234567 */
+    {0,0},{0,0},{0,0},{0,0},            /* 89:; */
+    { 0, 0 },  /* &lt; */
+    { 0, 0 },                           /* = */
+    { 0, 0 },  /* &gt; */
+    { 0, 0 },  /* ? */
+    { 0, 0 },  /* @ */
+    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, /* ABCDEFGH */
+    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, /* IJKLMNOP */
+    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, /* QRSTUVWX */
+    {0,0},{0,0},                                     /* YZ */
+    { 0, 0 },  /* [ */
+    OSXBT("\\"),  /* \\ */
+};
+
+static int
+OS__check_escaped_control_char(const void *buf, int size) {
+    size_t i;
+    /*
+     * Inefficient algorithm which translates the escape sequences
+     * defined above into characters. Returns -1 if not found.
+     * TODO: replace by a faster algorithm (bsearch(), hash or
+     * nested table lookups).
+     */
+    for(i = 0; i < 32 /* Don't spend time on the bottom half */; i++) {
+        const struct OCTET_STRING__jer_escape_table_s *el;
+        el = &OCTET_STRING__jer_escape_table[i];
+        if(el->size == size && memcmp(buf, el->string, size) == 0)
+            return i;
+    }
+    return -1;
+}
+
+static int
+OCTET_STRING__handle_control_chars(void *struct_ptr, const void *chunk_buf, size_t chunk_size) {
+    /*
+     * This might be one of the escape sequences
+     * for control characters. Check it out.
+     * #11.15.5
+     */
+    int control_char = OS__check_escaped_control_char(chunk_buf,chunk_size);
+    if(control_char >= 0) {
+        OCTET_STRING_t *st = (OCTET_STRING_t *)struct_ptr;
+        void *p = REALLOC(st->buf, st->size + 2);
+        if(p) {
+            st->buf = (uint8_t *)p;
+            st->buf[st->size++] = control_char;
+            st->buf[st->size] = '\0';  /* nul-termination */
+            return 0;
+        }
+    }
+
+    return -1;  /* No, it's not */
+}
+
+asn_enc_rval_t
+OCTET_STRING_encode_jer_utf8(const asn_TYPE_descriptor_t *td,
+                             const asn_jer_constraints_t *constraints,
+                             const void *sptr, int ilevel,
+                             enum jer_encoder_flags_e flags,
+                             asn_app_consume_bytes_f *cb, void *app_key) {
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+    uint8_t *buf, *end;
+    uint8_t *ss;  /* Sequence start */
+    ssize_t encoded_len = 0;
+
+    (void)ilevel;  /* Unused argument */
+    (void)flags;  /* Unused argument */
+
+    if(!st || (!st->buf && st->size))
+        ASN__ENCODE_FAILED;
+
+    buf = st->buf;
+    end = buf + st->size;
+    ASN__CALLBACK("\"", 1);
+    for(ss = buf; buf < end; buf++) {
+        unsigned int ch = *buf;
+        int s_len;	/* Special encoding sequence length */
+
+        /*
+         * Escape certain characters
+         */
+        if(ch < sizeof(OCTET_STRING__jer_escape_table)
+            / sizeof(OCTET_STRING__jer_escape_table[0])
+        && (s_len = OCTET_STRING__jer_escape_table[ch].size)) {
+            if(((buf - ss) && cb(ss, buf - ss, app_key) < 0)
+            || cb(OCTET_STRING__jer_escape_table[ch].string, s_len, app_key) < 0)
+                ASN__ENCODE_FAILED;
+            encoded_len += (buf - ss) + s_len;
+            ss = buf + 1;
+        }
+    }
+
+    encoded_len += (buf - ss);
+    if((buf - ss) && cb(ss, buf - ss, app_key) < 0)
+        goto cb_failed;
+
+    er.encoded += encoded_len;
+
+    ASN__CALLBACK("\"", 1);
+    ASN__ENCODED_OK(er);
+
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
+
+#define CQUOTE 0x22
+
+/*
+ * Convert from hexadecimal format (cstring): "AB CD EF"
+ */
+static ssize_t OCTET_STRING__convert_hexadecimal(void *sptr, const void *chunk_buf, size_t chunk_size, int have_more) {
+    OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;
+    const char *chunk_stop = (const char *)chunk_buf;
+    const char *p = chunk_stop;
+    const char *pend = p + chunk_size;
+    unsigned int clv = 0;
+    int half = 0;	/* Half bit */
+    uint8_t *buf;
+
+    /* Strip quotes */
+    for (; p < pend; ++p) {
+        if (*p == CQUOTE) {
+            ++p;
+            break;
+        }
+    }
+    --pend;
+    for (; pend >= p; --pend) {
+        if (*pend == CQUOTE)
+            break;
+    }
+    if (pend - p < 0) return -1;
+    chunk_size = pend - p;
+
+    /* Reallocate buffer according to high cap estimation */
+    size_t new_size = st->size + (chunk_size + 1) / 2;
+    void *nptr = REALLOC(st->buf, new_size + 1);
+    if(!nptr) return -1;
+    st->buf = (uint8_t *)nptr;
+    buf = st->buf + st->size;
+
+    /*
+     * If something like " a b c " appears here, the " a b":3 will be
+     * converted, and the rest skipped. That is, unless buf_size is greater
+     * than chunk_size, then it'll be equivalent to "ABC0".
+     */
+    for(; p < pend; p++) {
+        int ch = *(const unsigned char *)p;
+        switch(ch) {
+        /* allow LF, FF, CR, space */
+        case 0x0a: case 0x0c: case 0x0d: case 0x20:
+            continue;
+        case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:  /*01234*/
+        case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:  /*56789*/
+            clv = (clv << 4) + (ch - 0x30);
+            break;
+        case 0x41: case 0x42: case 0x43:  /* ABC */
+        case 0x44: case 0x45: case 0x46:  /* DEF */
+            clv = (clv << 4) + (ch - 0x41 + 10);
+            break;
+        case 0x61: case 0x62: case 0x63:  /* abc */
+        case 0x64: case 0x65: case 0x66:  /* def */
+            clv = (clv << 4) + (ch - 0x61 + 10);
+            break;
+        default:
+            *buf = 0;  /* JIC */
+            return -1;
+        }
+        if(half++) {
+            half = 0;
+            *buf++ = clv;
+            chunk_stop = p + 1;
+        }
+    }
+
+    /*
+     * Check partial decoding.
+     */
+    if(half) {
+        if(have_more) {
+            /*
+             * Partial specification is fine,
+             * because no more more PJER_TEXT data is available.
+             */
+            *buf++ = clv << 4;
+            chunk_stop = p;
+        }
+    } else {
+        ++p;
+        chunk_stop = p;
+    }
+
+    st->size = buf - st->buf;  /* Adjust the buffer size */
+    assert(st->size <= new_size);
+    st->buf[st->size] = 0;  /* Courtesy termination */
+
+    return (chunk_stop - (const char *)chunk_buf);  /* Converted size */
+}
+
+/*
+ * Something like strtod(), but with stricter rules.
+ */
+static int
+OS__strtoent(const char *buf, const char *end, int32_t *ret_value) {
+	const int32_t last_unicode_codepoint = 0x10ffff;
+	int32_t val = 0;
+	const char *p;
+
+	for(p = buf; p < end; p++) {
+		int ch = *p;
+
+        switch(ch) {
+        case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:  /*01234*/
+        case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:  /*56789*/
+            val = val * 16 + (ch - 0x30);
+            break;
+        case 0x41: case 0x42: case 0x43:  /* ABC */
+        case 0x44: case 0x45: case 0x46:  /* DEF */
+            val = val * 16 + (ch - 0x41 + 10);
+            break;
+        case 0x61: case 0x62: case 0x63:  /* abc */
+        case 0x64: case 0x65: case 0x66:  /* def */
+            val = val * 16 + (ch - 0x61 + 10);
+            break;
+        default:
+            return -1;  /* Character set error */
+        }
+
+        /* Value exceeds the Unicode range. */
+        if(val > last_unicode_codepoint) {
+            return -1;
+        }
+    }
+
+    *ret_value = val;
+    return (p - buf);
+}
+
+/*
+ * Convert from the plain UTF-8 format
+ */
+static ssize_t
+OCTET_STRING__convert_entrefs(void *sptr, const void *chunk_buf,
+                              size_t chunk_size, int have_more) {
+    OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;
+    const char *p = (const char *)chunk_buf;
+    const char *pend = p + chunk_size;
+    uint8_t *buf;
+
+    /* Strip quotes */
+    for(; p < pend; ++p) {
+        if (*p == CQUOTE) {
+            ++p;
+            break;
+        }
+    }
+    --pend;
+    for(; pend >= p; --pend) {
+        if (*pend == CQUOTE)
+            break;
+    }
+    if(pend - p < 0)
+        return -1;
+
+    /* Reallocate buffer */
+    size_t new_size = st->size + (pend - p);
+    void *nptr = REALLOC(st->buf, new_size + 1);
+    if(!nptr) return -1;
+    st->buf = (uint8_t *)nptr;
+    buf = st->buf + st->size;
+
+    /*
+     * Convert into the octet string.
+     */
+    for(; p < pend; p++) {
+        int ch = *(const unsigned char *)p;
+        int len;  /* Length of the rest of the chunk */
+
+        if(ch != 0x5c /* '\' */) {
+            *buf++ = ch;
+            continue;  /* That was easy... */
+        }
+
+        /*
+         * Process entity reference.
+         */
+        len = chunk_size - (p - (const char *)chunk_buf);
+        if(len == 1 /* "\" */) goto want_more;
+        switch(p[1]) {
+        case 0x75: /* 'u' */
+            ;
+            const char *pval;  /* Pointer to start of digits */
+            int32_t val = 0;  /* Entity reference value */
+
+            if(len - 6 < 0) goto want_more;
+            pval = p + 2;
+            len = OS__strtoent(pval, pval + 4, &val);
+            if(len == -1) {
+                /* Invalid charset. Just copy verbatim. */
+                *buf++ = ch;
+                continue;
+            }
+            if(!len) goto want_more;
+            p += (pval - p) + len - 1;  /* Advance past entref */
+
+            if(val < 0x80) {
+                *buf++ = (char)val;
+            } else if(val < 0x800) {
+                *buf++ = 0xc0 | ((val >> 6));
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else if(val < 0x10000) {
+                *buf++ = 0xe0 | ((val >> 12));
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else if(val < 0x200000) {
+                *buf++ = 0xf0 | ((val >> 18));
+                *buf++ = 0x80 | ((val >> 12) & 0x3f);
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else if(val < 0x4000000) {
+                *buf++ = 0xf8 | ((val >> 24));
+                *buf++ = 0x80 | ((val >> 18) & 0x3f);
+                *buf++ = 0x80 | ((val >> 12) & 0x3f);
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else {
+                *buf++ = 0xfc | ((val >> 30) & 0x1);
+                *buf++ = 0x80 | ((val >> 24) & 0x3f);
+                *buf++ = 0x80 | ((val >> 18) & 0x3f);
+                *buf++ = 0x80 | ((val >> 12) & 0x3f);
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            }
+            break;
+        case 0x22: /* " */
+            *buf++ = 0x22;
+            ++p;
+            break;
+        case 0x5c: /* \ */
+            *buf++ = 0x5c;
+            ++p;
+            break;
+        case 0x62: /* b */
+            *buf++ = 0x08;
+            ++p;
+            break;
+        case 0x66: /* f */
+            *buf++ = 0x0c;
+            ++p;
+            break;
+        case 0x6e: /* n */
+            *buf++ = 0x0a;
+            ++p;
+            break;
+        case 0x72: /* r */
+            *buf++ = 0x0d;
+            ++p;
+            break;
+        case 0x74: /* t */
+            *buf++ = 0x09;
+            ++p;
+            break;
+        default:
+            /* Unsupported entity reference */
+            *buf++ = ch;
+            ++p;
+            continue;
+        }
+        continue;
+    want_more:
+        if(have_more) {
+            /*
+             * We know that no more data (of the same type)
+             * is coming. Copy the rest verbatim.
+             */
+            *buf++ = ch;
+            continue;
+        }
+        chunk_size = (p - (const char *)chunk_buf);
+        /* Processing stalled: need more data */
+        break;
+    }
+
+    st->size = buf - st->buf;
+    assert(st->size <= new_size);
+    st->buf[st->size] = 0;  /* Courtesy termination */
+
+    return chunk_size;  /* Converted in full */
+}
+
+/*
+ * Decode OCTET STRING from the JSON element's value.
+ */
+static asn_dec_rval_t
+OCTET_STRING__decode_jer(
+    const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *td,
+    void **sptr, const void *buf_ptr, size_t size,
+    int (*opt_unexpected_tag_decoder)(void *struct_ptr, const void *chunk_buf,
+                                      size_t chunk_size),
+    ssize_t (*body_receiver)(void *struct_ptr, const void *chunk_buf,
+                             size_t chunk_size, int have_more)) {
+    OCTET_STRING_t *st = (OCTET_STRING_t *)*sptr;
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    asn_struct_ctx_t *ctx;  /* Per-structure parser context */
+    asn_dec_rval_t rval;  /* Return value from the decoder */
+    int st_allocated;
+
+    /*
+     * Create the string if does not exist.
+     */
+    if(!st) {
+        st = (OCTET_STRING_t *)CALLOC(1, specs->struct_size);
+        *sptr = (void *)st;
+        if(!st) goto sta_failed;
+        st_allocated = 1;
+    } else {
+        st_allocated = 0;
+    }
+    if(!st->buf) {
+        /* This is separate from above section */
+        st->buf = (uint8_t *)CALLOC(1, 1);
+        if(!st->buf) {
+            if(st_allocated) {
+                *sptr = 0;
+                goto stb_failed;
+            } else {
+                goto sta_failed;
+            }
+        }
+    }
+
+    /* Restore parsing context */
+    ctx = (asn_struct_ctx_t *)(((char *)*sptr) + specs->ctx_offset);
+
+    return jer_decode_general(opt_codec_ctx, ctx, *sptr,
+                              buf_ptr, size,
+                              opt_unexpected_tag_decoder,
+                              body_receiver);
+
+stb_failed:
+    FREEMEM(st);
+sta_failed:
+    rval.code = RC_FAIL;
+    rval.consumed = 0;
+    return rval;
+}
+
+/*
+ * Decode OCTET STRING from the hexadecimal data.
+ */
+asn_dec_rval_t
+OCTET_STRING_decode_jer_hex(const asn_codec_ctx_t *opt_codec_ctx,
+                            const asn_TYPE_descriptor_t *td,
+                            const asn_jer_constraints_t *constraints,
+                            void **sptr,
+                            const void *buf_ptr, size_t size) {
+    return OCTET_STRING__decode_jer(opt_codec_ctx, td, sptr,
+                                    buf_ptr, size, 0,
+                                    OCTET_STRING__convert_hexadecimal);
+}
+
+/*
+ * Decode OCTET STRING from the string (ASCII/UTF-8) data.
+ */
+asn_dec_rval_t
+OCTET_STRING_decode_jer_utf8(const asn_codec_ctx_t *opt_codec_ctx,
+                             const asn_TYPE_descriptor_t *td,
+                             const asn_jer_constraints_t *constraints,
+                             void **sptr, const void *buf_ptr, size_t size) {
+    return OCTET_STRING__decode_jer(opt_codec_ctx, td, sptr,
+                                    buf_ptr, size,
+                                    OCTET_STRING__handle_control_chars,
+                                    OCTET_STRING__convert_entrefs);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_oer.c
new file mode 100644
index 000000000..5ec0d34ae
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_oer.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+
+asn_dec_rval_t
+OCTET_STRING_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                        const asn_TYPE_descriptor_t *td,
+                        const asn_oer_constraints_t *constraints, void **sptr,
+                        const void *ptr, size_t size) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_OCTET_STRING_specs;
+    OCTET_STRING_t *st = (OCTET_STRING_t *)*sptr;
+    const asn_oer_constraints_t *cts =
+        constraints ? constraints : td->encoding_constraints.oer_constraints;
+    ssize_t ct_size = cts ? cts->size : -1;
+    asn_dec_rval_t rval = {RC_OK, 0};
+    size_t expected_length = 0;
+
+    size_t unit_bytes;
+    switch(specs->subvariant) {
+    default:
+    case ASN_OSUBV_BIT:
+        ASN_DEBUG("Invalid use of OCTET STRING to decode BIT STRING");
+        ASN__DECODE_FAILED;
+    case ASN_OSUBV_ANY:
+        /* Fall through */
+    case ASN_OSUBV_STR:
+        unit_bytes = 1;
+        break;
+    case ASN_OSUBV_U16:
+        unit_bytes = 2;
+        break;
+    case ASN_OSUBV_U32:
+        unit_bytes = 4;
+        break;
+    }
+
+    (void)opt_codec_ctx;
+
+    if(!st) {
+        st = (OCTET_STRING_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    if(ct_size >= 0) {
+        expected_length = unit_bytes * ct_size;
+    } else {
+        /*
+         * X.696 (08/2015) #27.2
+         * Encode length determinant as _number of octets_, but only
+         * if upper bound is not equal to lower bound.
+         */
+        ssize_t len_len = oer_fetch_length(ptr, size, &expected_length);
+        if(len_len > 0) {
+            rval.consumed = len_len;
+            ptr = (const char *)ptr + len_len;
+            size -= len_len;
+        } else if(len_len == 0) {
+            ASN__DECODE_STARVED;
+        } else if(len_len < 0) {
+            ASN__DECODE_FAILED;
+        }
+
+        if(expected_length % unit_bytes != 0) {
+            ASN_DEBUG(
+                "Data size %" ASN_PRI_SIZE " bytes is not consistent with multiplier %" ASN_PRI_SIZE "",
+                expected_length, unit_bytes);
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    if(size < expected_length) {
+        ASN__DECODE_STARVED;
+    } else {
+        uint8_t *buf = MALLOC(expected_length + 1);
+        if(buf == NULL) {
+            ASN__DECODE_FAILED;
+        } else {
+            memcpy(buf, ptr, expected_length);
+            buf[expected_length] = '\0';
+        }
+        FREEMEM(st->buf);
+        st->buf = buf;
+        st->size = expected_length;
+
+        rval.consumed += expected_length;
+        return rval;
+    }
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+OCTET_STRING_encode_oer(const asn_TYPE_descriptor_t *td,
+                        const asn_oer_constraints_t *constraints,
+                        const void *sptr, asn_app_consume_bytes_f *cb,
+                        void *app_key) {
+    const asn_OCTET_STRING_specifics_t *specs =
+        td->specifics ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+                      : &asn_SPC_OCTET_STRING_specs;
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+    const asn_oer_constraints_t *cts =
+        constraints ? constraints : td->encoding_constraints.oer_constraints;
+    ssize_t ct_size = cts ? cts->size : -1;
+    asn_enc_rval_t er = {0, 0, 0};
+
+    if(!st) ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Encoding %s %" ASN_PRI_SIZE " as OCTET STRING", td ? td->name : "", st->size);
+
+    if(ct_size >= 0) {
+        /*
+         * Check that available data matches the constraint
+         */
+        size_t unit_bytes;
+        switch(specs->subvariant) {
+        default:
+        case ASN_OSUBV_BIT:
+            ASN_DEBUG("Invalid use of OCTET STRING to encode BIT STRING");
+            ASN__ENCODE_FAILED;
+        case ASN_OSUBV_ANY:
+            /* Fall through */
+        case ASN_OSUBV_STR:
+            unit_bytes = 1;
+            break;
+        case ASN_OSUBV_U16:
+            unit_bytes = 2;
+            break;
+        case ASN_OSUBV_U32:
+            unit_bytes = 4;
+            break;
+        }
+
+        if(st->size != unit_bytes * (size_t)ct_size) {
+            ASN_DEBUG(
+                "Trying to encode %s (%" ASN_PRI_SIZE " bytes) which doesn't fit SIZE "
+                "constraint (%" ASN_PRI_SIZE ")",
+                td->name, st->size, ct_size);
+            ASN__ENCODE_FAILED;
+        }
+    } else {
+        /*
+         * X.696 (08/2015) #27.2
+         * Encode length determinant as _number of octets_, but only
+         * if upper bound is not equal to lower bound.
+         */
+        ssize_t ret = oer_serialize_length(st->size, cb, app_key);
+        if(ret < 0) {
+            ASN__ENCODE_FAILED;
+        }
+        er.encoded += ret;
+    }
+
+    er.encoded += st->size;
+    if(cb(st->buf, st->size, app_key) < 0) {
+        ASN__ENCODE_FAILED;
+    } else {
+        ASN__ENCODED_OK(er);
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_print.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_print.c
new file mode 100644
index 000000000..2ffb37eb2
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_print.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+
+int
+OCTET_STRING_print(const asn_TYPE_descriptor_t *td, const void *sptr,
+                   int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
+    const char * const h2c = "0123456789ABCDEF";
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+    char scratch[16 * 3 + 4];
+    char *p = scratch;
+    uint8_t *buf;
+    uint8_t *end;
+    size_t i;
+
+    (void)td;  /* Unused argument */
+
+    if(!st || (!st->buf && st->size))
+        return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+
+    /*
+     * Dump the contents of the buffer in hexadecimal.
+     */
+    buf = st->buf;
+    end = (buf == NULL)? NULL : buf + st->size;
+    for(i = 0; buf < end; buf++, i++) {
+        if(!(i % 16) && (i || st->size > 16)) {
+            if(cb(scratch, p - scratch, app_key) < 0)
+                return -1;
+            _i_INDENT(1);
+            p = scratch;
+        }
+        *p++ = h2c[(*buf >> 4) & 0x0F];
+        *p++ = h2c[*buf & 0x0F];
+        *p++ = 0x20;
+    }
+
+    if(p > scratch) {
+        p--;  /* Remove the tail space */
+        if(cb(scratch, p - scratch, app_key) < 0)
+            return -1;
+    }
+
+    return 0;
+}
+
+int
+OCTET_STRING_print_utf8(const asn_TYPE_descriptor_t *td, const void *sptr,
+                        int ilevel, asn_app_consume_bytes_f *cb,
+                        void *app_key) {
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+
+    (void)td;  /* Unused argument */
+    (void)ilevel;  /* Unused argument */
+
+    if(st && (st->buf || !st->size)) {
+        return (cb(st->buf, st->size, app_key) < 0) ? -1 : 0;
+    } else {
+        return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_rfill.c
new file mode 100644
index 000000000..4605bf699
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_rfill.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+
+/*
+ * Biased function for randomizing character values around their limits.
+ */
+static uint32_t
+OCTET_STRING__random_char(unsigned long lb, unsigned long ub) {
+    assert(lb <= ub);
+    switch(asn_random_between(0, 16)) {
+    case 0:
+        if(lb < ub) return lb + 1;
+        /* Fall through */
+    case 1:
+        return lb;
+    case 2:
+        if(lb < ub) return ub - 1;
+        /* Fall through */
+    case 3:
+        return ub;
+    default:
+        return asn_random_between(lb, ub);
+    }
+}
+
+asn_random_fill_result_t
+OCTET_STRING_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                         const asn_encoding_constraints_t *constraints,
+                         size_t max_length) {
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    unsigned int unit_bytes = 1;
+    unsigned long clb = 0;  /* Lower bound on char */
+    unsigned long cub = 255;  /* Higher bound on char value */
+    uint8_t *buf;
+    uint8_t *bend;
+    uint8_t *b;
+    size_t rnd_len;
+    OCTET_STRING_t *st;
+
+    if(max_length == 0 && !*sptr) return result_skipped;
+
+    switch(specs->subvariant) {
+    default:
+    case ASN_OSUBV_ANY:
+        return result_failed;
+    case ASN_OSUBV_BIT:
+        /* Handled by BIT_STRING itself. */
+        return result_failed;
+    case ASN_OSUBV_STR:
+        unit_bytes = 1;
+        clb = 0;
+        cub = 255;
+        break;
+    case ASN_OSUBV_U16:
+        unit_bytes = 2;
+        clb = 0;
+        cub = 65535;
+        break;
+    case ASN_OSUBV_U32:
+        unit_bytes = 4;
+        clb = 0;
+        cub = 0x10FFFF;
+        break;
+    }
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+    if(!constraints || !constraints->per_constraints)
+        constraints = &td->encoding_constraints;
+    if(constraints->per_constraints) {
+        const asn_per_constraint_t *pc = &constraints->per_constraints->value;
+        if(pc->flags & APC_SEMI_CONSTRAINED) {
+            clb = pc->lower_bound;
+        } else if(pc->flags & APC_CONSTRAINED) {
+            clb = pc->lower_bound;
+            cub = pc->upper_bound;
+        }
+    }
+#else
+    if(!constraints) constraints = &td->encoding_constraints;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+
+    rnd_len =
+        OCTET_STRING_random_length_constrained(td, constraints, max_length);
+
+    buf = CALLOC(unit_bytes, rnd_len + 1);
+    if(!buf) return result_failed;
+
+    bend = &buf[unit_bytes * rnd_len];
+
+    switch(unit_bytes) {
+    case 1:
+        for(b = buf; b < bend; b += unit_bytes) {
+            *(uint8_t *)b = OCTET_STRING__random_char(clb, cub);
+        }
+        *(uint8_t *)b = 0;
+        break;
+    case 2:
+        for(b = buf; b < bend; b += unit_bytes) {
+            uint32_t code = OCTET_STRING__random_char(clb, cub);
+            b[0] = code >> 8;
+            b[1] = code;
+        }
+        *(uint16_t *)b = 0;
+        break;
+    case 4:
+        for(b = buf; b < bend; b += unit_bytes) {
+            uint32_t code = OCTET_STRING__random_char(clb, cub);
+            b[0] = code >> 24;
+            b[1] = code >> 16;
+            b[2] = code >> 8;
+            b[3] = code;
+        }
+        *(uint32_t *)b = 0;
+        break;
+    }
+
+    if(*sptr) {
+        st = *sptr;
+        FREEMEM(st->buf);
+    } else {
+        st = (OCTET_STRING_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) {
+            FREEMEM(buf);
+            return result_failed;
+        }
+    }
+
+    st->buf = buf;
+    st->size = unit_bytes * rnd_len;
+
+    result_ok.length = st->size;
+    return result_ok;
+}
+
+size_t
+OCTET_STRING_random_length_constrained(
+    const asn_TYPE_descriptor_t *td,
+    const asn_encoding_constraints_t *constraints, size_t max_length) {
+    const unsigned lengths[] = {0,     1,     2,     3,     4,     8,
+                                126,   127,   128,   16383, 16384, 16385,
+                                65534, 65535, 65536, 65537};
+    size_t rnd_len;
+
+    /* Figure out how far we should go */
+    rnd_len = lengths[asn_random_between(
+        0, sizeof(lengths) / sizeof(lengths[0]) - 1)];
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+    if(!constraints || !constraints->per_constraints)
+        constraints = &td->encoding_constraints;
+    if(constraints->per_constraints) {
+        const asn_per_constraint_t *pc = &constraints->per_constraints->size;
+        if(pc->flags & APC_CONSTRAINED) {
+            long suggested_upper_bound = pc->upper_bound < (ssize_t)max_length
+                                             ? pc->upper_bound
+                                             : (ssize_t)max_length;
+            if(max_length <= (size_t)pc->lower_bound) {
+                return pc->lower_bound;
+            }
+            if(pc->flags & APC_EXTENSIBLE) {
+                switch(asn_random_between(0, 5)) {
+                case 0:
+                    if(pc->lower_bound > 0) {
+                        rnd_len = pc->lower_bound - 1;
+                        break;
+                    }
+                    /* Fall through */
+                case 1:
+                    rnd_len = pc->upper_bound + 1;
+                    break;
+                case 2:
+                    /* Keep rnd_len from the table */
+                    if(rnd_len <= max_length) {
+                        break;
+                    }
+                    /* Fall through */
+                default:
+                    rnd_len = asn_random_between(pc->lower_bound,
+                                                 suggested_upper_bound);
+                }
+            } else {
+                rnd_len =
+                    asn_random_between(pc->lower_bound, suggested_upper_bound);
+            }
+        } else {
+            rnd_len = asn_random_between(0, max_length);
+        }
+    } else {
+#else
+    if(!constraints) constraints = &td->encoding_constraints;
+    {
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+        if(rnd_len > max_length) {
+            rnd_len = asn_random_between(0, max_length);
+        }
+    }
+
+    return rnd_len;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_uper.c
new file mode 100644
index 000000000..88214dd54
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_uper.c
@@ -0,0 +1,319 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+#include "BIT_STRING.h"  /* for .bits_unused member */
+
+#undef RETURN
+#define RETURN(_code) do {\
+        asn_dec_rval_t tmprval;\
+        tmprval.code = _code;\
+        tmprval.consumed = consumed_myself;\
+        return tmprval;\
+    } while(0)
+
+static asn_per_constraints_t asn_DEF_OCTET_STRING_constraints = {
+    { APC_CONSTRAINED, 8, 8, 0, 255 },
+    { APC_SEMI_CONSTRAINED, -1, -1, 0, 0 },
+    0, 0
+};
+
+asn_dec_rval_t
+OCTET_STRING_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                         const asn_TYPE_descriptor_t *td,
+                         const asn_per_constraints_t *constraints, void **sptr,
+                         asn_per_data_t *pd) {
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    const asn_per_constraints_t *pc =
+        constraints ? constraints : td->encoding_constraints.per_constraints;
+    const asn_per_constraint_t *cval;
+    const asn_per_constraint_t *csiz;
+    asn_dec_rval_t rval = { RC_OK, 0 };
+    OCTET_STRING_t *st = (OCTET_STRING_t *)*sptr;
+    ssize_t consumed_myself = 0;
+    int repeat;
+    enum {
+        OS__BPC_CHAR = 1,
+        OS__BPC_U16 = 2,
+        OS__BPC_U32 = 4
+    } bpc;  /* Bytes per character */
+    unsigned int unit_bits;
+    unsigned int canonical_unit_bits;
+
+    (void)opt_codec_ctx;
+
+    if(pc) {
+        cval = &pc->value;
+        csiz = &pc->size;
+    } else {
+        cval = &asn_DEF_OCTET_STRING_constraints.value;
+        csiz = &asn_DEF_OCTET_STRING_constraints.size;
+    }
+
+    switch(specs->subvariant) {
+    default:
+    case ASN_OSUBV_ANY:
+    case ASN_OSUBV_BIT:
+        ASN_DEBUG("Unrecognized subvariant %d", specs->subvariant);
+        RETURN(RC_FAIL);
+        break;
+    case ASN_OSUBV_STR:
+        canonical_unit_bits = unit_bits = 8;
+        if(cval->flags & APC_CONSTRAINED)
+            unit_bits = cval->range_bits;
+        bpc = OS__BPC_CHAR;
+        break;
+    case ASN_OSUBV_U16:
+        canonical_unit_bits = unit_bits = 16;
+        if(cval->flags & APC_CONSTRAINED)
+            unit_bits = cval->range_bits;
+        bpc = OS__BPC_U16;
+        break;
+    case ASN_OSUBV_U32:
+        canonical_unit_bits = unit_bits = 32;
+        if(cval->flags & APC_CONSTRAINED)
+            unit_bits = cval->range_bits;
+        bpc = OS__BPC_U32;
+        break;
+    }
+
+    /*
+     * Allocate the string.
+     */
+    if(!st) {
+        st = (OCTET_STRING_t *)(*sptr = CALLOC(1, specs->struct_size));
+        if(!st) RETURN(RC_FAIL);
+    }
+
+    ASN_DEBUG("PER Decoding %s size %"ASN_PRIdMAX" .. %"ASN_PRIdMAX" bits %d",
+              csiz->flags & APC_EXTENSIBLE ? "extensible" : "non-extensible",
+              csiz->lower_bound, csiz->upper_bound, csiz->effective_bits);
+
+    if(csiz->flags & APC_EXTENSIBLE) {
+        int inext = per_get_few_bits(pd, 1);
+        if(inext < 0) RETURN(RC_WMORE);
+        if(inext) {
+            csiz = &asn_DEF_OCTET_STRING_constraints.size;
+            unit_bits = canonical_unit_bits;
+        }
+    }
+
+    if(csiz->effective_bits >= 0) {
+        FREEMEM(st->buf);
+        if(bpc) {
+            st->size = csiz->upper_bound * bpc;
+        } else {
+            st->size = (csiz->upper_bound + 7) >> 3;
+        }
+        st->buf = (uint8_t *)MALLOC(st->size + 1);
+        if(!st->buf) { st->size = 0; RETURN(RC_FAIL); }
+    }
+
+    /* X.691, #16.5: zero-length encoding */
+    /* X.691, #16.6: short fixed length encoding (up to 2 octets) */
+    /* X.691, #16.7: long fixed length encoding (up to 64K octets) */
+    if(csiz->effective_bits == 0) {
+        int ret;
+        if(bpc) {
+            ASN_DEBUG("Encoding OCTET STRING size %"ASN_PRIdMAX"",
+                      csiz->upper_bound);
+            ret = OCTET_STRING_per_get_characters(pd, st->buf,
+                                                  csiz->upper_bound,
+                                                  bpc, unit_bits,
+                                                  cval->lower_bound,
+                                                  cval->upper_bound,
+                                                  pc);
+            if(ret > 0) RETURN(RC_FAIL);
+        } else {
+            ASN_DEBUG("Encoding BIT STRING size %"ASN_PRIdMAX"",
+                      csiz->upper_bound);
+            ret = per_get_many_bits(pd, st->buf, 0,
+                                    unit_bits * csiz->upper_bound);
+        }
+        if(ret < 0) RETURN(RC_WMORE);
+        consumed_myself += unit_bits * csiz->upper_bound;
+        st->buf[st->size] = 0;
+        RETURN(RC_OK);
+    }
+
+    st->size = 0;
+    do {
+        ssize_t raw_len;
+        ssize_t len_bytes;
+        void *p;
+        int ret;
+
+        /* Get the PER length */
+        raw_len = uper_get_length(pd, csiz->effective_bits, csiz->lower_bound,
+                                  &repeat);
+        if(raw_len < 0) RETURN(RC_WMORE);
+        if(raw_len == 0 && st->buf) break;
+
+        ASN_DEBUG("Got PER length eb %ld, len %ld, %s (%s)",
+                  (long)csiz->effective_bits, (long)raw_len,
+                  repeat ? "repeat" : "once", td->name);
+        len_bytes = raw_len * bpc;
+        p = REALLOC(st->buf, st->size + len_bytes + 1);
+        if(!p) RETURN(RC_FAIL);
+        st->buf = (uint8_t *)p;
+
+        ret = OCTET_STRING_per_get_characters(pd, &st->buf[st->size], raw_len,
+                                              bpc, unit_bits, cval->lower_bound,
+                                              cval->upper_bound, pc);
+        if(ret > 0) RETURN(RC_FAIL);
+        if(ret < 0) RETURN(RC_WMORE);
+        st->size += len_bytes;
+    } while(repeat);
+    st->buf[st->size] = 0;  /* nul-terminate */
+
+    return rval;
+}
+
+asn_enc_rval_t
+OCTET_STRING_encode_uper(const asn_TYPE_descriptor_t *td,
+                         const asn_per_constraints_t *constraints,
+                         const void *sptr, asn_per_outp_t *po) {
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    const asn_per_constraints_t *pc = constraints
+        ? constraints
+        : td->encoding_constraints.per_constraints;
+    const asn_per_constraint_t *cval;
+    const asn_per_constraint_t *csiz;
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+    int inext = 0;  /* Lies not within extension root */
+    unsigned int unit_bits;
+    unsigned int canonical_unit_bits;
+    size_t size_in_units;
+    const uint8_t *buf;
+    int ret;
+    enum {
+        OS__BPC_CHAR = 1,
+        OS__BPC_U16 = 2,
+        OS__BPC_U32 = 4
+    } bpc;  /* Bytes per character */
+    int ct_extensible;
+
+    if(!st || (!st->buf && st->size))
+        ASN__ENCODE_FAILED;
+
+    if(pc) {
+        cval = &pc->value;
+        csiz = &pc->size;
+    } else {
+        cval = &asn_DEF_OCTET_STRING_constraints.value;
+        csiz = &asn_DEF_OCTET_STRING_constraints.size;
+    }
+    ct_extensible = csiz->flags & APC_EXTENSIBLE;
+
+    switch(specs->subvariant) {
+    default:
+    case ASN_OSUBV_ANY:
+    case ASN_OSUBV_BIT:
+        ASN__ENCODE_FAILED;
+    case ASN_OSUBV_STR:
+        canonical_unit_bits = unit_bits = 8;
+        if(cval->flags & APC_CONSTRAINED)
+            unit_bits = cval->range_bits;
+        bpc = OS__BPC_CHAR;
+        size_in_units = st->size;
+        break;
+    case ASN_OSUBV_U16:
+        canonical_unit_bits = unit_bits = 16;
+        if(cval->flags & APC_CONSTRAINED)
+            unit_bits = cval->range_bits;
+        bpc = OS__BPC_U16;
+        size_in_units = st->size >> 1;
+        if(st->size & 1) {
+            ASN_DEBUG("%s string size is not modulo 2", td->name);
+            ASN__ENCODE_FAILED;
+        }
+        break;
+    case ASN_OSUBV_U32:
+        canonical_unit_bits = unit_bits = 32;
+        if(cval->flags & APC_CONSTRAINED)
+            unit_bits = cval->range_bits;
+        bpc = OS__BPC_U32;
+        size_in_units = st->size >> 2;
+        if(st->size & 3) {
+            ASN_DEBUG("%s string size is not modulo 4", td->name);
+            ASN__ENCODE_FAILED;
+        }
+        break;
+    }
+
+    ASN_DEBUG("Encoding %s into %" ASN_PRI_SIZE " units of %d bits"
+              " (%"ASN_PRIdMAX"..%"ASN_PRIdMAX", effective %d)%s",
+              td->name, size_in_units, unit_bits,
+              csiz->lower_bound, csiz->upper_bound,
+              csiz->effective_bits, ct_extensible ? " EXT" : "");
+
+    /* Figure out whether size lies within PER visible constraint */
+
+    if(csiz->effective_bits >= 0) {
+        if((ssize_t)size_in_units < csiz->lower_bound
+           || (ssize_t)size_in_units > csiz->upper_bound) {
+            if(ct_extensible) {
+                csiz = &asn_DEF_OCTET_STRING_constraints.size;
+                unit_bits = canonical_unit_bits;
+                inext = 1;
+            } else {
+                ASN__ENCODE_FAILED;
+            }
+        }
+    } else {
+        inext = 0;
+    }
+
+    if(ct_extensible) {
+        /* Declare whether length is [not] within extension root */
+        if(per_put_few_bits(po, inext, 1))
+            ASN__ENCODE_FAILED;
+    }
+
+    if(csiz->effective_bits >= 0 && !inext) {
+        ASN_DEBUG("Encoding %" ASN_PRI_SIZE " bytes (%"ASN_PRIdMAX"), length in %d bits", st->size,
+                  size_in_units - csiz->lower_bound, csiz->effective_bits);
+        ret = per_put_few_bits(po, size_in_units - csiz->lower_bound,
+                               csiz->effective_bits);
+        if(ret) ASN__ENCODE_FAILED;
+        ret = OCTET_STRING_per_put_characters(po, st->buf, size_in_units, bpc,
+                                              unit_bits, cval->lower_bound,
+                                              cval->upper_bound, pc);
+        if(ret) ASN__ENCODE_FAILED;
+        ASN__ENCODED_OK(er);
+    }
+
+    ASN_DEBUG("Encoding %" ASN_PRI_SIZE " bytes", st->size);
+
+    buf = st->buf;
+    ASN_DEBUG("Encoding %" ASN_PRI_SIZE " in units", size_in_units);
+    do {
+        int need_eom = 0;
+        ssize_t may_save = uper_put_length(po, size_in_units, &need_eom);
+        if(may_save < 0) ASN__ENCODE_FAILED;
+
+        ASN_DEBUG("Encoding %" ASN_PRI_SSIZE " of %" ASN_PRI_SIZE "%s", may_save, size_in_units,
+                  need_eom ? ",+EOM" : "");
+
+        ret = OCTET_STRING_per_put_characters(po, buf, may_save, bpc, unit_bits,
+                                              cval->lower_bound,
+                                              cval->upper_bound, pc);
+        if(ret) ASN__ENCODE_FAILED;
+
+        buf += may_save * bpc;
+        size_in_units -= may_save;
+        assert(!(may_save & 0x07) || !size_in_units);
+        if(need_eom && uper_put_length(po, 0, 0))
+            ASN__ENCODE_FAILED; /* End of Message length */
+    } while(size_in_units);
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_xer.c
new file mode 100644
index 000000000..4def68bde
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OCTET_STRING_xer.c
@@ -0,0 +1,627 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OCTET_STRING.h"
+#include "BIT_STRING.h"  /* for .bits_unused member */
+
+asn_enc_rval_t
+OCTET_STRING_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                        int ilevel, enum xer_encoder_flags_e flags,
+                        asn_app_consume_bytes_f *cb, void *app_key) {
+    const char * const h2c = "0123456789ABCDEF";
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+    char scratch[16 * 3 + 4];
+    char *p = scratch;
+    uint8_t *buf;
+    uint8_t *end;
+    size_t i;
+
+    if(!st || (!st->buf && st->size))
+        ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    /*
+     * Dump the contents of the buffer in hexadecimal.
+     */
+    buf = st->buf;
+    end = buf + st->size;
+    if(flags & XER_F_CANONICAL) {
+        char *scend = scratch + (sizeof(scratch) - 2);
+        for(; buf < end; buf++) {
+            if(p >= scend) {
+                ASN__CALLBACK(scratch, p - scratch);
+                p = scratch;
+            }
+            *p++ = h2c[(*buf >> 4) & 0x0F];
+            *p++ = h2c[*buf & 0x0F];
+        }
+
+        ASN__CALLBACK(scratch, p-scratch);  /* Dump the rest */
+    } else {
+        for(i = 0; buf < end; buf++, i++) {
+            if(!(i % 16) && (i || st->size > 16)) {
+                ASN__CALLBACK(scratch, p-scratch);
+                p = scratch;
+                ASN__TEXT_INDENT(1, ilevel);
+            }
+            *p++ = h2c[(*buf >> 4) & 0x0F];
+            *p++ = h2c[*buf & 0x0F];
+            *p++ = 0x20;
+        }
+        if(p - scratch) {
+            p--;  /* Remove the tail space */
+            ASN__CALLBACK(scratch, p-scratch);  /* Dump the rest */
+            if(st->size > 16)
+                ASN__TEXT_INDENT(1, ilevel-1);
+        }
+    }
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
+
+static const struct OCTET_STRING__xer_escape_table_s {
+    const char *string;
+    int size;
+} OCTET_STRING__xer_escape_table[] = {
+#define	OSXET(s)	{ s, sizeof(s) - 1 }
+    OSXET("\074\156\165\154\057\076"),  /* <nul/> */
+    OSXET("\074\163\157\150\057\076"),  /* <soh/> */
+    OSXET("\074\163\164\170\057\076"),  /* <stx/> */
+    OSXET("\074\145\164\170\057\076"),  /* <etx/> */
+    OSXET("\074\145\157\164\057\076"),  /* <eot/> */
+    OSXET("\074\145\156\161\057\076"),  /* <enq/> */
+    OSXET("\074\141\143\153\057\076"),  /* <ack/> */
+    OSXET("\074\142\145\154\057\076"),  /* <bel/> */
+    OSXET("\074\142\163\057\076"),      /* <bs/> */
+    OSXET("\011"),                      /* \t */
+    OSXET("\012"),                      /* \n */
+    OSXET("\074\166\164\057\076"),      /* <vt/> */
+    OSXET("\074\146\146\057\076"),      /* <ff/> */
+    OSXET("\015"),                      /* \r */
+    OSXET("\074\163\157\057\076"),      /* <so/> */
+    OSXET("\074\163\151\057\076"),      /* <si/> */
+    OSXET("\074\144\154\145\057\076"),  /* <dle/> */
+    OSXET("\074\144\143\061\057\076"),  /* <de1/> */
+    OSXET("\074\144\143\062\057\076"),  /* <de2/> */
+    OSXET("\074\144\143\063\057\076"),  /* <de3/> */
+    OSXET("\074\144\143\064\057\076"),  /* <de4/> */
+    OSXET("\074\156\141\153\057\076"),  /* <nak/> */
+    OSXET("\074\163\171\156\057\076"),  /* <syn/> */
+    OSXET("\074\145\164\142\057\076"),  /* <et/ext/source> */
+    OSXET("\074\143\141\156\057\076"),  /* <can/> */
+    OSXET("\074\145\155\057\076"),      /* <em/> */
+    OSXET("\074\163\165\142\057\076"),  /* <su/ext/source> */
+    OSXET("\074\145\163\143\057\076"),  /* <esc/> */
+    OSXET("\074\151\163\064\057\076"),  /* <is4/> */
+    OSXET("\074\151\163\063\057\076"),  /* <is3/> */
+    OSXET("\074\151\163\062\057\076"),  /* <is2/> */
+    OSXET("\074\151\163\061\057\076"),  /* <is1/> */
+    { 0, 0 },                           /* " " */
+    { 0, 0 },                           /* ! */
+    { 0, 0 },                           /* \" */
+    { 0, 0 },                           /* # */
+    { 0, 0 },                           /* $ */
+    { 0, 0 },                           /* % */
+    OSXET("\046\141\155\160\073"),      /* &amp; */
+    { 0, 0 },                           /* ' */
+    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},  /* ()*+,-./ */
+    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},  /* 01234567 */
+    {0,0},{0,0},{0,0},{0,0},            /* 89:; */
+    OSXET("\046\154\164\073"),          /* &lt; */
+    { 0, 0 },                           /* = */
+    OSXET("\046\147\164\073"),          /* &gt; */
+};
+
+static int
+OS__check_escaped_control_char(const void *buf, int size) {
+    size_t i;
+    /*
+     * Inefficient algorithm which translates the escape sequences
+     * defined above into characters. Returns -1 if not found.
+     * TODO: replace by a faster algorithm (bsearch(), hash or
+     * nested table lookups).
+     */
+    for(i = 0; i < 32 /* Don't spend time on the bottom half */; i++) {
+        const struct OCTET_STRING__xer_escape_table_s *el;
+        el = &OCTET_STRING__xer_escape_table[i];
+        if(el->size == size && memcmp(buf, el->string, size) == 0)
+            return i;
+    }
+    return -1;
+}
+
+static int
+OCTET_STRING__handle_control_chars(void *struct_ptr, const void *chunk_buf, size_t chunk_size) {
+    /*
+     * This might be one of the escape sequences
+     * for control characters. Check it out.
+     * #11.15.5
+     */
+    int control_char = OS__check_escaped_control_char(chunk_buf,chunk_size);
+    if(control_char >= 0) {
+        OCTET_STRING_t *st = (OCTET_STRING_t *)struct_ptr;
+        void *p = REALLOC(st->buf, st->size + 2);
+        if(p) {
+            st->buf = (uint8_t *)p;
+            st->buf[st->size++] = control_char;
+            st->buf[st->size] = '\0';  /* nul-termination */
+            return 0;
+        }
+    }
+
+    return -1;  /* No, it's not */
+}
+
+asn_enc_rval_t
+OCTET_STRING_encode_xer_utf8(const asn_TYPE_descriptor_t *td, const void *sptr,
+                             int ilevel, enum xer_encoder_flags_e flags,
+                             asn_app_consume_bytes_f *cb, void *app_key) {
+    const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;
+    asn_enc_rval_t er = { 0, 0, 0 };
+    uint8_t *buf, *end;
+    uint8_t *ss;  /* Sequence start */
+    ssize_t encoded_len = 0;
+
+    (void)ilevel;  /* Unused argument */
+    (void)flags;  /* Unused argument */
+
+    if(!st || (!st->buf && st->size))
+        ASN__ENCODE_FAILED;
+
+    buf = st->buf;
+    end = buf + st->size;
+    for(ss = buf; buf < end; buf++) {
+        unsigned int ch = *buf;
+        int s_len;	/* Special encoding sequence length */
+
+        /*
+         * Escape certain characters: X.680/11.15
+         */
+        if(ch < sizeof(OCTET_STRING__xer_escape_table)
+            / sizeof(OCTET_STRING__xer_escape_table[0])
+        && (s_len = OCTET_STRING__xer_escape_table[ch].size)) {
+            if(((buf - ss) && cb(ss, buf - ss, app_key) < 0)
+            || cb(OCTET_STRING__xer_escape_table[ch].string, s_len, app_key) < 0)
+                ASN__ENCODE_FAILED;
+            encoded_len += (buf - ss) + s_len;
+            ss = buf + 1;
+        }
+    }
+
+    encoded_len += (buf - ss);
+    if((buf - ss) && cb(ss, buf - ss, app_key) < 0)
+        ASN__ENCODE_FAILED;
+
+    er.encoded = encoded_len;
+    ASN__ENCODED_OK(er);
+}
+
+/*
+ * Convert from hexadecimal format (cstring): "AB CD EF"
+ */
+static ssize_t OCTET_STRING__convert_hexadecimal(void *sptr, const void *chunk_buf, size_t chunk_size, int have_more) {
+    OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;
+    const char *chunk_stop = (const char *)chunk_buf;
+    const char *p = chunk_stop;
+    const char *pend = p + chunk_size;
+    unsigned int clv = 0;
+    int half = 0;	/* Half bit */
+    uint8_t *buf;
+
+    /* Reallocate buffer according to high cap estimation */
+    size_t new_size = st->size + (chunk_size + 1) / 2;
+    void *nptr = REALLOC(st->buf, new_size + 1);
+    if(!nptr) return -1;
+    st->buf = (uint8_t *)nptr;
+    buf = st->buf + st->size;
+
+    /*
+     * If something like " a b c " appears here, the " a b":3 will be
+     * converted, and the rest skipped. That is, unless buf_size is greater
+     * than chunk_size, then it'll be equivalent to "ABC0".
+     */
+    for(; p < pend; p++) {
+        int ch = *(const unsigned char *)p;
+        switch(ch) {
+        case 0x09: case 0x0a: case 0x0c: case 0x0d:
+        case 0x20:
+            /* Ignore whitespace */
+            continue;
+        case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:  /*01234*/
+        case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:  /*56789*/
+            clv = (clv << 4) + (ch - 0x30);
+            break;
+        case 0x41: case 0x42: case 0x43:  /* ABC */
+        case 0x44: case 0x45: case 0x46:  /* DEF */
+            clv = (clv << 4) + (ch - 0x41 + 10);
+            break;
+        case 0x61: case 0x62: case 0x63:  /* abc */
+        case 0x64: case 0x65: case 0x66:  /* def */
+            clv = (clv << 4) + (ch - 0x61 + 10);
+            break;
+        default:
+            *buf = 0;  /* JIC */
+            return -1;
+        }
+        if(half++) {
+            half = 0;
+            *buf++ = clv;
+            chunk_stop = p + 1;
+        }
+    }
+
+    /*
+     * Check partial decoding.
+     */
+    if(half) {
+        if(have_more) {
+            /*
+             * Partial specification is fine,
+             * because no more more PXER_TEXT data is available.
+             */
+            *buf++ = clv << 4;
+            chunk_stop = p;
+        }
+    } else {
+        chunk_stop = p;
+    }
+
+    st->size = buf - st->buf;  /* Adjust the buffer size */
+    assert(st->size <= new_size);
+    st->buf[st->size] = 0;  /* Courtesy termination */
+
+    return (chunk_stop - (const char *)chunk_buf);  /* Converted size */
+}
+
+/*
+ * Convert from binary format: "00101011101"
+ */
+static ssize_t OCTET_STRING__convert_binary(void *sptr, const void *chunk_buf, size_t chunk_size, int have_more) {
+    BIT_STRING_t *st = (BIT_STRING_t *)sptr;
+    const char *p = (const char *)chunk_buf;
+    const char *pend = (p == NULL)? NULL : p + chunk_size;
+    int bits_unused = st->bits_unused & 0x7;
+    uint8_t *buf;
+
+    /* Reallocate buffer according to high cap estimation */
+    size_t new_size = st->size + (chunk_size + 7) / 8;
+    void *nptr = REALLOC(st->buf, new_size + 1);
+    if(!nptr) return -1;
+    st->buf = (uint8_t *)nptr;
+    buf = st->buf + st->size;
+
+    (void)have_more;
+
+    if(bits_unused == 0)
+        bits_unused = 8;
+    else if(st->size)
+        buf--;
+
+    /*
+     * Convert series of 0 and 1 into the octet string.
+     */
+    for(; p < pend; p++) {
+        int ch = *(const unsigned char *)p;
+        switch(ch) {
+        case 0x09: case 0x0a: case 0x0c: case 0x0d:
+        case 0x20:
+            /* Ignore whitespace */
+            break;
+        case 0x30:
+        case 0x31:
+            if(bits_unused-- <= 0) {
+                *++buf = 0;	/* Clean the cell */
+                bits_unused = 7;
+            }
+            *buf |= (ch&1) << bits_unused;
+            break;
+        default:
+            st->bits_unused = bits_unused;
+            return -1;
+        }
+    }
+
+    if(bits_unused == 8) {
+        st->size = buf - st->buf;
+        st->bits_unused = 0;
+    } else {
+        st->size = buf - st->buf + 1;
+        st->bits_unused = bits_unused;
+    }
+
+    assert(st->size <= new_size);
+    st->buf[st->size] = 0;  /* Courtesy termination */
+
+    return chunk_size;  /* Converted in full */
+}
+
+/*
+ * Something like strtod(), but with stricter rules.
+ */
+static int
+OS__strtoent(int base, const char *buf, const char *end, int32_t *ret_value) {
+	const int32_t last_unicode_codepoint = 0x10ffff;
+	int32_t val = 0;
+	const char *p;
+
+	for(p = buf; p < end; p++) {
+		int ch = *p;
+
+        switch(ch) {
+        case 0x30: case 0x31: case 0x32: case 0x33: case 0x34:  /*01234*/
+        case 0x35: case 0x36: case 0x37: case 0x38: case 0x39:  /*56789*/
+            val = val * base + (ch - 0x30);
+            break;
+        case 0x41: case 0x42: case 0x43:  /* ABC */
+        case 0x44: case 0x45: case 0x46:  /* DEF */
+            val = val * base + (ch - 0x41 + 10);
+            break;
+        case 0x61: case 0x62: case 0x63:  /* abc */
+        case 0x64: case 0x65: case 0x66:  /* def */
+            val = val * base + (ch - 0x61 + 10);
+            break;
+        case 0x3b:  /* ';' */
+            *ret_value = val;
+            return (p - buf) + 1;
+        default:
+            return -1;  /* Character set error */
+        }
+
+        /* Value exceeds the Unicode range. */
+        if(val > last_unicode_codepoint) {
+            return -1;
+        }
+    }
+
+    *ret_value = -1;
+    return (p - buf);
+}
+
+/*
+ * Convert from the plain UTF-8 format, expanding entity references: "2 &lt; 3"
+ */
+static ssize_t
+OCTET_STRING__convert_entrefs(void *sptr, const void *chunk_buf,
+                              size_t chunk_size, int have_more) {
+    OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;
+    const char *p = (const char *)chunk_buf;
+    const char *pend = p + chunk_size;
+    uint8_t *buf;
+
+    /* Reallocate buffer */
+    size_t new_size = st->size + chunk_size;
+    void *nptr = REALLOC(st->buf, new_size + 1);
+    if(!nptr) return -1;
+    st->buf = (uint8_t *)nptr;
+    buf = st->buf + st->size;
+
+    /*
+     * Convert series of 0 and 1 into the octet string.
+     */
+    for(; p < pend; p++) {
+        int ch = *(const unsigned char *)p;
+        int len;  /* Length of the rest of the chunk */
+
+        if(ch != 0x26 /* '&' */) {
+            *buf++ = ch;
+            continue;  /* That was easy... */
+        }
+
+        /*
+         * Process entity reference.
+         */
+        len = chunk_size - (p - (const char *)chunk_buf);
+        if(len == 1 /* "&" */) goto want_more;
+        if(p[1] == 0x23 /* '#' */) {
+            const char *pval;  /* Pointer to start of digits */
+            int32_t val = 0;  /* Entity reference value */
+            int base;
+
+            if(len == 2 /* "&#" */) goto want_more;
+            if(p[2] == 0x78 /* 'x' */)
+                pval = p + 3, base = 16;
+            else
+                pval = p + 2, base = 10;
+            len = OS__strtoent(base, pval, p + len, &val);
+            if(len == -1) {
+                /* Invalid charset. Just copy verbatim. */
+                *buf++ = ch;
+                continue;
+            }
+            if(!len || pval[len-1] != 0x3b) goto want_more;
+            assert(val > 0);
+            p += (pval - p) + len - 1;  /* Advance past entref */
+
+            if(val < 0x80) {
+                *buf++ = (char)val;
+            } else if(val < 0x800) {
+                *buf++ = 0xc0 | ((val >> 6));
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else if(val < 0x10000) {
+                *buf++ = 0xe0 | ((val >> 12));
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else if(val < 0x200000) {
+                *buf++ = 0xf0 | ((val >> 18));
+                *buf++ = 0x80 | ((val >> 12) & 0x3f);
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else if(val < 0x4000000) {
+                *buf++ = 0xf8 | ((val >> 24));
+                *buf++ = 0x80 | ((val >> 18) & 0x3f);
+                *buf++ = 0x80 | ((val >> 12) & 0x3f);
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            } else {
+                *buf++ = 0xfc | ((val >> 30) & 0x1);
+                *buf++ = 0x80 | ((val >> 24) & 0x3f);
+                *buf++ = 0x80 | ((val >> 18) & 0x3f);
+                *buf++ = 0x80 | ((val >> 12) & 0x3f);
+                *buf++ = 0x80 | ((val >> 6) & 0x3f);
+                *buf++ = 0x80 | ((val & 0x3f));
+            }
+        } else {
+            /*
+             * Ugly, limited parsing of &amp; &gt; &lt;
+             */
+            char *sc = (char *)memchr(p, 0x3b, len > 5 ? 5 : len);
+            if(!sc) goto want_more;
+            if((sc - p) == 4
+                && p[1] == 0x61  /* 'a' */
+                && p[2] == 0x6d  /* 'm' */
+                && p[3] == 0x70  /* 'p' */) {
+                *buf++ = 0x26;
+                p = sc;
+                continue;
+            }
+            if((sc - p) == 3) {
+                if(p[1] == 0x6c) {
+                    *buf = 0x3c;  /* '<' */
+                } else if(p[1] == 0x67) {
+                    *buf = 0x3e;  /* '>' */
+                } else {
+                    /* Unsupported entity reference */
+                    *buf++ = ch;
+                    continue;
+                }
+                if(p[2] != 0x74) {
+                    /* Unsupported entity reference */
+                    *buf++ = ch;
+                    continue;
+                }
+                buf++;
+                p = sc;
+                continue;
+            }
+            /* Unsupported entity reference */
+            *buf++ = ch;
+        }
+
+        continue;
+    want_more:
+        if(have_more) {
+            /*
+             * We know that no more data (of the same type)
+             * is coming. Copy the rest verbatim.
+             */
+            *buf++ = ch;
+            continue;
+        }
+        chunk_size = (p - (const char *)chunk_buf);
+        /* Processing stalled: need more data */
+        break;
+    }
+
+    st->size = buf - st->buf;
+    assert(st->size <= new_size);
+    st->buf[st->size] = 0;  /* Courtesy termination */
+
+    return chunk_size;  /* Converted in full */
+}
+
+/*
+ * Decode OCTET STRING from the XML element's body.
+ */
+static asn_dec_rval_t
+OCTET_STRING__decode_xer(
+    const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *td,
+    void **sptr, const char *opt_mname, const void *buf_ptr, size_t size,
+    int (*opt_unexpected_tag_decoder)(void *struct_ptr, const void *chunk_buf,
+                                      size_t chunk_size),
+    ssize_t (*body_receiver)(void *struct_ptr, const void *chunk_buf,
+                             size_t chunk_size, int have_more)) {
+    OCTET_STRING_t *st = (OCTET_STRING_t *)*sptr;
+    const asn_OCTET_STRING_specifics_t *specs = td->specifics
+        ? (const asn_OCTET_STRING_specifics_t *)td->specifics
+        : &asn_SPC_OCTET_STRING_specs;
+    const char *xml_tag = opt_mname ? opt_mname : td->xml_tag;
+    asn_struct_ctx_t *ctx;  /* Per-structure parser context */
+    asn_dec_rval_t rval;  /* Return value from the decoder */
+    int st_allocated;
+
+    /*
+     * Create the string if does not exist.
+     */
+    if(!st) {
+        st = (OCTET_STRING_t *)CALLOC(1, specs->struct_size);
+        *sptr = (void *)st;
+        if(!st) goto sta_failed;
+        st_allocated = 1;
+    } else {
+        st_allocated = 0;
+    }
+    if(!st->buf) {
+        /* This is separate from above section */
+        st->buf = (uint8_t *)CALLOC(1, 1);
+        if(!st->buf) {
+            if(st_allocated) {
+                *sptr = 0;
+                goto stb_failed;
+            } else {
+                goto sta_failed;
+            }
+        }
+    }
+
+    /* Restore parsing context */
+    ctx = (asn_struct_ctx_t *)(((char *)*sptr) + specs->ctx_offset);
+
+    return xer_decode_general(opt_codec_ctx, ctx, *sptr, xml_tag,
+                              buf_ptr, size,
+                              opt_unexpected_tag_decoder,
+                              body_receiver);
+
+stb_failed:
+    FREEMEM(st);
+sta_failed:
+    rval.code = RC_FAIL;
+    rval.consumed = 0;
+    return rval;
+}
+
+/*
+ * Decode OCTET STRING from the hexadecimal data.
+ */
+asn_dec_rval_t
+OCTET_STRING_decode_xer_hex(const asn_codec_ctx_t *opt_codec_ctx,
+                            const asn_TYPE_descriptor_t *td, void **sptr,
+                            const char *opt_mname, const void *buf_ptr,
+                            size_t size) {
+    return OCTET_STRING__decode_xer(opt_codec_ctx, td, sptr, opt_mname,
+                                    buf_ptr, size, 0,
+                                    OCTET_STRING__convert_hexadecimal);
+}
+
+/*
+ * Decode OCTET STRING from the binary (0/1) data.
+ */
+asn_dec_rval_t
+OCTET_STRING_decode_xer_binary(const asn_codec_ctx_t *opt_codec_ctx,
+                               const asn_TYPE_descriptor_t *td, void **sptr,
+                               const char *opt_mname, const void *buf_ptr,
+                               size_t size) {
+    return OCTET_STRING__decode_xer(opt_codec_ctx, td, sptr, opt_mname,
+                                    buf_ptr, size, 0,
+                                    OCTET_STRING__convert_binary);
+}
+
+/*
+ * Decode OCTET STRING from the string (ASCII/UTF-8) data.
+ */
+asn_dec_rval_t
+OCTET_STRING_decode_xer_utf8(const asn_codec_ctx_t *opt_codec_ctx,
+                             const asn_TYPE_descriptor_t *td, void **sptr,
+                             const char *opt_mname, const void *buf_ptr,
+                             size_t size) {
+    return OCTET_STRING__decode_xer(opt_codec_ctx, td, sptr, opt_mname,
+                                    buf_ptr, size,
+                                    OCTET_STRING__handle_control_chars,
+                                    OCTET_STRING__convert_entrefs);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE.c /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE.c
new file mode 100644
index 000000000..1f80ecd93
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE.c
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OPEN_TYPE.h"
+#include "constr_CHOICE.h"
+
+asn_TYPE_operation_t asn_OP_OPEN_TYPE = {
+    OPEN_TYPE_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    OPEN_TYPE_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    OPEN_TYPE_compare,
+    OPEN_TYPE_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    OPEN_TYPE_decode_ber,
+    OPEN_TYPE_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OPEN_TYPE_decode_xer,
+    OPEN_TYPE_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    OPEN_TYPE_decode_jer,
+    OPEN_TYPE_encode_jer,
+#else
+    0,
+    0,
+#endif /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    OPEN_TYPE_decode_oer,
+    OPEN_TYPE_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    OPEN_TYPE_decode_uper,
+    OPEN_TYPE_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    OPEN_TYPE_decode_aper,
+    OPEN_TYPE_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    0,  /* Random fill is not supported for open type */
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE.h /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE.h
new file mode 100644
index 000000000..db8f4b9d4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE.h
@@ -0,0 +1,128 @@
+/*-
+ * Copyright (c) 2017-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef ASN_OPEN_TYPE_H
+#define ASN_OPEN_TYPE_H
+
+#include "asn_application.h"
+///////////#include "per_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Decode an Open Type which is potentially constraiend
+ * by the other members of the parent structure.
+ */
+
+#undef  ADVANCE
+#define ADVANCE(num_bytes)               \
+    do {                                 \
+        size_t num = num_bytes;          \
+        ptr = ((const char *)ptr) + num; \
+        size -= num;                     \
+        consumed_myself += num;          \
+    } while(0)
+
+#define OPEN_TYPE_free CHOICE_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+#define OPEN_TYPE_print CHOICE_print
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define OPEN_TYPE_compare CHOICE_compare
+#define OPEN_TYPE_copy    CHOICE_copy
+
+#define OPEN_TYPE_constraint CHOICE_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+asn_dec_rval_t OPEN_TYPE_ber_get(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *parent_type,
+    void *parent_structure,
+    const asn_TYPE_member_t *element,
+    const void *ptr, size_t size);
+#define OPEN_TYPE_decode_ber NULL
+#define OPEN_TYPE_encode_der CHOICE_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+asn_dec_rval_t OPEN_TYPE_xer_get(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *parent_type,
+    void *parent_structure,
+    const asn_TYPE_member_t *element,
+    const void *ptr, size_t size);
+#define OPEN_TYPE_decode_xer NULL
+#define OPEN_TYPE_encode_xer CHOICE_encode_xer
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+asn_dec_rval_t OPEN_TYPE_jer_get(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *parent_type,
+    void *parent_structure,
+    const asn_TYPE_member_t *element,
+    const void *ptr, size_t size);
+#define OPEN_TYPE_decode_jer NULL
+#define OPEN_TYPE_encode_jer CHOICE_encode_jer
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+asn_dec_rval_t OPEN_TYPE_oer_get(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *parent_type,
+    void *parent_structure,
+    asn_TYPE_member_t *element, const void *ptr,
+    size_t size);
+#define OPEN_TYPE_decode_oer NULL
+asn_enc_rval_t OPEN_TYPE_encode_oer(
+    const asn_TYPE_descriptor_t *type_descriptor,
+    const asn_oer_constraints_t *constraints, const void *struct_ptr,
+    asn_app_consume_bytes_f *consume_bytes_cb, void *app_key);
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+asn_dec_rval_t OPEN_TYPE_uper_get(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *parent_type,
+    void *parent_structure,
+    const asn_TYPE_member_t *element,
+    asn_per_data_t *pd);
+#define OPEN_TYPE_decode_uper NULL
+asn_enc_rval_t OPEN_TYPE_encode_uper(
+    const asn_TYPE_descriptor_t *type_descriptor,
+    const asn_per_constraints_t *constraints, const void *struct_ptr,
+    asn_per_outp_t *per_output);
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+asn_dec_rval_t OPEN_TYPE_aper_get(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *parent_type,
+    void *parent_structure,
+    const asn_TYPE_member_t *element,
+    asn_per_data_t *pd);
+#define OPEN_TYPE_decode_aper NULL
+asn_enc_rval_t OPEN_TYPE_encode_aper(
+    const asn_TYPE_descriptor_t *type_descriptor,
+    const asn_per_constraints_t *constraints, const void *struct_ptr,
+    asn_per_outp_t *per_output);
+
+int OPEN_TYPE_aper_is_unknown_type(
+    const asn_TYPE_descriptor_t *td,
+    void *sptr,
+    const asn_TYPE_member_t *elm);
+
+asn_dec_rval_t OPEN_TYPE_aper_unknown_type_discard_bytes(
+    asn_per_data_t *pd);
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+extern asn_TYPE_operation_t asn_OP_OPEN_TYPE;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_OPEN_TYPE_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_aper.c
new file mode 100644
index 000000000..135d646ab
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_aper.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OPEN_TYPE.h"
+#include "constr_CHOICE.h"
+#include "aper_opentype.h"
+
+asn_dec_rval_t
+OPEN_TYPE_aper_get(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td, void *sptr,
+                   const asn_TYPE_member_t *elm, asn_per_data_t *pd) {
+    asn_type_selector_result_t selected;
+    void *memb_ptr;   /* Pointer to the member */
+    void **memb_ptr2; /* Pointer to that pointer */
+    void *inner_value;
+    asn_dec_rval_t rv;
+
+    if(!(elm->flags & ATF_OPEN_TYPE)) {
+        ASN__DECODE_FAILED;
+    }
+
+    if(!elm->type_selector) {
+        ASN_DEBUG("Type selector is not defined for Open Type %s->%s->%s",
+                  td->name, elm->name, elm->type->name);
+        ASN__DECODE_FAILED;
+    }
+
+    selected = elm->type_selector(td, sptr);
+    if(!selected.presence_index) {
+        ASN__DECODE_FAILED;
+    }
+
+    /* Fetch the pointer to this member */
+    assert(elm->flags == ATF_OPEN_TYPE);
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr2 = (void **)((char *)sptr + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)sptr + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    if(*memb_ptr2 != NULL) {
+        /* Make sure we reset the structure first before encoding */
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2, 0)
+           != 0) {
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    inner_value =
+        (char *)*memb_ptr2
+        + elm->type->elements[selected.presence_index - 1].memb_offset;
+
+    rv = aper_open_type_get(opt_codec_ctx, selected.type_descriptor,
+                            elm->type->elements[selected.presence_index - 1].encoding_constraints.per_constraints,
+                            &inner_value, pd);
+    switch(rv.code) {
+    case RC_OK:
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2,
+                                       selected.presence_index)
+           == 0) {
+            break;
+        } else {
+            rv.code = RC_FAIL;
+        }
+        /* Fall through */
+    case RC_WMORE:
+    case RC_FAIL:
+        if(*memb_ptr2) {
+            if(elm->flags & ATF_POINTER) {
+                ASN_STRUCT_FREE(*selected.type_descriptor, inner_value);
+                *memb_ptr2 = NULL;
+            } else {
+                ASN_STRUCT_RESET(*selected.type_descriptor,
+                                              inner_value);
+            }
+        }
+    }
+    return rv;
+}
+
+asn_enc_rval_t
+OPEN_TYPE_encode_aper(const asn_TYPE_descriptor_t *td,
+                      const asn_per_constraints_t *constraints,
+                      const void *sptr, asn_per_outp_t *po) {
+    const void *memb_ptr;   /* Pointer to the member */
+    asn_TYPE_member_t *elm; /* CHOICE's element */
+    asn_enc_rval_t er = {0,0,0};
+    unsigned present;
+
+    (void)constraints;
+
+    present = CHOICE_variant_get_presence(td, sptr);
+    if(present == 0 || present > td->elements_count) {
+        ASN__ENCODE_FAILED;
+    } else {
+        present--;
+    }
+
+    ASN_DEBUG("Encoding %s OPEN TYPE element %d", td->name, present);
+
+    elm = &td->elements[present];
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        memb_ptr =
+            *(const void *const *)((const char *)sptr + elm->memb_offset);
+        if(!memb_ptr) ASN__ENCODE_FAILED;
+    } else {
+        memb_ptr = (const char *)sptr + elm->memb_offset;
+    }
+
+    if(aper_open_type_put(elm->type, elm->encoding_constraints.per_constraints, memb_ptr, po) < 0) {
+        ASN__ENCODE_FAILED;
+    }
+
+    er.encoded = 0;
+    ASN__ENCODED_OK(er);
+}
+
+
+int OPEN_TYPE_aper_is_unknown_type(const asn_TYPE_descriptor_t *td, void *sptr, const asn_TYPE_member_t *elm) {
+    asn_type_selector_result_t selected;
+
+    if(!elm->type_selector) {
+        return 1;
+    }
+    else {
+        selected = elm->type_selector(td, sptr);
+        if(!selected.presence_index) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+asn_dec_rval_t
+OPEN_TYPE_aper_unknown_type_discard_bytes (asn_per_data_t *pd) {
+#define ASN_DUMMY_BYTES 256
+    unsigned char dummy[ASN_DUMMY_BYTES], *dummy_ptr = NULL;
+    ssize_t bytes;
+    int repeat;
+    asn_dec_rval_t rv;
+
+    rv.consumed = 0;
+    rv.code = RC_FAIL;
+
+    do {
+        bytes = aper_get_length(pd, -1, -1, -1, &repeat);
+        if (bytes > 10 * ASN_DUMMY_BYTES)
+        {
+            return rv;
+        }
+        else if (bytes > ASN_DUMMY_BYTES)
+        {
+            dummy_ptr = CALLOC(1, bytes);
+            if (!dummy_ptr)
+                return rv;
+        }
+
+        per_get_many_bits(pd, (dummy_ptr ? dummy_ptr : dummy), 0, bytes << 3);
+
+        if (dummy_ptr)
+        {
+            FREEMEM(dummy_ptr);
+            dummy_ptr = NULL;
+        }
+    } while (repeat);
+
+     rv.code = RC_OK;
+     return rv;
+#undef ASN_DUMMY_BYTES
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_ber.c
new file mode 100644
index 000000000..a5c39e871
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_ber.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OPEN_TYPE.h"
+#include "constr_CHOICE.h"
+
+asn_dec_rval_t
+OPEN_TYPE_ber_get(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td, void *sptr,
+                  const asn_TYPE_member_t *elm, const void *ptr, size_t size) {
+    size_t consumed_myself = 0;
+    asn_type_selector_result_t selected;
+    void *memb_ptr;   /* Pointer to the member */
+    void **memb_ptr2; /* Pointer to that pointer */
+    void *inner_value;
+    asn_dec_rval_t rv;
+
+    if(!(elm->flags & ATF_OPEN_TYPE)) {
+        ASN__DECODE_FAILED;
+    }
+
+    if(!elm->type_selector) {
+        ASN_DEBUG("Type selector is not defined for Open Type %s->%s->%s",
+                  td->name, elm->name, elm->type->name);
+        ASN__DECODE_FAILED;
+    }
+
+    selected = elm->type_selector(td, sptr);
+    if(!selected.presence_index) {
+        ASN__DECODE_FAILED;
+    }
+
+    /* Fetch the pointer to this member */
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr2 = (void **)((char *)sptr + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)sptr + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    if(*memb_ptr2 != NULL) {
+        /* Make sure we reset the structure first before encoding */
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2, 0) != 0) {
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    inner_value =
+        (char *)*memb_ptr2
+        + elm->type->elements[selected.presence_index - 1].memb_offset;
+
+    ASN_DEBUG("presence %d\n", selected.presence_index);
+
+    rv = selected.type_descriptor->op->ber_decoder(
+        opt_codec_ctx, selected.type_descriptor, &inner_value, ptr, size,
+        elm->tag_mode);
+    ADVANCE(rv.consumed);
+    rv.consumed = 0;
+    switch(rv.code) {
+    case RC_OK:
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2,
+                                       selected.presence_index)
+           == 0) {
+            rv.code = RC_OK;
+            rv.consumed = consumed_myself;
+            return rv;
+        } else {
+            /* Oh, now a full-blown failure failure */
+        }
+        /* Fall through */
+    case RC_FAIL:
+        rv.consumed = consumed_myself;
+        /* Fall through */
+    case RC_WMORE:
+        break;
+    }
+
+    if(*memb_ptr2) {
+        if(elm->flags & ATF_POINTER) {
+            ASN_STRUCT_FREE(*selected.type_descriptor, inner_value);
+            *memb_ptr2 = NULL;
+        } else {
+            ASN_STRUCT_RESET(*selected.type_descriptor,
+                                          inner_value);
+        }
+    }
+    return rv;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_jer.c
new file mode 100644
index 000000000..d209e2de1
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_jer.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OPEN_TYPE.h"
+#include "constr_CHOICE.h"
+
+asn_dec_rval_t
+OPEN_TYPE_jer_get(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td,
+                  void *sptr, const asn_TYPE_member_t *elm, const void *ptr,
+                  size_t size) {
+    size_t consumed_myself = 0;
+    asn_type_selector_result_t selected;
+    void *memb_ptr;   /* Pointer to the member */
+    void **memb_ptr2; /* Pointer to that pointer */
+    void *inner_value;
+    asn_dec_rval_t rv;
+
+    int jer_context = 0;
+    ssize_t ch_size;
+    pjer_chunk_type_e ch_type;
+
+    if(!(elm->flags & ATF_OPEN_TYPE)) {
+        ASN__DECODE_FAILED;
+    }
+
+    if(!elm->type_selector) {
+        ASN_DEBUG("Type selector is not defined for Open Type %s->%s->%s",
+                  td->name, elm->name, elm->type->name);
+        ASN__DECODE_FAILED;
+    }
+
+    selected = elm->type_selector(td, sptr);
+    if(!selected.presence_index) {
+        ASN__DECODE_FAILED;
+    }
+
+    /* Fetch the pointer to this member */
+    assert(elm->flags == ATF_OPEN_TYPE);
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr2 = (void **)((char *)sptr + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)sptr + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    if(*memb_ptr2 != NULL) {
+        /* Make sure we reset the structure first before encoding */
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2, 0)
+           != 0) {
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    /*
+     * Confirm wrapper.
+     */
+    for(;;) {
+        ch_size = jer_next_token(&jer_context, ptr, size, &ch_type);
+        if(ch_size < 0) {
+            ASN__DECODE_FAILED;
+        } else {
+            switch(ch_type) {
+            case PJER_WMORE:
+                ASN__DECODE_STARVED;
+            case PJER_TEXT:
+            case PJER_DLM:
+                ADVANCE(ch_size);
+                continue;
+            case PJER_KEY:
+            default:
+                break;
+            }
+            break;
+        }
+
+    }
+
+    /*
+     * Wrapper value confirmed.
+     */
+    switch(jer_check_sym(ptr, ch_size, NULL)) {
+    case JCK_UNKNOWN:
+        ADVANCE(ch_size);
+        break;
+    case JCK_BROKEN:
+    default:
+        ASN__DECODE_FAILED;
+    }
+
+
+    /* Skip colon */
+    ch_size = jer_next_token(&jer_context, ptr, size, &ch_type);
+    if(ch_size < 0 || ch_type != PJER_TEXT)  {
+        ASN__DECODE_FAILED;
+    } else {
+        ADVANCE(ch_size);
+    }
+
+    inner_value =
+        (char *)*memb_ptr2
+        + elm->type->elements[selected.presence_index - 1].memb_offset;
+
+    rv = selected.type_descriptor->op->jer_decoder(
+        opt_codec_ctx, selected.type_descriptor, selected.type_descriptor->encoding_constraints.jer_constraints,
+        &inner_value, ptr, size);
+    ADVANCE(rv.consumed);
+    rv.consumed = 0;
+    switch(rv.code) {
+    case RC_OK:
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2,
+                                       selected.presence_index)
+           == 0) {
+            break;
+        } else {
+            rv.code = RC_FAIL;
+        }
+        /* Fall through */
+    case RC_FAIL:
+        /* Point to a best position where failure occurred */
+        rv.consumed = consumed_myself;
+        /* Fall through */
+    case RC_WMORE:
+        /* Wrt. rv.consumed==0:
+         * In case a genuine RC_WMORE, the whole Open Type decoding
+         * will have to be restarted.
+         */
+        if(*memb_ptr2) {
+            if(elm->flags & ATF_POINTER) {
+                ASN_STRUCT_FREE(*selected.type_descriptor, inner_value);
+                *memb_ptr2 = NULL;
+            } else {
+                ASN_STRUCT_RESET(*selected.type_descriptor,
+                                              inner_value);
+            }
+        }
+        return rv;
+    }
+
+
+    /*
+     * Finalize wrapper.
+     */
+    for(;;) {
+        ch_size = jer_next_token(&jer_context, ptr, size, &ch_type);
+        if(ch_size < 0) {
+            ASN__DECODE_FAILED;
+        } else {
+            switch(ch_type) {
+            case PJER_WMORE:
+                ASN__DECODE_STARVED;
+            case PJER_TEXT:
+                ADVANCE(ch_size);
+                continue;
+            default:
+                break;
+            }
+            break;
+        }
+    }
+
+    /*
+     * Wrapper value confirmed.
+     */
+    switch(jer_check_sym(ptr, ch_size, NULL)) {
+    case JCK_KEY:
+    case JCK_OEND:
+        ADVANCE(ch_size);
+        break;
+    case JCK_BROKEN:
+    default:
+        ASN__DECODE_FAILED;
+    }
+
+    rv.consumed += consumed_myself;
+
+    return rv;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_oer.c
new file mode 100644
index 000000000..440ed7c24
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_oer.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OPEN_TYPE.h"
+#include "constr_CHOICE.h"
+
+asn_dec_rval_t
+OPEN_TYPE_oer_get(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td, void *sptr,
+                  asn_TYPE_member_t *elm, const void *ptr, size_t size) {
+    asn_type_selector_result_t selected;
+    void *memb_ptr;   /* Pointer to the member */
+    void **memb_ptr2; /* Pointer to that pointer */
+    void *inner_value;
+    asn_dec_rval_t rv;
+    size_t ot_ret;
+
+
+    if(!(elm->flags & ATF_OPEN_TYPE)) {
+        ASN__DECODE_FAILED;
+    }
+
+    if(!elm->type_selector) {
+        ASN_DEBUG("Type selector is not defined for Open Type %s->%s->%s",
+                  td->name, elm->name, elm->type->name);
+        ASN__DECODE_FAILED;
+    }
+
+    selected = elm->type_selector(td, sptr);
+    if(!selected.presence_index) {
+        ASN__DECODE_FAILED;
+    }
+
+    /* Fetch the pointer to this member */
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr2 = (void **)((char *)sptr + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)sptr + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    if(*memb_ptr2 != NULL) {
+        /* Make sure we reset the structure first before encoding */
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2, 0) != 0) {
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    inner_value =
+        (char *)*memb_ptr2
+        + elm->type->elements[selected.presence_index - 1].memb_offset;
+
+    ot_ret = oer_open_type_get(opt_codec_ctx, selected.type_descriptor, NULL,
+                               &inner_value, ptr, size);
+    switch(ot_ret) {
+    default:
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2,
+                                       selected.presence_index)
+           == 0) {
+            rv.code = RC_OK;
+            rv.consumed = ot_ret;
+            return rv;
+        } else {
+            /* Oh, now a full-blown failure failure */
+        }
+        /* Fall through */
+    case -1:
+        rv.code = RC_FAIL;
+        rv.consumed = ot_ret;
+        break;
+    case 0:
+        rv.code = RC_WMORE;
+        rv.consumed = 0;
+        break;
+    }
+
+    if(*memb_ptr2) {
+        const asn_CHOICE_specifics_t *specs =
+            selected.type_descriptor->specifics;
+        if(elm->flags & ATF_POINTER) {
+            ASN_STRUCT_FREE(*selected.type_descriptor, inner_value);
+            *memb_ptr2 = NULL;
+        } else {
+            ASN_STRUCT_FREE_CONTENTS_ONLY(*selected.type_descriptor,
+                                          inner_value);
+            memset(*memb_ptr2, 0, specs->struct_size);
+        }
+    }
+    return rv;
+}
+
+asn_enc_rval_t
+OPEN_TYPE_encode_oer(const asn_TYPE_descriptor_t *td,
+                  const asn_oer_constraints_t *constraints, const void *sptr,
+                  asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_TYPE_member_t *elm;
+    unsigned present;
+    const void *memb_ptr;
+    ssize_t encoded;
+    asn_enc_rval_t er = {0, 0, 0};
+
+    (void)constraints;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    present = CHOICE_variant_get_presence(td, sptr);
+    if(present == 0 || present > td->elements_count) {
+        ASN__ENCODE_FAILED;
+    } else {
+        present--;
+    }
+
+    ASN_DEBUG("Encoding %s OPEN TYPE element %d", td->name, present);
+
+    elm = &td->elements[present];
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr =
+            *(const void *const *)((const char *)sptr + elm->memb_offset);
+        if(memb_ptr == 0) {
+            /* Mandatory element absent */
+            ASN__ENCODE_FAILED;
+        }
+    } else {
+        memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+    }
+
+    if((encoded = oer_open_type_put(elm->type,
+                          elm->encoding_constraints.oer_constraints,
+                          memb_ptr, cb, app_key)) < 0) {
+        ASN__ENCODE_FAILED;
+    }
+
+    er.encoded = encoded;
+    ASN__ENCODED_OK(er);
+
+    return er;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_uper.c
new file mode 100644
index 000000000..80527a90f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_uper.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OPEN_TYPE.h"
+#include "constr_CHOICE.h"
+#include "uper_opentype.h"
+
+asn_dec_rval_t
+OPEN_TYPE_uper_get(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td, void *sptr,
+                   const asn_TYPE_member_t *elm, asn_per_data_t *pd) {
+    asn_type_selector_result_t selected;
+    void *memb_ptr;   /* Pointer to the member */
+    void **memb_ptr2; /* Pointer to that pointer */
+    void *inner_value;
+    asn_dec_rval_t rv;
+
+    if(!(elm->flags & ATF_OPEN_TYPE)) {
+        ASN__DECODE_FAILED;
+    }
+
+    if(!elm->type_selector) {
+        ASN_DEBUG("Type selector is not defined for Open Type %s->%s->%s",
+                  td->name, elm->name, elm->type->name);
+        ASN__DECODE_FAILED;
+    }
+
+    selected = elm->type_selector(td, sptr);
+    if(!selected.presence_index) {
+        ASN__DECODE_FAILED;
+    }
+
+    /* Fetch the pointer to this member */
+    assert(elm->flags == ATF_OPEN_TYPE);
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr2 = (void **)((char *)sptr + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)sptr + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    if(*memb_ptr2 != NULL) {
+        /* Make sure we reset the structure first before encoding */
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2, 0)
+           != 0) {
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    inner_value =
+        (char *)*memb_ptr2
+        + elm->type->elements[selected.presence_index - 1].memb_offset;
+
+    rv = uper_open_type_get(opt_codec_ctx, selected.type_descriptor,
+                            elm->type->elements[selected.presence_index - 1].encoding_constraints.per_constraints,
+                            &inner_value, pd);
+    switch(rv.code) {
+    case RC_OK:
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2,
+                                       selected.presence_index)
+           == 0) {
+            break;
+        } else {
+            rv.code = RC_FAIL;
+        }
+        /* Fall through */
+    case RC_WMORE:
+    case RC_FAIL:
+        if(*memb_ptr2) {
+            if(elm->flags & ATF_POINTER) {
+                ASN_STRUCT_FREE(*selected.type_descriptor, inner_value);
+                *memb_ptr2 = NULL;
+            } else {
+                ASN_STRUCT_RESET(*selected.type_descriptor,
+                                              inner_value);
+            }
+        }
+    }
+    return rv;
+}
+
+asn_enc_rval_t
+OPEN_TYPE_encode_uper(const asn_TYPE_descriptor_t *td,
+                      const asn_per_constraints_t *constraints,
+                      const void *sptr, asn_per_outp_t *po) {
+    const void *memb_ptr;   /* Pointer to the member */
+    asn_TYPE_member_t *elm; /* CHOICE's element */
+    asn_enc_rval_t er = {0,0,0};
+    unsigned present;
+
+    (void)constraints;
+
+    present = CHOICE_variant_get_presence(td, sptr);
+    if(present == 0 || present > td->elements_count) {
+        ASN__ENCODE_FAILED;
+    } else {
+        present--;
+    }
+
+    ASN_DEBUG("Encoding %s OPEN TYPE element %d", td->name, present);
+
+    elm = &td->elements[present];
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        memb_ptr =
+            *(const void *const *)((const char *)sptr + elm->memb_offset);
+        if(!memb_ptr) ASN__ENCODE_FAILED;
+    } else {
+        memb_ptr = (const char *)sptr + elm->memb_offset;
+    }
+
+    if(uper_open_type_put(elm->type,
+                          elm->encoding_constraints.per_constraints,
+                          memb_ptr, po) < 0) {
+        ASN__ENCODE_FAILED;
+    }
+
+    er.encoded = 0;
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_xer.c
new file mode 100644
index 000000000..d3430a974
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/OPEN_TYPE_xer.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "OPEN_TYPE.h"
+#include "constr_CHOICE.h"
+
+asn_dec_rval_t
+OPEN_TYPE_xer_get(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td, void *sptr,
+                  const asn_TYPE_member_t *elm, const void *ptr, size_t size) {
+    size_t consumed_myself = 0;
+    asn_type_selector_result_t selected;
+    void *memb_ptr;   /* Pointer to the member */
+    void **memb_ptr2; /* Pointer to that pointer */
+    void *inner_value;
+    asn_dec_rval_t rv;
+
+    int xer_context = 0;
+    ssize_t ch_size;
+    pxer_chunk_type_e ch_type;
+
+    if(!(elm->flags & ATF_OPEN_TYPE)) {
+        ASN__DECODE_FAILED;
+    }
+
+    if(!elm->type_selector) {
+        ASN_DEBUG("Type selector is not defined for Open Type %s->%s->%s",
+                  td->name, elm->name, elm->type->name);
+        ASN__DECODE_FAILED;
+    }
+
+    selected = elm->type_selector(td, sptr);
+    if(!selected.presence_index) {
+        ASN__DECODE_FAILED;
+    }
+
+    /* Fetch the pointer to this member */
+    assert(elm->flags == ATF_OPEN_TYPE);
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr2 = (void **)((char *)sptr + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)sptr + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    if(*memb_ptr2 != NULL) {
+        /* Make sure we reset the structure first before encoding */
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2, 0)
+           != 0) {
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    /*
+     * Confirm wrapper.
+     */
+    for(;;) {
+        ch_size = xer_next_token(&xer_context, ptr, size, &ch_type);
+        if(ch_size < 0) {
+            ASN__DECODE_FAILED;
+        } else {
+            switch(ch_type) {
+            case PXER_WMORE:
+                ASN__DECODE_STARVED;
+            case PXER_COMMENT:
+            case PXER_TEXT:
+                ADVANCE(ch_size);
+                continue;
+            case PXER_TAG:
+                break;
+            }
+            break;
+        }
+    }
+
+    /*
+     * Wrapper value confirmed.
+     */
+    switch(xer_check_tag(ptr, ch_size, elm->name)) {
+    case XCT_OPENING:
+        ADVANCE(ch_size);
+        break;
+    case XCT_BROKEN:
+    default:
+        ASN__DECODE_FAILED;
+    }
+
+    inner_value =
+        (char *)*memb_ptr2
+        + elm->type->elements[selected.presence_index - 1].memb_offset;
+
+    rv = selected.type_descriptor->op->xer_decoder(
+        opt_codec_ctx, selected.type_descriptor, &inner_value, NULL, ptr, size);
+    ADVANCE(rv.consumed);
+    rv.consumed = 0;
+    switch(rv.code) {
+    case RC_OK:
+        if(CHOICE_variant_set_presence(elm->type, *memb_ptr2,
+                                       selected.presence_index)
+           == 0) {
+            break;
+        } else {
+            rv.code = RC_FAIL;
+        }
+        /* Fall through */
+    case RC_FAIL:
+        /* Point to a best position where failure occurred */
+        rv.consumed = consumed_myself;
+        /* Fall through */
+    case RC_WMORE:
+        /* Wrt. rv.consumed==0:
+         * In case a genuine RC_WMORE, the whole Open Type decoding
+         * will have to be restarted.
+         */
+        if(*memb_ptr2) {
+            if(elm->flags & ATF_POINTER) {
+                ASN_STRUCT_FREE(*selected.type_descriptor, inner_value);
+                *memb_ptr2 = NULL;
+            } else {
+                ASN_STRUCT_RESET(*selected.type_descriptor,
+                                              inner_value);
+            }
+        }
+        return rv;
+    }
+
+    /*
+     * Finalize wrapper.
+     */
+    for(;;) {
+        ch_size = xer_next_token(&xer_context, ptr, size, &ch_type);
+        if(ch_size < 0) {
+            ASN__DECODE_FAILED;
+        } else {
+            switch(ch_type) {
+            case PXER_WMORE:
+                ASN__DECODE_STARVED;
+            case PXER_COMMENT:
+            case PXER_TEXT:
+                ADVANCE(ch_size);
+                continue;
+            case PXER_TAG:
+                break;
+            }
+            break;
+        }
+    }
+
+    /*
+     * Wrapper value confirmed.
+     */
+    switch(xer_check_tag(ptr, ch_size, elm->name)) {
+    case XCT_CLOSING:
+        ADVANCE(ch_size);
+        break;
+    case XCT_BROKEN:
+    default:
+        ASN__DECODE_FAILED;
+    }
+
+    rv.consumed += consumed_myself;
+
+    return rv;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ObjectDescriptor.c /ext/source/modules/EVSE/EvseV2G/asn1/ObjectDescriptor.c
new file mode 100644
index 000000000..7a73bf586
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ObjectDescriptor.c
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ObjectDescriptor.h"
+
+/*
+ * ObjectDescriptor basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_ObjectDescriptor_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (7 << 2)),  /* [UNIVERSAL 7] IMPLICIT ... */
+    (ASN_TAG_CLASS_UNIVERSAL | (4 << 2))   /* ... OCTET STRING */
+};
+asn_TYPE_operation_t asn_OP_ObjectDescriptor = {
+    OCTET_STRING_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    OCTET_STRING_print_utf8,  /* Treat as ASCII subset (it's not) */
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    OCTET_STRING_compare,
+    OCTET_STRING_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    OCTET_STRING_decode_ber,  /* Implemented in terms of OCTET STRING */
+    OCTET_STRING_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OCTET_STRING_decode_xer_utf8,
+    OCTET_STRING_encode_xer_utf8,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    OCTET_STRING_decode_jer_utf8,
+    OCTET_STRING_encode_jer_utf8,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    0,
+    0,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    OCTET_STRING_decode_uper,
+    OCTET_STRING_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    OCTET_STRING_decode_aper,
+    OCTET_STRING_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    0,  /* Not supported for ObjectDescriptor */
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_ObjectDescriptor = {
+    "ObjectDescriptor",
+    "ObjectDescriptor",
+    &asn_OP_ObjectDescriptor,
+    asn_DEF_ObjectDescriptor_tags,
+    sizeof(asn_DEF_ObjectDescriptor_tags)
+      / sizeof(asn_DEF_ObjectDescriptor_tags[0]) - 1,
+    asn_DEF_ObjectDescriptor_tags,
+    sizeof(asn_DEF_ObjectDescriptor_tags)
+      / sizeof(asn_DEF_ObjectDescriptor_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        asn_generic_unknown_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ObjectDescriptor.h /ext/source/modules/EVSE/EvseV2G/asn1/ObjectDescriptor.h
new file mode 100644
index 000000000..4c6924913
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ObjectDescriptor.h
@@ -0,0 +1,55 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_ObjectDescriptor_H_
+#define	_ObjectDescriptor_H_
+
+#include "GraphicString.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef GraphicString_t ObjectDescriptor_t;  /* Implemented via GraphicString */
+
+extern asn_TYPE_descriptor_t asn_DEF_ObjectDescriptor;
+extern asn_TYPE_operation_t asn_OP_ObjectDescriptor;
+
+#define ObjectDescriptor_free OCTET_STRING_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+#define ObjectDescriptor_print OCTET_STRING_print_utf8
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define ObjectDescriptor_constraint asn_generic_unknown_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define ObjectDescriptor_decode_ber OCTET_STRING_decode_ber
+#define ObjectDescriptor_encode_der OCTET_STRING_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define ObjectDescriptor_decode_xer OCTET_STRING_decode_xer_utf8
+#define ObjectDescriptor_encode_xer OCTET_STRING_encode_xer_utf8
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+#define ObjectDescriptor_decode_jer OCTET_STRING_decode_jer_utf8
+#define ObjectDescriptor_encode_jer OCTET_STRING_encode_jer_utf8
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+#define ObjectDescriptor_decode_uper OCTET_STRING_decode_uper
+#define ObjectDescriptor_encode_uper OCTET_STRING_encode_uper
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+#define ObjectDescriptor_decode_aper OCTET_STRING_decode_aper
+#define ObjectDescriptor_encode_aper OCTET_STRING_encode_aper
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _ObjectDescriptor_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfile.c /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfile.c
new file mode 100644
index 000000000..fa127c4b4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfile.c
@@ -0,0 +1,73 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "SecurityProfile.h"
+
+/*
+ * This type is implemented using NativeEnumerated,
+ * so here we adjust the DEF accordingly.
+ */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_SecurityProfile_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_SecurityProfile_constr_1 CC_NOTUSED = {
+	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static const asn_INTEGER_enum_map_t asn_MAP_SecurityProfile_value2enum_1[] = {
+	{ 0,	7,	"tcpOnly" },
+	{ 2,	12,	"tls12-server" },
+	{ 20,	12,	"tls13-mutual" }
+};
+static const unsigned int asn_MAP_SecurityProfile_enum2value_1[] = {
+	0,	/* tcpOnly(0) */
+	1,	/* tls12-server(2) */
+	2	/* tls13-mutual(20) */
+};
+const asn_INTEGER_specifics_t asn_SPC_SecurityProfile_specs_1 = {
+	asn_MAP_SecurityProfile_value2enum_1,	/* "tag" => N; sorted by tag */
+	asn_MAP_SecurityProfile_enum2value_1,	/* N => "tag"; sorted by N */
+	3,	/* Number of elements in the maps */
+	0,	/* Enumeration is not extensible */
+	1,	/* Strict enumeration */
+	0,	/* Native long size */
+	0
+};
+static const ber_tlv_tag_t asn_DEF_SecurityProfile_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
+};
+asn_TYPE_descriptor_t asn_DEF_SecurityProfile = {
+	"SecurityProfile",
+	"SecurityProfile",
+	&asn_OP_NativeEnumerated,
+	asn_DEF_SecurityProfile_tags_1,
+	sizeof(asn_DEF_SecurityProfile_tags_1)
+		/sizeof(asn_DEF_SecurityProfile_tags_1[0]), /* 1 */
+	asn_DEF_SecurityProfile_tags_1,	/* Same as above */
+	sizeof(asn_DEF_SecurityProfile_tags_1)
+		/sizeof(asn_DEF_SecurityProfile_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_SecurityProfile_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_SecurityProfile_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		NativeEnumerated_constraint
+	},
+	0, 0,	/* Defined elsewhere */
+	&asn_SPC_SecurityProfile_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfile.h /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfile.h
new file mode 100644
index 000000000..b35e8fb35
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfile.h
@@ -0,0 +1,55 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_SecurityProfile_H_
+#define	_SecurityProfile_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeEnumerated.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Dependencies */
+typedef enum SecurityProfile {
+	SecurityProfile_tcpOnly	= 0,
+	SecurityProfile_tls12_server	= 2,
+	SecurityProfile_tls13_mutual	= 20
+} e_SecurityProfile;
+
+/* SecurityProfile */
+typedef long	 SecurityProfile_t;
+
+/* Implementation */
+extern asn_per_constraints_t asn_PER_type_SecurityProfile_constr_1;
+extern asn_TYPE_descriptor_t asn_DEF_SecurityProfile;
+extern const asn_INTEGER_specifics_t asn_SPC_SecurityProfile_specs_1;
+asn_struct_free_f SecurityProfile_free;
+asn_struct_print_f SecurityProfile_print;
+asn_constr_check_f SecurityProfile_constraint;
+ber_type_decoder_f SecurityProfile_decode_ber;
+der_type_encoder_f SecurityProfile_encode_der;
+xer_type_decoder_f SecurityProfile_decode_xer;
+xer_type_encoder_f SecurityProfile_encode_xer;
+jer_type_encoder_f SecurityProfile_encode_jer;
+oer_type_decoder_f SecurityProfile_decode_oer;
+oer_type_encoder_f SecurityProfile_encode_oer;
+per_type_decoder_f SecurityProfile_decode_uper;
+per_type_encoder_f SecurityProfile_encode_uper;
+per_type_decoder_f SecurityProfile_decode_aper;
+per_type_encoder_f SecurityProfile_encode_aper;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _SecurityProfile_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfileTuple.c /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfileTuple.c
new file mode 100644
index 000000000..64ecf64bb
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfileTuple.c
@@ -0,0 +1,330 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "SecurityProfileTuple.h"
+
+static int
+memb_authorizationMethod_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	/* Determine the number of elements */
+	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
+	
+	if((size >= 1UL)) {
+		/* Perform validation of the inner elements */
+		return SEQUENCE_OF_constraint(td, sptr, ctfailcb, app_key);
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+static int
+memb_energyTransferMode_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
+			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+	size_t size;
+	
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+	
+	/* Determine the number of elements */
+	size = _A_CSEQUENCE_FROM_VOID(sptr)->count;
+	
+	if((size >= 1UL)) {
+		/* Perform validation of the inner elements */
+		return SEQUENCE_OF_constraint(td, sptr, ctfailcb, app_key);
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: constraint failed (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_authorizationMethod_constr_3 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_authorizationMethod_constr_3 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_energyTransferMode_constr_5 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_type_energyTransferMode_constr_5 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_authorizationMethod_constr_3 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_authorizationMethod_constr_3 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_memb_energyTransferMode_constr_5 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+static asn_per_constraints_t asn_PER_memb_energyTransferMode_constr_5 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+static asn_TYPE_member_t asn_MBR_authorizationMethod_3[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
+		0,
+		&asn_DEF_AuthorizationMethod,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_authorizationMethod_tags_3[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static asn_SET_OF_specifics_t asn_SPC_authorizationMethod_specs_3 = {
+	sizeof(struct authorizationMethod),
+	offsetof(struct authorizationMethod, _asn_ctx),
+	1,	/* XER encoding is XMLValueList */
+};
+static /* Use -fall-defs-global to expose */
+asn_TYPE_descriptor_t asn_DEF_authorizationMethod_3 = {
+	"authorizationMethod",
+	"authorizationMethod",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_authorizationMethod_tags_3,
+	sizeof(asn_DEF_authorizationMethod_tags_3)
+		/sizeof(asn_DEF_authorizationMethod_tags_3[0]), /* 1 */
+	asn_DEF_authorizationMethod_tags_3,	/* Same as above */
+	sizeof(asn_DEF_authorizationMethod_tags_3)
+		/sizeof(asn_DEF_authorizationMethod_tags_3[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_authorizationMethod_constr_3,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_authorizationMethod_constr_3,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_authorizationMethod_3,
+	1,	/* Single element */
+	&asn_SPC_authorizationMethod_specs_3	/* Additional specs */
+};
+
+static asn_TYPE_member_t asn_MBR_energyTransferMode_5[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
+		0,
+		&asn_DEF_EnergyTransferMode,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_energyTransferMode_tags_5[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static asn_SET_OF_specifics_t asn_SPC_energyTransferMode_specs_5 = {
+	sizeof(struct energyTransferMode),
+	offsetof(struct energyTransferMode, _asn_ctx),
+	1,	/* XER encoding is XMLValueList */
+};
+static /* Use -fall-defs-global to expose */
+asn_TYPE_descriptor_t asn_DEF_energyTransferMode_5 = {
+	"energyTransferMode",
+	"energyTransferMode",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_energyTransferMode_tags_5,
+	sizeof(asn_DEF_energyTransferMode_tags_5)
+		/sizeof(asn_DEF_energyTransferMode_tags_5[0]), /* 1 */
+	asn_DEF_energyTransferMode_tags_5,	/* Same as above */
+	sizeof(asn_DEF_energyTransferMode_tags_5)
+		/sizeof(asn_DEF_energyTransferMode_tags_5[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_energyTransferMode_constr_5,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_energyTransferMode_constr_5,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_energyTransferMode_5,
+	1,	/* Single element */
+	&asn_SPC_energyTransferMode_specs_5	/* Additional specs */
+};
+
+asn_TYPE_member_t asn_MBR_SecurityProfileTuple_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct SecurityProfileTuple, securityProfile),
+		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
+		0,
+		&asn_DEF_SecurityProfile,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"securityProfile"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct SecurityProfileTuple, authorizationMethod),
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_authorizationMethod_3,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_authorizationMethod_constr_3,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_authorizationMethod_constr_3,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_authorizationMethod_constraint_1
+		},
+		0, 0, /* No default value */
+		"authorizationMethod"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct SecurityProfileTuple, energyTransferMode),
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_energyTransferMode_5,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			&asn_OER_memb_energyTransferMode_constr_5,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			&asn_PER_memb_energyTransferMode_constr_5,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			memb_energyTransferMode_constraint_1
+		},
+		0, 0, /* No default value */
+		"energyTransferMode"
+		},
+};
+static const ber_tlv_tag_t asn_DEF_SecurityProfileTuple_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_SecurityProfileTuple_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 0, 0, 0 }, /* securityProfile */
+    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0, 1 }, /* authorizationMethod */
+    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, -1, 0 } /* energyTransferMode */
+};
+asn_SEQUENCE_specifics_t asn_SPC_SecurityProfileTuple_specs_1 = {
+	sizeof(struct SecurityProfileTuple),
+	offsetof(struct SecurityProfileTuple, _asn_ctx),
+	asn_MAP_SecurityProfileTuple_tag2el_1,
+	3,	/* Count of tags in the map */
+	0, 0, 0,	/* Optional elements (not needed) */
+	3,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_SecurityProfileTuple = {
+	"SecurityProfileTuple",
+	"SecurityProfileTuple",
+	&asn_OP_SEQUENCE,
+	asn_DEF_SecurityProfileTuple_tags_1,
+	sizeof(asn_DEF_SecurityProfileTuple_tags_1)
+		/sizeof(asn_DEF_SecurityProfileTuple_tags_1[0]), /* 1 */
+	asn_DEF_SecurityProfileTuple_tags_1,	/* Same as above */
+	sizeof(asn_DEF_SecurityProfileTuple_tags_1)
+		/sizeof(asn_DEF_SecurityProfileTuple_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_SecurityProfileTuple_1,
+	3,	/* Elements count */
+	&asn_SPC_SecurityProfileTuple_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfileTuple.h /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfileTuple.h
new file mode 100644
index 000000000..487015863
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/SecurityProfileTuple.h
@@ -0,0 +1,60 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_SecurityProfileTuple_H_
+#define	_SecurityProfileTuple_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "SecurityProfile.h"
+#include "AuthorizationMethod.h"
+#include "asn_SEQUENCE_OF.h"
+#include "constr_SEQUENCE_OF.h"
+#include "EnergyTransferMode.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* SecurityProfileTuple */
+typedef struct SecurityProfileTuple {
+	SecurityProfile_t	 securityProfile;
+	struct authorizationMethod {
+		A_SEQUENCE_OF(AuthorizationMethod_t) list;
+		
+		/* Context for parsing across buffer boundaries */
+		asn_struct_ctx_t _asn_ctx;
+	} authorizationMethod;
+	struct energyTransferMode {
+		A_SEQUENCE_OF(EnergyTransferMode_t) list;
+		
+		/* Context for parsing across buffer boundaries */
+		asn_struct_ctx_t _asn_ctx;
+	} energyTransferMode;
+	/*
+	 * This type is extensible,
+	 * possible extensions are below.
+	 */
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} SecurityProfileTuple_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_SecurityProfileTuple;
+extern asn_SEQUENCE_specifics_t asn_SPC_SecurityProfileTuple_specs_1;
+extern asn_TYPE_member_t asn_MBR_SecurityProfileTuple_1[3];
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _SecurityProfileTuple_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtension.c /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtension.c
new file mode 100644
index 000000000..ba273c78f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtension.c
@@ -0,0 +1,93 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "StandardizedExtension.h"
+
+asn_TYPE_member_t asn_MBR_StandardizedExtension_1[] = {
+	{ ATF_NOFLAGS, 0, offsetof(struct StandardizedExtension, extensionID),
+		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
+		0,
+		&asn_DEF_NativeInteger,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"extensionID"
+		},
+	{ ATF_NOFLAGS, 0, offsetof(struct StandardizedExtension, extensionValue),
+		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
+		0,
+		&asn_DEF_OCTET_STRING,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		"extensionValue"
+		},
+};
+static const ber_tlv_tag_t asn_DEF_StandardizedExtension_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+static const asn_TYPE_tag2member_t asn_MAP_StandardizedExtension_tag2el_1[] = {
+    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* extensionID */
+    { (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)), 1, 0, 0 } /* extensionValue */
+};
+asn_SEQUENCE_specifics_t asn_SPC_StandardizedExtension_specs_1 = {
+	sizeof(struct StandardizedExtension),
+	offsetof(struct StandardizedExtension, _asn_ctx),
+	asn_MAP_StandardizedExtension_tag2el_1,
+	2,	/* Count of tags in the map */
+	0, 0, 0,	/* Optional elements (not needed) */
+	-1,	/* First extension addition */
+};
+asn_TYPE_descriptor_t asn_DEF_StandardizedExtension = {
+	"StandardizedExtension",
+	"StandardizedExtension",
+	&asn_OP_SEQUENCE,
+	asn_DEF_StandardizedExtension_tags_1,
+	sizeof(asn_DEF_StandardizedExtension_tags_1)
+		/sizeof(asn_DEF_StandardizedExtension_tags_1[0]), /* 1 */
+	asn_DEF_StandardizedExtension_tags_1,	/* Same as above */
+	sizeof(asn_DEF_StandardizedExtension_tags_1)
+		/sizeof(asn_DEF_StandardizedExtension_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_constraint
+	},
+	asn_MBR_StandardizedExtension_1,
+	2,	/* Elements count */
+	&asn_SPC_StandardizedExtension_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtension.h /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtension.h
new file mode 100644
index 000000000..7faa5957c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtension.h
@@ -0,0 +1,42 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_StandardizedExtension_H_
+#define	_StandardizedExtension_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "NativeInteger.h"
+#include "OCTET_STRING.h"
+#include "constr_SEQUENCE.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* StandardizedExtension */
+typedef struct StandardizedExtension {
+	long	 extensionID;
+	OCTET_STRING_t	 extensionValue;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} StandardizedExtension_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_StandardizedExtension;
+extern asn_SEQUENCE_specifics_t asn_SPC_StandardizedExtension_specs_1;
+extern asn_TYPE_member_t asn_MBR_StandardizedExtension_1[2];
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _StandardizedExtension_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtensions.c /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtensions.c
new file mode 100644
index 000000000..c360d3036
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtensions.c
@@ -0,0 +1,78 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#include "StandardizedExtensions.h"
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+static asn_oer_constraints_t asn_OER_type_StandardizedExtensions_constr_1 CC_NOTUSED = {
+	{ 0, 0 },
+	-1	/* (SIZE(1..MAX)) */};
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+asn_per_constraints_t asn_PER_type_StandardizedExtensions_constr_1 CC_NOTUSED = {
+	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
+	{ APC_SEMI_CONSTRAINED,	-1, -1,  1,  0 }	/* (SIZE(1..MAX)) */,
+	0, 0	/* No PER value map */
+};
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+asn_TYPE_member_t asn_MBR_StandardizedExtensions_1[] = {
+	{ ATF_POINTER, 0, 0,
+		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
+		0,
+		&asn_DEF_StandardizedExtension,
+		0,
+		{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+			0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+			0
+		},
+		0, 0, /* No default value */
+		""
+		},
+};
+static const ber_tlv_tag_t asn_DEF_StandardizedExtensions_tags_1[] = {
+	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
+};
+asn_SET_OF_specifics_t asn_SPC_StandardizedExtensions_specs_1 = {
+	sizeof(struct StandardizedExtensions),
+	offsetof(struct StandardizedExtensions, _asn_ctx),
+	0,	/* XER encoding is XMLDelimitedItemList */
+};
+asn_TYPE_descriptor_t asn_DEF_StandardizedExtensions = {
+	"StandardizedExtensions",
+	"StandardizedExtensions",
+	&asn_OP_SEQUENCE_OF,
+	asn_DEF_StandardizedExtensions_tags_1,
+	sizeof(asn_DEF_StandardizedExtensions_tags_1)
+		/sizeof(asn_DEF_StandardizedExtensions_tags_1[0]), /* 1 */
+	asn_DEF_StandardizedExtensions_tags_1,	/* Same as above */
+	sizeof(asn_DEF_StandardizedExtensions_tags_1)
+		/sizeof(asn_DEF_StandardizedExtensions_tags_1[0]), /* 1 */
+	{
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+		&asn_OER_type_StandardizedExtensions_constr_1,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+		&asn_PER_type_StandardizedExtensions_constr_1,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+		0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+		SEQUENCE_OF_constraint
+	},
+	asn_MBR_StandardizedExtensions_1,
+	1,	/* Single element */
+	&asn_SPC_StandardizedExtensions_specs_1	/* Additional specs */
+};
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtensions.h /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtensions.h
new file mode 100644
index 000000000..62e23a107
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/StandardizedExtensions.h
@@ -0,0 +1,47 @@
+/*
+ * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
+ * From ASN.1 module "ISO15118-200"
+ * 	found in "esdp_extensions_new.asn"
+ * 	`asn1c -no-gen-example`
+ */
+
+#ifndef	_StandardizedExtensions_H_
+#define	_StandardizedExtensions_H_
+
+
+#include "asn_application.h"
+
+/* Including external dependencies */
+#include "asn_SEQUENCE_OF.h"
+#include "constr_SEQUENCE_OF.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Forward declarations */
+struct StandardizedExtension;
+
+/* StandardizedExtensions */
+typedef struct StandardizedExtensions {
+	A_SEQUENCE_OF(struct StandardizedExtension) list;
+	
+	/* Context for parsing across buffer boundaries */
+	asn_struct_ctx_t _asn_ctx;
+} StandardizedExtensions_t;
+
+/* Implementation */
+extern asn_TYPE_descriptor_t asn_DEF_StandardizedExtensions;
+extern asn_SET_OF_specifics_t asn_SPC_StandardizedExtensions_specs_1;
+extern asn_TYPE_member_t asn_MBR_StandardizedExtensions_1[1];
+extern asn_per_constraints_t asn_PER_type_StandardizedExtensions_constr_1;
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Referred external types */
+#include "StandardizedExtension.h"
+
+#endif	/* _StandardizedExtensions_H_ */
+#include "asn_internal.h"
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String.c /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String.c
new file mode 100644
index 000000000..37760250e
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String.c
@@ -0,0 +1,230 @@
+/*-
+ * Copyright (c) 2003, 2004, 2006 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "UTF8String.h"
+
+/*
+ * UTF8String basic type description.
+ */
+static const ber_tlv_tag_t asn_DEF_UTF8String_tags[] = {
+    (ASN_TAG_CLASS_UNIVERSAL | (12 << 2)),  /* [UNIVERSAL 12] IMPLICIT ...*/
+    (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),   /* ... OCTET STRING */
+};
+asn_TYPE_operation_t asn_OP_UTF8String = {
+    OCTET_STRING_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    UTF8String_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    OCTET_STRING_compare,
+    OCTET_STRING_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    OCTET_STRING_decode_ber,  /* Implemented in terms of OCTET STRING */
+    OCTET_STRING_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    OCTET_STRING_decode_xer_utf8,
+    OCTET_STRING_encode_xer_utf8,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    OCTET_STRING_decode_jer_utf8,
+    OCTET_STRING_encode_jer_utf8,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    OCTET_STRING_decode_oer,
+    OCTET_STRING_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    OCTET_STRING_decode_uper,
+    OCTET_STRING_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    OCTET_STRING_decode_aper,
+    OCTET_STRING_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    UTF8String_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+asn_TYPE_descriptor_t asn_DEF_UTF8String = {
+    "UTF8String",
+    "UTF8String",
+    &asn_OP_UTF8String,
+    asn_DEF_UTF8String_tags,
+    sizeof(asn_DEF_UTF8String_tags)
+      / sizeof(asn_DEF_UTF8String_tags[0]) - 1,
+    asn_DEF_UTF8String_tags,
+    sizeof(asn_DEF_UTF8String_tags)
+      / sizeof(asn_DEF_UTF8String_tags[0]),
+    {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+        UTF8String_constraint
+    },
+    0, 0,  /* No members */
+    0  /* No specifics */
+};
+
+/*
+ * This is the table of length expectations.
+ * The second half of this table is only applicable to the long sequences.
+ */
+static const int UTF8String_ht[2][16] = {
+	{ /* 0x0 ... 0x7 */
+	  /* 0000..0111 */
+	  1, 1, 1, 1, 1, 1, 1, 1,
+	  /* 1000..1011(0), 1100..1101(2), 1110(3), 1111(-1) */
+	  0, 0, 0, 0, 2, 2, 3, -1 },
+	{ /* 0xF0 .. 0xF7 */
+	  /* 11110000..11110111 */
+	  4, 4, 4, 4, 4, 4, 4, 4,
+	  5, 5, 5, 5, 6, 6, -1, -1 }
+};
+static const int32_t UTF8String_mv[7] = { 0, 0,
+	0x00000080,
+	0x00000800,
+	0x00010000,
+	0x00200000,
+	0x04000000
+};
+
+/* Internal aliases for return codes */
+#define	U8E_TRUNC	-1	/* UTF-8 sequence truncated */
+#define	U8E_ILLSTART	-2	/* Illegal UTF-8 sequence start */
+#define	U8E_NOTCONT	-3	/* Continuation expectation failed */
+#define	U8E_NOTMIN	-4	/* Not minimal length encoding */
+#define	U8E_EINVAL	-5	/* Invalid arguments */
+
+int
+UTF8String_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
+                      asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+    ssize_t len = UTF8String_length((const UTF8String_t *)sptr);
+	switch(len) {
+	case U8E_EINVAL:
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given", td->name);
+		break;
+	case U8E_TRUNC:
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: truncated UTF-8 sequence (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		break;
+	case U8E_ILLSTART:
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: UTF-8 illegal start of encoding (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		break;
+	case U8E_NOTCONT:
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: UTF-8 not continuation (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		break;
+	case U8E_NOTMIN:
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: UTF-8 not minimal sequence (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		break;
+	}
+	return (len < 0) ? -1 : 0;
+}
+
+static ssize_t
+UTF8String__process(const UTF8String_t *st, uint32_t *dst, size_t dstlen) {
+	size_t length = 0;
+	uint8_t *buf = (st == NULL)? NULL : st->buf;
+	uint8_t *end = (buf == NULL)? NULL : buf + st->size;
+	uint32_t *dstend = (dst == NULL)? NULL : dst + dstlen;
+
+	for(length = 0; buf < end; length++) {
+		int ch = *buf;
+		uint8_t *cend;
+		int32_t value;
+		int want;
+
+		/* Compute the sequence length */
+		want = UTF8String_ht[0][ch >> 4];
+		switch(want) {
+		case -1:
+			/* Second half of the table, long sequence */
+			want = UTF8String_ht[1][ch & 0x0F];
+			if(want != -1) break;
+			/* Fall through */
+		case 0:
+			return U8E_ILLSTART;
+		}
+
+		/* assert(want >= 1 && want <= 6) */
+
+		/* Check character sequence length */
+		if(buf + want > end) return U8E_TRUNC;
+
+		value = ch & (0xff >> want);
+		cend = buf + want;
+		for(buf++; buf < cend; buf++) {
+			ch = *buf;
+			if(ch < 0x80 || ch > 0xbf) return U8E_NOTCONT;
+			value = (value << 6) | (ch & 0x3F);
+		}
+		if(value < UTF8String_mv[want])
+			return U8E_NOTMIN;
+		if(dst < dstend)
+			*dst++ = value;	/* Record value */
+	}
+
+	if(dst < dstend) *dst = 0;	/* zero-terminate */
+
+	return length;
+}
+
+
+ssize_t
+UTF8String_length(const UTF8String_t *st) {
+	if(st && st->buf) {
+		return UTF8String__process(st, 0, 0);
+	} else {
+		return U8E_EINVAL;
+	}
+}
+
+size_t
+UTF8String_to_wcs(const UTF8String_t *st, uint32_t *dst, size_t dstlen) {
+	if(st && st->buf) {
+		ssize_t ret = UTF8String__process(st, dst, dstlen);
+		return (ret < 0) ? 0 : ret;
+	} else {
+		return 0;
+	}
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String.h /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String.h
new file mode 100644
index 000000000..25a402db8
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String.h
@@ -0,0 +1,86 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_UTF8String_H_
+#define	_UTF8String_H_
+
+#include "OCTET_STRING.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef OCTET_STRING_t UTF8String_t;	/* Implemented via OCTET STRING */
+
+extern asn_TYPE_descriptor_t asn_DEF_UTF8String;
+extern asn_TYPE_operation_t asn_OP_UTF8String;
+
+#define UTF8String_free OCTET_STRING_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f UTF8String_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+#define UTF8String_compare OCTET_STRING_compare
+#define UTF8String_copy    OCTET_STRING_copy
+
+asn_constr_check_f UTF8String_constraint;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define UTF8String_decode_ber OCTET_STRING_decode_ber
+#define UTF8String_encode_der OCTET_STRING_encode_der
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define UTF8String_decode_xer OCTET_STRING_decode_xer_utf8
+#define UTF8String_encode_xer OCTET_STRING_encode_xer_utf8
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+#define UTF8String_decode_jer OCTET_STRING_decode_jer_utf8
+#define UTF8String_encode_jer OCTET_STRING_encode_jer_utf8
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+#define UTF8String_decode_uper OCTET_STRING_decode_uper
+#define UTF8String_encode_uper OCTET_STRING_encode_uper
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+#define UTF8String_decode_aper OCTET_STRING_decode_aper
+#define UTF8String_encode_aper OCTET_STRING_encode_aper
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f UTF8String_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+/*
+ * Returns length of the given UTF-8 string in characters,
+ * or a negative error code:
+ * -1:	UTF-8 sequence truncated 
+ * -2:	Illegal UTF-8 sequence start
+ * -3:	Continuation expectation failed
+ * -4:	Not minimal length encoding
+ * -5:	Invalid arguments
+ */
+ssize_t UTF8String_length(const UTF8String_t *st);
+
+/*
+ * Convert the UTF-8 string into a sequence of wide characters.
+ * Returns the number of characters necessary.
+ * Returned value might be greater than dstlen.
+ * In case of conversion error, 0 is returned.
+ * 
+ * If st points to a valid UTF-8 string, calling
+ * 	UTF8String_to_wcs(st, 0, 0);
+ * is equivalent to
+ * 	UTF8String_length(const UTF8String_t *st);
+ */
+size_t UTF8String_to_wcs(const UTF8String_t *st, uint32_t *dst, size_t dstlen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _UTF8String_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String_print.c /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String_print.c
new file mode 100644
index 000000000..946948535
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String_print.c
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "UTF8String.h"
+
+int
+UTF8String_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+                 asn_app_consume_bytes_f *cb, void *app_key) {
+    const UTF8String_t *st = (const UTF8String_t *)sptr;
+
+    (void)td;  /* Unused argument */
+    (void)ilevel;  /* Unused argument */
+
+    if(st && st->buf) {
+        return (cb(st->buf, st->size, app_key) < 0) ? -1 : 0;
+    } else {
+        return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String_rfill.c
new file mode 100644
index 000000000..56471584c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/UTF8String_rfill.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "UTF8String.h"
+
+/*
+ * Biased function for randomizing UTF-8 sequences.
+ */
+static size_t
+UTF8String__random_char(uint8_t *b, size_t size) {
+    static const struct rnd_value {
+        const char *value;
+        size_t size;
+    } values[] = {{"\0", 1},
+                  {"\x01", 1},
+                  {"\x7f", 1},
+                  {"\xc2\xa2", 2},
+                  {"\xe2\x82\xac", 3},
+                  {"\xf0\x90\x8d\x88", 4},
+                  {"\xf4\x8f\xbf\xbf", 4}};
+
+    const struct rnd_value *v;
+    size_t max_idx = 0;
+
+    switch(size) {
+    case 0:
+        assert(size != 0);
+        return 0;
+    case 1:
+        max_idx = 2;
+        break;
+    case 2:
+        max_idx = 3;
+        break;
+    default:
+    case 4:
+        max_idx = sizeof(values) / sizeof(values[0]) - 1;
+        break;
+    }
+
+    v = &values[asn_random_between(0, max_idx)];
+    memcpy(b, v->value, v->size);
+    return v->size;
+}
+
+asn_random_fill_result_t
+UTF8String_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                       const asn_encoding_constraints_t *constraints,
+                       size_t max_length) {
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 1};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    uint8_t *buf;
+    uint8_t *bend;
+    uint8_t *b;
+    size_t rnd_len;
+    size_t idx;
+    UTF8String_t *st;
+
+    if(max_length == 0 && !*sptr) return result_skipped;
+
+    /* Figure out how far we should go */
+    rnd_len = OCTET_STRING_random_length_constrained(td, constraints,
+                                                     max_length / 4);
+
+    buf = CALLOC(4, rnd_len + 1);
+    if(!buf) return result_failed;
+
+    bend = &buf[4 * rnd_len];
+
+    for(b = buf, idx = 0; idx < rnd_len; idx++) {
+        b += UTF8String__random_char(b, (bend - b));
+    }
+    *(uint8_t *)b = 0;
+
+    if(*sptr) {
+        st = *sptr;
+        FREEMEM(st->buf);
+    } else {
+        st = (OCTET_STRING_t *)(*sptr = CALLOC(1, sizeof(UTF8String_t)));
+        if(!st) {
+            FREEMEM(buf);
+            return result_failed;
+        }
+    }
+
+    st->buf = buf;
+    st->size = b - buf;
+
+    assert(UTF8String_length(st) == (ssize_t)rnd_len);
+
+    return result_ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/all_asn1c_headers.h /ext/source/modules/EVSE/EvseV2G/asn1/all_asn1c_headers.h
new file mode 100644
index 000000000..cae7b3e43
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/all_asn1c_headers.h
@@ -0,0 +1,81 @@
+#ifndef ALL_ASN1C_HEADERS_H
+#define ALL_ASN1C_HEADERS_H
+#include "ANY.h"
+#include "aper_decoder.h"
+#include "aper_encoder.h"
+#include "aper_opentype.h"
+#include "aper_support.h"
+#include "asn_application.h"
+#include "asn_bit_data.h"
+#include "asn_codecs.h"
+#include "asn_codecs_prim.h"
+#include "asn_config.h"
+#include "asn_internal.h"
+#include "asn_ioc.h"
+#include "asn_random_fill.h"
+#include "asn_SEQUENCE_OF.h"
+#include "asn_SET_OF.h"
+#include "asn_system.h"
+#include "AuthorizationMethod.h"
+#include "BasicSignaling.h"
+#include "BasicSignalingProtocol.h"
+#include "ber_decoder.h"
+#include "ber_tlv_length.h"
+#include "ber_tlv_tag.h"
+#include "BIT_STRING.h"
+#include "BOOLEAN.h"
+#include "ChargingInterface.h"
+#include "ChargingStationCharacteristics.h"
+#include "ConductiveChargingInterfaceLimitations.h"
+#include "constraints.h"
+#include "constr_CHOICE.h"
+#include "constr_SEQUENCE.h"
+#include "constr_SEQUENCE_OF.h"
+#include "constr_SET_OF.h"
+#include "constr_TYPE.h"
+#include "DCChargingLimits.h"
+#include "der_encoder.h"
+#include "EMSPIdentifier.h"
+#include "EMSPIdentifiers.h"
+#include "EnergyTransferMode.h"
+#include "ENUMERATED.h"
+#include "EVCharacteristics.h"
+#include "Extensions.h"
+#include "ExternalExtension.h"
+#include "ExternalExtensions.h"
+#include "EXTERNAL.h"
+#include "GraphicString.h"
+#include "HighLevelCommunication.h"
+#include "HighLevelCommunicationTuple.h"
+#include "HLCProtocol.h"
+#include "INTEGER.h"
+#include "IPv6Socket.h"
+#include "jer_decoder.h"
+#include "jer_encoder.h"
+#include "jer_support.h"
+#include "NativeEnumerated.h"
+#include "NativeInteger.h"
+#include "ObjectDescriptor.h"
+#include "OBJECT_IDENTIFIER.h"
+#include "OCTET_STRING.h"
+#include "oer_decoder.h"
+#include "oer_encoder.h"
+#include "oer_support.h"
+#include "OPEN_TYPE.h"
+#include "per_decoder.h"
+#include "per_encoder.h"
+#include "per_opentype.h"
+#include "per_support.h"
+#include "SecurityProfile.h"
+#include "SecurityProfileTuple.h"
+#include "StandardizedExtension.h"
+#include "StandardizedExtensions.h"
+#include "uper_decoder.h"
+#include "uper_encoder.h"
+#include "uper_opentype.h"
+#include "uper_support.h"
+#include "UTF8String.h"
+#include "xer_decoder.h"
+#include "xer_encoder.h"
+#include "xer_support.h"
+#endif // ALL_ASN1C_HEADERS_H
\ No newline at end of file
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_decoder.c /ext/source/modules/EVSE/EvseV2G/asn1/aper_decoder.c
new file mode 100644
index 000000000..14c9ec679
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_decoder.c
@@ -0,0 +1,91 @@
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "aper_decoder.h"
+
+asn_dec_rval_t
+aper_decode_complete(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td, void **sptr,
+                     const void *buffer, size_t size) {
+	asn_dec_rval_t rval;
+
+	rval = aper_decode(opt_codec_ctx, td, sptr, buffer, size, 0, 0);
+	if(rval.consumed) {
+		/*
+		 * We've always given 8-aligned data,
+		 * so convert bits to integral bytes.
+		 */
+		rval.consumed += 7;
+		rval.consumed >>= 3;
+	} else if(rval.code == RC_OK) {
+		if(size) {
+			if(((const uint8_t *)buffer)[0] == 0) {
+				rval.consumed = 1;	/* 1 byte */
+			} else {
+				ASN_DEBUG("Expecting single zeroed byte");
+				rval.code = RC_FAIL;
+			}
+		} else {
+			/* Must contain at least 8 bits. */
+			rval.code = RC_WMORE;
+		}
+	}
+
+	return rval;
+}
+
+asn_dec_rval_t
+aper_decode(const asn_codec_ctx_t *opt_codec_ctx,
+            const asn_TYPE_descriptor_t *td, void **sptr, const void *buffer,
+            size_t size, int skip_bits, int unused_bits) {
+	asn_codec_ctx_t s_codec_ctx;
+	asn_dec_rval_t rval;
+	asn_per_data_t pd;
+
+	if(skip_bits < 0 || skip_bits > 7
+		|| unused_bits < 0 || unused_bits > 7
+		|| (unused_bits > 0 && !size))
+		ASN__DECODE_FAILED;
+
+	/*
+	 * Stack checker requires that the codec context
+	 * must be allocated on the stack.
+	 */
+	if(opt_codec_ctx) {
+		if(opt_codec_ctx->max_stack_size) {
+			s_codec_ctx = *opt_codec_ctx;
+			opt_codec_ctx = &s_codec_ctx;
+		}
+	} else {
+		/* If context is not given, be security-conscious anyway */
+		memset(&s_codec_ctx, 0, sizeof(s_codec_ctx));
+		s_codec_ctx.max_stack_size = ASN__DEFAULT_STACK_MAX;
+		opt_codec_ctx = &s_codec_ctx;
+	}
+
+	/* Fill in the position indicator */
+	memset(&pd, 0, sizeof(pd));
+	pd.buffer = (const uint8_t *)buffer;
+	pd.nboff = skip_bits;
+	pd.nbits = 8 * size - unused_bits; /* 8 is CHAR_BIT from <limits.h> */
+	if(pd.nboff > pd.nbits)
+		ASN__DECODE_FAILED;
+
+	/*
+	 * Invoke type-specific decoder.
+	 */
+	if(!td->op->aper_decoder)
+		ASN__DECODE_FAILED;	/* PER is not compiled in */
+	rval = td->op->aper_decoder(opt_codec_ctx, td, 0, sptr, &pd);
+	if(rval.code == RC_OK) {
+		/* Return the number of consumed bits */
+		rval.consumed = ((pd.buffer - (const uint8_t *)buffer) << 3)
+		+ pd.nboff - skip_bits;
+		ASN_DEBUG("PER decoding consumed %zu, counted %zu",
+				  rval.consumed, pd.moved);
+		assert(rval.consumed == pd.moved);
+	} else {
+		/* PER codec is not a restartable */
+		rval.consumed = 0;
+	}
+	return rval;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_decoder.h /ext/source/modules/EVSE/EvseV2G/asn1/aper_decoder.h
new file mode 100644
index 000000000..f9b364f30
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_decoder.h
@@ -0,0 +1,47 @@
+/*-
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_APER_DECODER_H_
+#define	_APER_DECODER_H_
+
+#include "asn_application.h"
+#include "aper_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * Aligned PER decoder of a "complete encoding" as per X.691#10.1.
+ * On success, this call always returns (.consumed >= 1), in BITS, as per X.691#10.1.3.
+ */
+asn_dec_rval_t aper_decode_complete(
+       const struct asn_codec_ctx_s *opt_codec_ctx,
+       const struct asn_TYPE_descriptor_s *type_descriptor,	/* Type to decode */
+       void **struct_ptr,	/* Pointer to a target structure's pointer */
+       const void *buffer,	/* Data to be decoded */
+       size_t size		/* Size of data buffer */
+									);
+
+/*
+ * Aligned PER decoder of any ASN.1 type. May be invoked by the application.
+ * WARNING: This call returns the number of BITS read from the stream. Beware.
+ */
+asn_dec_rval_t aper_decode(
+      const struct asn_codec_ctx_s *opt_codec_ctx,
+      const struct asn_TYPE_descriptor_s *type_descriptor,	/* Type to decode */
+      void **struct_ptr,	/* Pointer to a target structure's pointer */
+      const void *buffer,	/* Data to be decoded */
+      size_t size,		/* Size of data buffer */
+      int skip_bits,		/* Number of unused leading bits, 0..7 */
+      int unused_bits		/* Number of unused tailing bits, 0..7 */
+      );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _APER_DECODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_encoder.c /ext/source/modules/EVSE/EvseV2G/asn1/aper_encoder.c
new file mode 100644
index 000000000..53ce31778
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_encoder.c
@@ -0,0 +1,129 @@
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "aper_encoder.h"
+
+/*
+ * Argument type and callback necessary for aper_encode_to_buffer().
+ */
+typedef struct enc_to_buf_arg {
+	void *buffer;
+	size_t left;
+} enc_to_buf_arg;
+static int encode_to_buffer_cb(const void *buffer, size_t size, void *key) {
+	enc_to_buf_arg *arg = (enc_to_buf_arg *)key;
+
+	if(arg->left < size)
+		return -1;	/* Data exceeds the available buffer size */
+
+	memcpy(arg->buffer, buffer, size);
+	arg->buffer = ((char *)arg->buffer) + size;
+	arg->left -= size;
+
+	return 0;
+}
+
+asn_enc_rval_t
+aper_encode_to_buffer(const asn_TYPE_descriptor_t *td,
+                      const asn_per_constraints_t *constraints,
+                      const void *sptr, void *buffer, size_t buffer_size) {
+    enc_to_buf_arg key;
+
+    key.buffer = buffer;
+    key.left = buffer_size;
+
+    if(td) ASN_DEBUG("Encoding \"%s\" using ALIGNED PER", td->name);
+
+    return aper_encode(td, constraints, sptr, encode_to_buffer_cb, &key);
+}
+
+ssize_t
+aper_encode_to_new_buffer(const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints,
+                          const void *sptr, void **buffer_r) {
+    asn_enc_rval_t er = {0,0,0};
+	enc_dyn_arg key;
+
+	memset(&key, 0, sizeof(key));
+
+	er = aper_encode(td, constraints, sptr, encode_dyn_cb, &key);
+	switch(er.encoded) {
+	case -1:
+		FREEMEM(key.buffer);
+		return -1;
+	case 0:
+		FREEMEM(key.buffer);
+		key.buffer = MALLOC(1);
+		if(key.buffer) {
+			*(char *)key.buffer = '\0';
+			*buffer_r = key.buffer;
+			return 1;
+		} else {
+			return -1;
+		}
+	default:
+		*buffer_r = key.buffer;
+		ASN_DEBUG("Complete encoded in %ld bits", (long)er.encoded);
+		return ((er.encoded + 7) >> 3);
+	}
+}
+
+/*
+ * Internally useful functions.
+ */
+
+/* Flush partially filled buffer */
+static int
+_aper_encode_flush_outp(asn_per_outp_t *po) {
+	uint8_t *buf;
+
+	if(po->nboff == 0 && po->buffer == po->tmpspace)
+		return 0;
+
+	buf = po->buffer + (po->nboff >> 3);
+	/* Make sure we account for the last, partially filled */
+	if(po->nboff & 0x07) {
+		buf[0] &= 0xff << (8 - (po->nboff & 0x07));
+		buf++;
+	}
+
+	if (po->output) {
+		return po->output(po->tmpspace, buf - po->tmpspace, po->op_key);
+	}
+	return 0;
+}
+
+asn_enc_rval_t
+aper_encode(const asn_TYPE_descriptor_t *td,
+        const asn_per_constraints_t *constraints,
+        const void *sptr, asn_app_consume_bytes_f *cb, void *app_key) {
+	asn_per_outp_t po;
+	asn_enc_rval_t er = {0,0,0};
+
+	/*
+	 * Invoke type-specific encoder.
+	 */
+	if(!td || !td->op->aper_encoder)
+		ASN__ENCODE_FAILED;	 /* PER is not compiled in */
+
+	po.buffer = po.tmpspace;
+	po.nboff = 0;
+	po.nbits = 8 * sizeof(po.tmpspace);
+	po.output = cb ? cb : ignore_output;
+	po.op_key = app_key;
+	po.flushed_bytes = 0;
+
+	er = td->op->aper_encoder(td, constraints, sptr, &po);
+	if(er.encoded != -1) {
+		size_t bits_to_flush;
+
+		bits_to_flush = ((po.buffer - po.tmpspace) << 3) + po.nboff;
+
+		/* Set number of bits encoded to a firm value */
+		er.encoded = (po.flushed_bytes << 3) + bits_to_flush;
+
+		if(_aper_encode_flush_outp(&po))
+			ASN__ENCODE_FAILED;
+	}
+
+	return er;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_encoder.h /ext/source/modules/EVSE/EvseV2G/asn1/aper_encoder.h
new file mode 100644
index 000000000..ea15e6726
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_encoder.h
@@ -0,0 +1,63 @@
+/*-
+ * Copyright (c) 2006-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_APER_ENCODER_H_
+#define	_APER_ENCODER_H_
+
+#include "asn_application.h"
+#include "aper_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * Aligned PER encoder of any ASN.1 type. May be invoked by the application.
+ * WARNING: This function returns the number of encoded bits in the .encoded
+ * field of the return value. Use the following formula to convert to bytes:
+ * 	bytes = ((.encoded + 7) / 8)
+ */
+asn_enc_rval_t aper_encode(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_per_constraints_t *constraints,
+    const void *struct_ptr,                     /* Structure to be encoded */
+    asn_app_consume_bytes_f *consume_bytes_cb,  /* Data collector */
+    void *app_key                               /* Arbitrary callback argument */
+);
+
+/*
+ * A variant of aper_encode() which encodes data into the existing buffer
+ * WARNING: This function returns the number of encoded bits in the .encoded
+ * field of the return value.
+ */
+asn_enc_rval_t aper_encode_to_buffer(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_per_constraints_t *constraints,
+    const void *struct_ptr,  /* Structure to be encoded */
+    void *buffer,            /* Pre-allocated buffer */
+    size_t buffer_size       /* Initial buffer size (max) */
+);
+
+/*
+ * A variant of aper_encode_to_buffer() which allocates buffer itself.
+ * Returns the number of bytes in the buffer or -1 in case of failure.
+ * WARNING: This function produces a "Production of the complete encoding",
+ * with length of at least one octet. Contrast this to precise bit-packing
+ * encoding of aper_encode() and aper_encode_to_buffer().
+ */
+ssize_t
+aper_encode_to_new_buffer(
+    const struct asn_TYPE_descriptor_s *td,
+    const asn_per_constraints_t *constraints,
+    const void *sptr,
+    void **buffer_r
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _APER_ENCODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_opentype.c /ext/source/modules/EVSE/EvseV2G/asn1/aper_opentype.c
new file mode 100644
index 000000000..5549f67d9
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_opentype.c
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2007 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "aper_encoder.h"
+#include "aper_support.h"
+#include "aper_opentype.h"
+
+static asn_dec_rval_t
+aper_open_type_get_simple(const asn_codec_ctx_t *ctx,
+                          const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+	asn_dec_rval_t rv;
+	ssize_t chunk_bytes;
+	int repeat;
+	uint8_t *buf = 0;
+	size_t bufLen = 0;
+	size_t bufSize = 0;
+	asn_per_data_t spd;
+	size_t padding;
+
+	ASN__STACK_OVERFLOW_CHECK(ctx);
+
+	ASN_DEBUG("Getting open type %s...", td->name);
+
+	do {
+	        chunk_bytes = aper_get_length(pd, -1, -1, -1, &repeat);
+		if(chunk_bytes < 0) {
+			FREEMEM(buf);
+			ASN__DECODE_STARVED;
+		}
+		if(bufLen + chunk_bytes > bufSize) {
+			void *ptr;
+			bufSize = chunk_bytes + (bufSize << 2);
+			ptr = REALLOC(buf, bufSize);
+			if(!ptr) {
+				FREEMEM(buf);
+				ASN__DECODE_FAILED;
+			}
+			buf = ptr;
+		}
+		if(per_get_many_bits(pd, buf + bufLen, 0, chunk_bytes << 3)) {
+			FREEMEM(buf);
+			ASN__DECODE_STARVED;
+		}
+		bufLen += chunk_bytes;
+	} while(repeat);
+
+	ASN_DEBUG("Getting open type %s encoded in %ld bytes", td->name,
+		(long)bufLen);
+
+	memset(&spd, 0, sizeof(spd));
+	spd.buffer = buf;
+	spd.nbits = bufLen << 3;
+
+	ASN_DEBUG_INDENT_ADD(+4);
+	rv = td->op->aper_decoder(ctx, td, constraints, sptr, &spd);
+	ASN_DEBUG_INDENT_ADD(-4);
+
+	if(rv.code == RC_OK) {
+		/* Check padding validity */
+		padding = spd.nbits - spd.nboff;
+                if (((padding > 0 && padding < 8) ||
+		/* X.691#10.1.3 */
+		(spd.nboff == 0 && spd.nbits == 8 && spd.buffer == buf)) &&
+                    per_get_few_bits(&spd, padding) == 0) {
+			/* Everything is cool */
+			FREEMEM(buf);
+			return rv;
+		}
+		FREEMEM(buf);
+		if(padding >= 8) {
+			ASN_DEBUG("Too large padding %d in open type", (int)padding);
+			ASN__DECODE_FAILED;
+		} else {
+			ASN_DEBUG("No padding");
+		}
+	} else {
+		FREEMEM(buf);
+		/* rv.code could be RC_WMORE, nonsense in this context */
+		rv.code = RC_FAIL; /* Noone would give us more */
+	}
+
+	return rv;
+}
+
+int
+aper_open_type_put(const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints,
+                   const void *sptr, asn_per_outp_t *po) {
+	void *buf;
+	void *bptr;
+	ssize_t size;
+	size_t toGo;
+
+	ASN_DEBUG("Open type put %s ...", td->name);
+
+	size = aper_encode_to_new_buffer(td, constraints, sptr, &buf);
+	if(size <= 0) return -1;
+
+	for(bptr = buf, toGo = size; toGo;) {
+        int need_eom = 0;
+		ssize_t maySave = aper_put_length(po, -1, -1, toGo, &need_eom);
+		if(maySave < 0) break;
+		if(per_put_many_bits(po, bptr, maySave * 8)) break;
+		bptr = (char *)bptr + maySave;
+		toGo -= maySave;
+        if(need_eom && (aper_put_length(po, -1, -1, 0, NULL) < 0)) {
+            FREEMEM(buf);
+            return -1;
+        }
+	}
+
+	FREEMEM(buf);
+	if(toGo) return -1;
+
+	ASN_DEBUG("Open type put %s of length %zd + overhead (1byte?)",
+			  td->name, size);
+
+	return 0;
+}
+
+asn_dec_rval_t
+aper_open_type_get(const asn_codec_ctx_t *ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints,
+                   void **sptr, asn_per_data_t *pd) {
+
+	return aper_open_type_get_simple(ctx, td, constraints, sptr, pd);
+}
+
+int
+aper_open_type_skip(const asn_codec_ctx_t *ctx, asn_per_data_t *pd) {
+	asn_TYPE_descriptor_t s_td;
+	asn_dec_rval_t rv;
+	asn_TYPE_operation_t op_t;
+
+	memset(&op_t, 0, sizeof(op_t));
+	s_td.name = "<unknown extension>";
+	s_td.op = &op_t;
+	s_td.op->aper_decoder = uper_sot_suck;
+
+	rv = aper_open_type_get(ctx, &s_td, 0, 0, pd);
+	if(rv.code != RC_OK)
+		return -1;
+	else
+		return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_opentype.h /ext/source/modules/EVSE/EvseV2G/asn1/aper_opentype.h
new file mode 100644
index 000000000..bc8134e8c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_opentype.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2007-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_APER_OPENTYPE_H_
+#define	_APER_OPENTYPE_H_
+
+#include "per_opentype.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+asn_dec_rval_t aper_open_type_get(const asn_codec_ctx_t *opt_codec_ctx,
+                                  const asn_TYPE_descriptor_t *td,
+                                  const asn_per_constraints_t *constraints,
+                                  void **sptr, asn_per_data_t *pd);
+
+
+int aper_open_type_skip(const asn_codec_ctx_t *opt_codec_ctx, asn_per_data_t *pd);
+
+int aper_open_type_put(const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints,
+                       const void *sptr, asn_per_outp_t *po);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _APER_OPENTYPE_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_support.c /ext/source/modules/EVSE/EvseV2G/asn1/aper_support.c
new file mode 100644
index 000000000..50e926297
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_support.c
@@ -0,0 +1,360 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_system.h"
+#include "asn_internal.h"
+#include "aper_support.h"
+
+int32_t
+aper_get_align(asn_per_data_t *pd) {
+
+	if(pd->nboff & 0x7) {
+		ASN_DEBUG("Aligning %ld bits", 8 - ((unsigned long)pd->nboff & 0x7));
+		return per_get_few_bits(pd, 8 - (pd->nboff & 0x7));
+	}
+	return 0;
+}
+
+ssize_t
+aper_get_length(asn_per_data_t *pd, ssize_t lb, ssize_t ub,
+		int ebits, int *repeat) {
+	int constrained = (lb >= 0) && (ub >= 0);
+	ssize_t value;
+
+	*repeat = 0;
+
+	if (constrained && ub < 65536) {
+		return aper_get_constrained_whole_number(pd, lb, ub);
+	}
+
+	if (aper_get_align(pd) < 0)
+		return -1;
+
+	if(ebits >= 0) return per_get_few_bits(pd, ebits);
+
+	value = per_get_few_bits(pd, 8);
+	if(value < 0) return -1;
+	if((value & 128) == 0)  /* #11.9.3.6 */
+		return (value & 0x7F);
+	if((value & 64) == 0) { /* #11.9.3.7 */
+		value = ((value & 63) << 8) | per_get_few_bits(pd, 8);
+		if(value < 0) return -1;
+		return value;
+	}
+	value &= 63;	/* this is "m" from X.691, #11.9.3.8 */
+	if(value < 1 || value > 4)
+		return -1;
+	*repeat = 1;
+	return (16384 * value);
+}
+
+ssize_t
+aper_get_nslength(asn_per_data_t *pd) {
+	ssize_t length;
+
+	ASN_DEBUG("Getting normally small length");
+
+	if(per_get_few_bits(pd, 1) == 0) {
+		length = per_get_few_bits(pd, 6) + 1;
+		if(length <= 0) return -1;
+		ASN_DEBUG("l=%zd", length);
+		return length;
+	} else {
+		int repeat;
+		length = aper_get_length(pd, -1, -1, -1, &repeat);
+		if(length >= 0 && !repeat) return length;
+		return -1; /* Error, or do not support >16K extensions */
+	}
+}
+
+ssize_t
+aper_get_nsnnwn(asn_per_data_t *pd) {
+	int b;
+	int length;
+
+	ASN_DEBUG("getting nsnnwn");
+
+	b = per_get_few_bits(pd, 1);
+	if (b == -1)
+		return -1;
+
+	/* X.691 2002 10.6.1 */
+	if (b == 0)
+		return per_get_few_bits(pd, 6);
+
+	if (aper_get_align(pd) < 0)
+		return -1;
+
+	/* X.691 2002 10.6.2 */
+	/* X.691 2002 10.9.3.5 */
+	b = per_get_few_bits(pd, 1);
+	if (b == -1)
+		return -1;
+
+	if (b == 1) {
+		/* other 10.9.3.x cases not handled, it's doubtful we reach them in practice */
+		ASN_DEBUG("todo: X.691 2002 10.9.3.x");
+		return -1;
+	}
+
+	/* X.691 2002 10.9.3.6 */
+	length = per_get_few_bits(pd, 7);
+	if (length > 4) {
+		/* todo */
+		ASN_DEBUG("todo: X.691 2002 10.9.3.6 for length > 4");
+		return -1;
+	}
+	ASN_DEBUG("length %d\n", length);
+
+	/* todo: 0xffffffff will be seen as -1 and will lead to decoding failure */
+	return per_get_few_bits(pd, length * 8);
+}
+
+/* X.691 2002 10.5 - Decoding of a constrained whole number */
+long
+aper_get_constrained_whole_number(asn_per_data_t *pd, long lb, long ub) {
+	assert(ub >= lb);
+	long range = ub - lb + 1;
+	int range_len;
+	int value_len;
+	long value;
+
+	ASN_DEBUG("aper get constrained_whole_number with lb %ld and ub %ld", lb, ub);
+
+	/* X.691 2002 10.5.4 */
+	if (range == 1)
+		return lb;
+
+	/* X.691 2002 10.5.7.1 - The bit-field case. */
+	if (range <= 255) {
+		int bitfield_size = 8;
+		for (bitfield_size = 8; bitfield_size >= 2; bitfield_size--)
+			if ((range - 1) & (1 << (bitfield_size-1)))
+				break;
+		value = per_get_few_bits(pd, bitfield_size);
+		if (value < 0 || value >= range)
+			return -1;
+		return value + lb;
+	}
+
+	/* X.691 2002 10.5.7.2 - The one-octet case. */
+	if (range == 256) {
+		if (aper_get_align(pd) < 0)
+			return -1;
+		value = per_get_few_bits(pd, 8);
+		if (value < 0 || value >= range)
+			return -1;
+		return value + lb;
+	}
+
+	/* X.691 2002 10.5.7.3 - The two-octet case. */
+	if (range <= 65536) {
+		if (aper_get_align(pd) < 0)
+			return -1;
+		value = per_get_few_bits(pd, 16);
+		if (value < 0 || value >= range)
+			return -1;
+		return value + lb;
+	}
+
+	/* X.691 2002 10.5.7.4 - The indefinite length case. */
+	/* since we limit input to be 'long' we don't handle all numbers */
+	/* and so length determinant is retrieved as X.691 2002 10.9.3.3 */
+	/* number of bytes to store the range */
+	for (range_len = 3; ; range_len++) {
+		long bits = ((long)1) << (8 * range_len);
+		if (range - 1 < bits)
+			break;
+	}
+	value_len = aper_get_constrained_whole_number(pd, 1, range_len);
+	if (value_len == -1)
+		return -1;
+	if (value_len > 4) {
+		ASN_DEBUG("todo: aper_get_constrained_whole_number: value_len > 4");
+		return -1;
+	}
+	if (aper_get_align(pd) < 0)
+		return -1;
+	value = per_get_few_bits(pd, value_len * 8);
+	if (value < 0 || value >= range)
+		return -1;
+	return value + lb;
+}
+
+int aper_put_align(asn_per_outp_t *po) {
+
+	if(po->nboff & 0x7) {
+		ASN_DEBUG("Aligning %ld bits", 8 - ((unsigned long)po->nboff & 0x7));
+		if(per_put_few_bits(po, 0x00, (8 - (po->nboff & 0x7))))
+			return -1;
+	}
+	return 0;
+}
+
+ssize_t
+aper_put_length(asn_per_outp_t *po, ssize_t lb, ssize_t ub, size_t n, int *need_eom) {
+	int constrained = (lb >= 0) && (ub >= 0);
+	int dummy = 0;
+	if(!need_eom) need_eom = &dummy;
+
+	*need_eom = 0;
+
+
+	ASN_DEBUG("APER put length %zu with range (%zd..%zd)", n, lb, ub);
+
+	/* X.691 2002 10.9.3.3 */
+	if (constrained && ub < 65536)
+		return aper_put_constrained_whole_number(po, lb, ub, n + lb) ? -1 : (ssize_t)n;
+
+	if (aper_put_align(po) < 0)
+		return -1;
+
+	if(n <= 127) { /* #11.9.3.6 */
+		return per_put_few_bits(po, n, 8)
+		? -1 : (ssize_t)n;
+	}
+	else if(n < 16384) /* #11.9.3.7 */
+		return per_put_few_bits(po, n|0x8000, 16)
+		? -1 : (ssize_t)n;
+
+	*need_eom = 0 == (n & 16383);
+	n >>= 14;
+	if(n > 4) {
+		*need_eom = 0;
+		n = 4;
+	}
+
+	return per_put_few_bits(po, 0xC0 | n, 8)
+	? -1 : (ssize_t)(n << 14);
+}
+
+
+int
+aper_put_nslength(asn_per_outp_t *po, size_t length) {
+
+	if(length <= 64) {
+		/* #11.9.3.4 */
+		if(length == 0) return -1;
+		return per_put_few_bits(po, length-1, 7) ? -1 : 0;
+	} else {
+		if(aper_put_length(po, -1, -1, length, NULL) != (ssize_t)length) {
+			/* This might happen in case of >16K extensions */
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int
+aper_put_nsnnwn(asn_per_outp_t *po, int number) {
+	int len;
+
+	ASN_DEBUG("aper put nsnnwn %d", number);
+
+	if (number <= 63) {
+		if (per_put_few_bits(po, 0, 1))
+			return -1;
+		return per_put_few_bits(po, number, 6);
+	}
+
+	if (per_put_few_bits(po, 1, 1))
+		return -1;
+
+	if (number < 256) {
+		len = 1;
+	} else if (number < 65536) {
+		len = 2;
+	} else { /* number > 64K */
+		int i;
+		for (i = 3; ; i++) {
+			int bits = 1 << (8 * i);
+			if (number < bits)
+				break;
+		}
+		len = i;
+	}
+
+	if (aper_put_align(po) < 0)
+		return -1;
+
+	/* put the length which is a non-constrained whole number */
+	if (len <= 127) {
+		if(per_put_few_bits(po, 0, 1))
+			return -1;
+		if(per_put_few_bits(po, len, 7))
+			return -1;
+	} else {
+		/* todo but not big problem, it's very doubtful that the
+		 * number of bytes to encode 'number' will be > 127
+		 */
+		return -1;
+	}
+	if(aper_put_align(po) < 0) /* Aligning on octet */
+		return -1;
+	return per_put_few_bits(po, number, 8 * len);
+}
+
+/* X.691 2002 10.5 - Encoding of a constrained whole number */
+int
+aper_put_constrained_whole_number(asn_per_outp_t *po, long lb, long ub, long number) {
+	assert(ub >= lb);
+	long range = ub - lb + 1;
+	long value = number - lb;
+	int range_len;
+	int value_len;
+
+	ASN_DEBUG("aper put constrained_whole_number %ld with lb %ld and ub %ld", number, lb, ub);
+
+	if (number < lb || number > ub)
+		return -1;
+
+	/* X.691 2002 10.5.4 */
+	if (range == 1)
+		return 0;
+
+	/* X.691 2002 10.5.7.1 - The bit-field case. */
+	if (range <= 255) {
+		int bitfield_size = 8;
+		for (bitfield_size = 8; bitfield_size >= 2; bitfield_size--)
+			if ((range - 1) & (1 << (bitfield_size-1)))
+				break;
+		return per_put_few_bits(po, value, bitfield_size);
+	}
+
+	/* X.691 2002 10.5.7.2 - The one-octet case. */
+	if (range == 256) {
+		if (aper_put_align(po))
+			return -1;
+		return per_put_few_bits(po, value, 8);
+	}
+
+	/* X.691 2002 10.5.7.3 - The two-octet case. */
+	if (range <= 65536) {
+		if (aper_put_align(po))
+			return -1;
+		return per_put_few_bits(po, value, 16);
+	}
+
+	/* X.691 2002 10.5.7.4 - The indefinite length case. */
+	/* since we limit input to be 'long' we don't handle all numbers */
+	/* and so length determinant is stored as X.691 2002 10.9.3.3 */
+	/* number of bytes to store the range */
+	for (range_len = 3; ; range_len++) {
+		int bits = 1 << (8 * range_len);
+		if (range - 1 < bits)
+			break;
+	}
+	/* number of bytes to store the value */
+	for (value_len = 1; ; value_len++) {
+		long bits = ((long)1) << (8 * value_len);
+		if (value < bits)
+			break;
+	}
+	if (aper_put_constrained_whole_number(po, 1, range_len, value_len))
+		return -1;
+	if (aper_put_align(po))
+		return -1;
+	return per_put_few_bits(po, value, value_len * 8);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/aper_support.h /ext/source/modules/EVSE/EvseV2G/asn1/aper_support.h
new file mode 100644
index 000000000..ef3cbc539
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/aper_support.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_APER_SUPPORT_H_
+#define	_APER_SUPPORT_H_
+
+#include "asn_system.h"		/* Platform-specific types */
+#include "per_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * X.691 (08/2015) #11.9 "General rules for encoding a length determinant"
+ * Get the length "n" from the Aligned PER stream.
+ */
+ssize_t aper_get_length(asn_per_data_t *pd, ssize_t lb, ssize_t ub,
+                        int effective_bound_bits, int *repeat);
+
+/*
+ * Get the normally small length "n".
+ */
+ssize_t aper_get_nslength(asn_per_data_t *pd);
+
+/*
+ * Get the normally small non-negative whole number.
+ */
+ssize_t aper_get_nsnnwn(asn_per_data_t *pd);
+
+/*
+ * Get the constrained whole number.
+ */
+long aper_get_constrained_whole_number(asn_per_data_t *po, long lb, long ub);
+
+/*
+ * X.691 (08/2015) #11.9 "General rules for encoding a length determinant"
+ * Put the length "n" to the Aligned PER stream.
+ * If (opt_need_eom) is given, it will be set to 1 if final 0-n is needed.
+ * In that case, invoke aper_put_length(po, -1, -1, 0, NULL) after encoding the
+ * last block.
+ * This function returns the number of units which may be flushed
+ * in the next units saving iteration.
+ */
+ssize_t aper_put_length(asn_per_outp_t *po, ssize_t lb, ssize_t ub, size_t n,
+                        int *opt_need_eom);
+
+/* Align the current bit position to octet bundary */
+int aper_put_align(asn_per_outp_t *po);
+int32_t aper_get_align(asn_per_data_t *pd);
+
+/*
+ * Put the normally small length "n" to the Unaligned PER stream.
+ * Returns 0 or -1.
+ */
+int aper_put_nslength(asn_per_outp_t *po, size_t length);
+
+/*
+ * Put the normally small non-negative whole number.
+ */
+int aper_put_nsnnwn(asn_per_outp_t *po, int number);
+
+/*
+ * Put the constrained whole number.
+ */
+int aper_put_constrained_whole_number(asn_per_outp_t *po, long lb, long ub, long number);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _APER_SUPPORT_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_SEQUENCE_OF.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_SEQUENCE_OF.c
new file mode 100644
index 000000000..f65b3ee73
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_SEQUENCE_OF.c
@@ -0,0 +1,41 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_SEQUENCE_OF.h"
+
+typedef A_SEQUENCE_OF(void) asn_sequence;
+
+void
+asn_sequence_del(void *asn_sequence_of_x, int number, int _do_free) {
+	asn_sequence *as = (asn_sequence *)asn_sequence_of_x;
+
+	if(as) {
+		void *ptr;
+		int n;
+
+		if(number < 0 || number >= as->count)
+			return;	/* Nothing to delete */
+
+		if(_do_free && as->free) {
+			ptr = as->array[number];
+		} else {
+			ptr = 0;
+		}
+
+		/*
+		 * Shift all elements to the left to hide the gap.
+		 */
+		--as->count;
+		for(n = number; n < as->count; n++)
+			as->array[n] = as->array[n+1];
+
+		/*
+		 * Invoke the third-party function only when the state
+		 * of the parent structure is consistent.
+		 */
+		if(ptr) as->free(ptr);
+	}
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_SEQUENCE_OF.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_SEQUENCE_OF.h
new file mode 100644
index 000000000..7a5464cc9
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_SEQUENCE_OF.h
@@ -0,0 +1,52 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN_SEQUENCE_OF_H
+#define	ASN_SEQUENCE_OF_H
+
+#include "asn_SET_OF.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * SEQUENCE OF is the same as SET OF with a tiny difference:
+ * the delete operation preserves the initial order of elements
+ * and thus MAY operate in non-constant time.
+ */
+#define	A_SEQUENCE_OF(type)	A_SET_OF(type)
+
+#define	ASN_SEQUENCE_ADD(headptr, ptr)		\
+	asn_sequence_add((headptr), (ptr))
+
+/***********************************************
+ * Implementation of the SEQUENCE OF structure.
+ */
+
+#define	asn_sequence_add	asn_set_add
+#define	asn_sequence_empty	asn_set_empty
+
+/*
+ * Delete the element from the set by its number (base 0).
+ * This is NOT a constant-time operation.
+ * The order of elements is preserved.
+ * If _do_free is given AND the (*free) is initialized, the element
+ * will be freed using the custom (*free) function as well.
+ */
+void asn_sequence_del(void *asn_sequence_of_x, int number, int _do_free);
+
+/*
+ * Cope with different conversions requirements to/from void in C and C++.
+ * This is mostly useful for support library.
+ */
+typedef A_SEQUENCE_OF(void) asn_anonymous_sequence_;
+#define _A_SEQUENCE_FROM_VOID(ptr)	((asn_anonymous_sequence_ *)(ptr))
+#define _A_CSEQUENCE_FROM_VOID(ptr) 	((const asn_anonymous_sequence_ *)(ptr))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_SEQUENCE_OF_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_SET_OF.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_SET_OF.c
new file mode 100644
index 000000000..edf3eb30f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_SET_OF.c
@@ -0,0 +1,88 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_SET_OF.h"
+#include <errno.h>
+
+/*
+ * Add another element into the set.
+ */
+int
+asn_set_add(void *asn_set_of_x, void *ptr) {
+	asn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x);
+
+	if(as == 0 || ptr == 0) {
+		errno = EINVAL;		/* Invalid arguments */
+		return -1;
+	}
+
+	/*
+	 * Make sure there's enough space to insert an element.
+	 */
+	if(as->count == as->size) {
+		int _newsize = as->size ? (as->size << 1) : 4;
+		void *_new_arr;
+		_new_arr = REALLOC(as->array, _newsize * sizeof(as->array[0]));
+		if(_new_arr) {
+			as->array = (void **)_new_arr;
+			as->size = _newsize;
+		} else {
+			/* ENOMEM */
+			return -1;
+		}
+	}
+
+	as->array[as->count++] = ptr;
+
+	return 0;
+}
+
+void
+asn_set_del(void *asn_set_of_x, int number, int _do_free) {
+	asn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x);
+
+	if(as) {
+		void *ptr;
+		if(number < 0 || number >= as->count)
+			return;
+
+		if(_do_free && as->free) {
+			ptr = as->array[number];
+		} else {
+			ptr = 0;
+		}
+
+		as->array[number] = as->array[--as->count];
+
+		/*
+		 * Invoke the third-party function only when the state
+		 * of the parent structure is consistent.
+		 */
+		if(ptr) as->free(ptr);
+	}
+}
+
+/*
+ * Free the contents of the set, do not free the set itself.
+ */
+void
+asn_set_empty(void *asn_set_of_x) {
+	asn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x);
+
+	if(as) {
+		if(as->array) {
+			if(as->free) {
+				while(as->count--)
+					as->free(as->array[as->count]);
+			}
+			FREEMEM(as->array);
+			as->array = 0;
+		}
+		as->count = 0;
+		as->size = 0;
+	}
+
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_SET_OF.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_SET_OF.h
new file mode 100644
index 000000000..882e1a47d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_SET_OF.h
@@ -0,0 +1,72 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN_SET_OF_H
+#define	ASN_SET_OF_H
+
+#ifdef __cplusplus
+#define A_SET_OF(type)                   \
+    struct {                             \
+        type **array;                    \
+        int count; /* Meaningful size */ \
+        int size;  /* Allocated size */  \
+        void (*free)(decltype(*array));  \
+    }
+#else   /* C */
+#define A_SET_OF(type)                   \
+    struct {                             \
+        type **array;                    \
+        int count; /* Meaningful size */ \
+        int size;  /* Allocated size */  \
+        void (*free)(type *);    \
+    }
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	ASN_SET_ADD(headptr, ptr)		\
+	asn_set_add((headptr), (ptr))
+
+/*******************************************
+ * Implementation of the SET OF structure.
+ */
+
+/*
+ * Add another structure into the set by its pointer.
+ * RETURN VALUES:
+ * 0 for success and -1/errno for failure.
+ */
+int  asn_set_add(void *asn_set_of_x, void *ptr);
+
+/*
+ * Delete the element from the set by its number (base 0).
+ * This is a constant-time operation. The order of elements before the
+ * deleted ones is guaranteed, the order of elements after the deleted
+ * one is NOT guaranteed.
+ * If _do_free is given AND the (*free) is initialized, the element
+ * will be freed using the custom (*free) function as well.
+ */
+void asn_set_del(void *asn_set_of_x, int number, int _do_free);
+
+/*
+ * Empty the contents of the set. Will free the elements, if (*free) is given.
+ * Will NOT free the set itself.
+ */
+void asn_set_empty(void *asn_set_of_x);
+
+/*
+ * Cope with different conversions requirements to/from void in C and C++.
+ * This is mostly useful for support library.
+ */
+typedef A_SET_OF(void) asn_anonymous_set_;
+#define _A_SET_FROM_VOID(ptr)		((asn_anonymous_set_ *)(ptr))
+#define _A_CSET_FROM_VOID(ptr)		((const asn_anonymous_set_ *)(ptr))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_SET_OF_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_application.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_application.c
new file mode 100644
index 000000000..f4d9d0e1d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_application.c
@@ -0,0 +1,556 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_application.h"
+#include <errno.h>
+
+static asn_enc_rval_t asn_encode_internal(const asn_codec_ctx_t *opt_codec_ctx,
+                                          enum asn_transfer_syntax syntax,
+                                          const asn_TYPE_descriptor_t *td,
+                                          const void *sptr,
+                                          asn_app_consume_bytes_f *callback,
+                                          void *callback_key);
+
+
+struct callback_count_bytes_key {
+    asn_app_consume_bytes_f *callback;
+    void *callback_key;
+    size_t computed_size;
+};
+
+/*
+ * Encoder which just counts bytes that come through it.
+ */
+static int
+callback_count_bytes_cb(const void *data, size_t size, void *keyp) {
+    struct callback_count_bytes_key *key = keyp;
+    int ret;
+
+    ret = key->callback(data, size, key->callback_key);
+    if(ret >= 0) {
+        key->computed_size += size;
+    }
+
+    return ret;
+}
+
+struct overrun_encoder_key {
+    void *buffer;
+    size_t buffer_size;
+    size_t computed_size;
+};
+
+struct dynamic_encoder_key {
+    void *buffer;
+    size_t buffer_size;
+    size_t computed_size;
+};
+
+struct callback_failure_catch_key {
+    asn_app_consume_bytes_f *callback;
+    void *callback_key;
+    int callback_failed;
+};
+
+/*
+ * Encoder which doesn't stop counting bytes
+ * even if it reaches the end of the buffer.
+ */
+static int
+overrun_encoder_cb(const void *data, size_t size, void *keyp) {
+    struct overrun_encoder_key *key = keyp;
+
+    if(key->computed_size + size > key->buffer_size) {
+        /*
+         * Avoid accident on the next call:
+         * stop adding bytes to the buffer.
+         */
+        key->buffer_size = 0;
+    } else {
+        memcpy((char *)key->buffer + key->computed_size, data, size);
+    }
+    key->computed_size += size;
+
+    return 0;
+}
+
+/*
+ * Encoder which dynamically allocates output, and continues
+ * to count even if allocation failed.
+ */
+static int
+dynamic_encoder_cb(const void *data, size_t size, void *keyp) {
+    struct dynamic_encoder_key *key = keyp;
+
+    if(key->buffer) {
+        if(key->computed_size + size >= key->buffer_size) {
+            void *p;
+            size_t new_size = key->buffer_size;
+
+            do {
+                new_size *= 2;
+            } while(new_size <= key->computed_size + size);
+
+            p = REALLOC(key->buffer, new_size);
+            if(p) {
+                key->buffer = p;
+                key->buffer_size = new_size;
+            } else {
+                FREEMEM(key->buffer);
+                key->buffer = 0;
+                key->buffer_size = 0;
+                key->computed_size += size;
+                return 0;
+            }
+        }
+        memcpy((char *)key->buffer + key->computed_size, data, size);
+    }
+
+    key->computed_size += size;
+
+    return 0;
+}
+
+/*
+ * Encoder which help convert the application level encoder failure into EIO.
+ */
+static int
+callback_failure_catch_cb(const void *data, size_t size, void *keyp) {
+    struct callback_failure_catch_key *key = keyp;
+    int ret;
+
+    ret = key->callback(data, size, key->callback_key);
+    if(ret < 0) {
+        key->callback_failed = 1;
+    }
+
+    return ret;
+}
+
+asn_enc_rval_t
+asn_encode(const asn_codec_ctx_t *opt_codec_ctx,
+           enum asn_transfer_syntax syntax, const asn_TYPE_descriptor_t *td,
+           const void *sptr, asn_app_consume_bytes_f *callback, void *callback_key) {
+    struct callback_failure_catch_key cb_key;
+    asn_enc_rval_t er = {0,0,0};
+
+    if(!callback) {
+        errno = EINVAL;
+        ASN__ENCODE_FAILED;
+    }
+
+    cb_key.callback = callback;
+    cb_key.callback_key = callback_key;
+    cb_key.callback_failed = 0;
+
+    er = asn_encode_internal(opt_codec_ctx, syntax, td, sptr,
+                             callback_failure_catch_cb, &cb_key);
+    if(cb_key.callback_failed) {
+        assert(er.encoded == -1);
+        assert(errno == EBADF);
+        errno = EIO;
+    }
+
+    return er;
+}
+
+asn_enc_rval_t
+asn_encode_to_buffer(const asn_codec_ctx_t *opt_codec_ctx,
+                     enum asn_transfer_syntax syntax,
+                     const asn_TYPE_descriptor_t *td, const void *sptr,
+                     void *buffer, size_t buffer_size) {
+    struct overrun_encoder_key buf_key;
+    asn_enc_rval_t er = {0,0,0};
+
+    if(buffer_size > 0 && !buffer) {
+        errno = EINVAL;
+        ASN__ENCODE_FAILED;
+    }
+
+    buf_key.buffer = buffer;
+    buf_key.buffer_size = buffer_size;
+    buf_key.computed_size = 0;
+
+    er = asn_encode_internal(opt_codec_ctx, syntax, td, sptr,
+                             overrun_encoder_cb, &buf_key);
+
+    if(er.encoded >= 0 && (size_t)er.encoded != buf_key.computed_size) {
+        ASN_DEBUG("asn_encode() returned %" ASN_PRI_SSIZE
+                  " yet produced %" ASN_PRI_SIZE " bytes",
+                  er.encoded, buf_key.computed_size);
+        assert(er.encoded < 0 || (size_t)er.encoded == buf_key.computed_size);
+    }
+
+    return er;
+}
+
+asn_encode_to_new_buffer_result_t
+asn_encode_to_new_buffer(const asn_codec_ctx_t *opt_codec_ctx,
+                         enum asn_transfer_syntax syntax,
+                         const asn_TYPE_descriptor_t *td, const void *sptr) {
+    struct dynamic_encoder_key buf_key;
+    asn_encode_to_new_buffer_result_t res;
+
+    buf_key.buffer_size = 16;
+    buf_key.buffer = MALLOC(buf_key.buffer_size);
+    buf_key.computed_size = 0;
+
+    res.result = asn_encode_internal(opt_codec_ctx, syntax, td, sptr,
+                                     dynamic_encoder_cb, &buf_key);
+
+    if(res.result.encoded >= 0
+       && (size_t)res.result.encoded != buf_key.computed_size) {
+        ASN_DEBUG("asn_encode() returned %" ASN_PRI_SSIZE
+                  " yet produced %" ASN_PRI_SIZE " bytes",
+                  res.result.encoded, buf_key.computed_size);
+        assert(res.result.encoded < 0
+               || (size_t)res.result.encoded == buf_key.computed_size);
+    }
+
+    res.buffer = buf_key.buffer;
+
+    /* 0-terminate just in case. */
+    if(res.buffer) {
+        assert(buf_key.computed_size < buf_key.buffer_size);
+        ((char *)res.buffer)[buf_key.computed_size] = '\0';
+    }
+
+    return res;
+}
+
+static asn_enc_rval_t
+asn_encode_internal(const asn_codec_ctx_t *opt_codec_ctx,
+                    enum asn_transfer_syntax syntax,
+                    const asn_TYPE_descriptor_t *td, const void *sptr,
+                    asn_app_consume_bytes_f *callback, void *callback_key) {
+    asn_enc_rval_t er = {0,0,0};
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    enum xer_encoder_flags_e xer_flags = XER_F_CANONICAL;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    enum jer_encoder_flags_e jer_flags = JER_F;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+    (void)opt_codec_ctx; /* Parameters are not checked on encode yet. */
+
+    if(!td || !sptr) {
+        errno = EINVAL;
+        ASN__ENCODE_FAILED;
+    }
+
+    switch(syntax) {
+    case ATS_NONSTANDARD_PLAINTEXT:
+        if(td->op->print_struct) {
+            struct callback_count_bytes_key cb_key;
+            cb_key.callback = callback;
+            cb_key.callback_key = callback_key;
+            cb_key.computed_size = 0;
+            if(td->op->print_struct(td, sptr, 1, callback_count_bytes_cb,
+                                    &cb_key)
+                   < 0
+               || callback_count_bytes_cb("\n", 1, &cb_key) < 0) {
+                errno = EBADF; /* Structure has incorrect form. */
+                er.encoded = -1;
+                er.failed_type = td;
+                er.structure_ptr = sptr;
+            } else {
+                er.encoded = cb_key.computed_size;
+                er.failed_type = 0;
+                er.structure_ptr = 0;
+            }
+        } else {
+            errno = ENOENT; /* Transfer syntax is not defined for this type. */
+            ASN__ENCODE_FAILED;
+        }
+        break;
+
+    case ATS_RANDOM:
+        errno = ENOENT; /* Randomization doesn't make sense on output. */
+        ASN__ENCODE_FAILED;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    case ATS_BER:
+        /* BER is a superset of DER. */
+        /* Fall through. */
+    case ATS_DER:
+        if(td->op->der_encoder) {
+            er = der_encode(td, sptr, callback, callback_key);
+            if(er.encoded == -1) {
+                if(er.failed_type && er.failed_type->op->der_encoder) {
+                    errno = EBADF;   /* Structure has incorrect form. */
+                } else {
+                    errno = ENOENT;  /* DER is not defined for this type. */
+                }
+            }
+        } else {
+            errno = ENOENT;  /* Transfer syntax is not defined for this type. */
+            ASN__ENCODE_FAILED;
+        }
+        break;
+    case ATS_CER:
+        errno = ENOENT;  /* Transfer syntax is not defined for any type. */
+        ASN__ENCODE_FAILED;
+#else
+    case ATS_BER:
+    case ATS_DER:
+    case ATS_CER:
+        errno = ENOENT;  /* BER is not defined. */
+        ASN__ENCODE_FAILED;
+
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    case ATS_BASIC_OER:
+        /* CANONICAL-OER is a superset of BASIC-OER. */
+        /* Fall through. */
+    case ATS_CANONICAL_OER:
+        if(td->op->oer_encoder) {
+            er = oer_encode(td, sptr, callback, callback_key);
+            if(er.encoded == -1) {
+                if(er.failed_type && er.failed_type->op->oer_encoder) {
+                    errno = EBADF;   /* Structure has incorrect form. */
+                } else {
+                    errno = ENOENT;  /* OER is not defined for this type. */
+                }
+            }
+        } else {
+            errno = ENOENT;  /* Transfer syntax is not defined for this type. */
+            ASN__ENCODE_FAILED;
+        }
+        break;
+#else
+    case ATS_BASIC_OER:
+    case ATS_CANONICAL_OER:
+        errno = ENOENT;  /* OER is not defined. */
+        ASN__ENCODE_FAILED;
+        break;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    case ATS_UNALIGNED_BASIC_PER:
+        /* CANONICAL-UPER is a superset of BASIC-UPER. */
+        /* Fall through. */
+    case ATS_UNALIGNED_CANONICAL_PER:
+        if(td->op->uper_encoder) {
+            er = uper_encode(td, 0, sptr, callback, callback_key);
+            if(er.encoded == -1) {
+                if(er.failed_type && er.failed_type->op->uper_encoder) {
+                    errno = EBADF;   /* Structure has incorrect form. */
+                } else {
+                    errno = ENOENT;  /* UPER is not defined for this type. */
+                }
+            } else {
+                ASN_DEBUG("Complete encoded in %ld bits", (long)er.encoded);
+                if(er.encoded == 0) {
+                    /* Enforce "Complete Encoding" of X.691 #11.1 */
+                    if(callback("\0", 1, callback_key) < 0) {
+                        errno = EBADF;
+                        ASN__ENCODE_FAILED;
+                    }
+                    er.encoded = 8;  /* Exactly 8 zero bits is added. */
+                }
+                /* Convert bits into bytes */
+                er.encoded = (er.encoded + 7) >> 3;
+            }
+        } else {
+            errno = ENOENT;  /* Transfer syntax is not defined for this type. */
+            ASN__ENCODE_FAILED;
+        }
+        break;
+#else
+    case ATS_UNALIGNED_BASIC_PER:
+    case ATS_UNALIGNED_CANONICAL_PER:
+        errno = ENOENT;  /* UPER is not defined. */
+        ASN__ENCODE_FAILED;
+        break;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    case ATS_ALIGNED_BASIC_PER:
+        /* CANONICAL-APER is a superset of BASIC-APER. */
+        /* Fall through. */
+    case ATS_ALIGNED_CANONICAL_PER:
+        if(td->op->aper_encoder) {
+            er = aper_encode(td, 0, sptr, callback, callback_key);
+            if(er.encoded == -1) {
+                if(er.failed_type && er.failed_type->op->aper_encoder) {
+                    errno = EBADF;   /* Structure has incorrect form. */
+                } else {
+                    errno = ENOENT;  /* APER is not defined for this type. */
+                }
+            } else {
+                ASN_DEBUG("Complete encoded in %ld bits", (long)er.encoded);
+                if(er.encoded == 0) {
+                    /* Enforce "Complete Encoding" of X.691 #11.1 */
+                    if(callback("\0", 1, callback_key) < 0) {
+                        errno = EBADF;
+                        ASN__ENCODE_FAILED;
+                    }
+                    er.encoded = 8;  /* Exactly 8 zero bits is added. */
+                }
+                /* Convert bits into bytes */
+                er.encoded = (er.encoded + 7) >> 3;
+            }
+        } else {
+            errno = ENOENT;  /* Transfer syntax is not defined for this type. */
+            ASN__ENCODE_FAILED;
+        }
+        break;
+#else
+    case ATS_ALIGNED_BASIC_PER:
+    case ATS_ALIGNED_CANONICAL_PER:
+        errno = ENOENT;  /* APER is not defined. */
+        ASN__ENCODE_FAILED;
+        break;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    case ATS_BASIC_XER:
+        /* CANONICAL-XER is a superset of BASIC-XER. */
+        xer_flags &= ~XER_F_CANONICAL;
+        xer_flags |= XER_F_BASIC;
+        /* Fall through. */
+    case ATS_CANONICAL_XER:
+        if(td->op->xer_encoder) {
+            er = xer_encode(td, sptr, xer_flags, callback, callback_key);
+            if(er.encoded == -1) {
+                if(er.failed_type && er.failed_type->op->xer_encoder) {
+                    errno = EBADF;   /* Structure has incorrect form. */
+                } else {
+                    errno = ENOENT;  /* XER is not defined for this type. */
+                }
+            }
+        } else {
+            errno = ENOENT;  /* Transfer syntax is not defined for this type. */
+            ASN__ENCODE_FAILED;
+        }
+        break;
+#else
+    case ATS_BASIC_XER:
+    case ATS_CANONICAL_XER:
+        errno = ENOENT;  /* XER is not defined. */
+        ASN__ENCODE_FAILED;
+        break;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    case ATS_JER_MINIFIED:
+        /* Currently JER_F and JER_F_MINIFIED have opposite purposes
+        *  so we just flip the flag. */
+        jer_flags &= ~JER_F;
+        jer_flags |= JER_F_MINIFIED;
+        /* Fall through. */
+    case ATS_JER:
+        if(td->op->jer_encoder) {
+            er = jer_encode(td, sptr, jer_flags, callback, callback_key);
+            if(er.encoded == -1) {
+                if(er.failed_type && er.failed_type->op->jer_encoder) {
+                    errno = EBADF;   /* Structure has incorrect form. */
+                } else {
+                    errno = ENOENT;  /* JER is not defined for this type. */
+                }
+            }
+        } else {
+            errno = ENOENT;  /* Transfer syntax is not defined for this type. */
+            ASN__ENCODE_FAILED;
+        }
+        break;
+#endif /* !defined(ASN_DISABLE_JER_SUPPORT) */
+    default:
+        errno = ENOENT;
+        ASN__ENCODE_FAILED;
+    }
+
+    return er;
+}
+
+asn_dec_rval_t
+asn_decode(const asn_codec_ctx_t *opt_codec_ctx,
+           enum asn_transfer_syntax syntax, const asn_TYPE_descriptor_t *td,
+           void **sptr, const void *buffer, size_t size) {
+    if(!td || !td->op || !sptr || (size && !buffer)) {
+        ASN__DECODE_FAILED;
+    }
+
+    switch(syntax) {
+    case ATS_CER:
+    case ATS_NONSTANDARD_PLAINTEXT:
+    default:
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+
+    case ATS_RANDOM:
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+        if(!td->op->random_fill) {
+            ASN__DECODE_FAILED;
+        } else {
+            if(asn_random_fill(td, sptr, 16000) == 0) {
+                asn_dec_rval_t ret = {RC_OK, 0};
+                return ret;
+            } else {
+                ASN__DECODE_FAILED;
+            }
+        }
+        break;
+#else
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+    case ATS_DER:
+    case ATS_BER:
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+        return ber_decode(opt_codec_ctx, td, sptr, buffer, size);
+#else
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+    case ATS_BASIC_OER:
+    case ATS_CANONICAL_OER:
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+        return oer_decode(opt_codec_ctx, td, sptr, buffer, size);
+#else
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+    case ATS_UNALIGNED_BASIC_PER:
+    case ATS_UNALIGNED_CANONICAL_PER:
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+        return uper_decode_complete(opt_codec_ctx, td, sptr, buffer, size);
+#else
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+
+    case ATS_ALIGNED_BASIC_PER:
+    case ATS_ALIGNED_CANONICAL_PER:
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+        return aper_decode_complete(opt_codec_ctx, td, sptr, buffer, size);
+#else
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+    case ATS_BASIC_XER:
+    case ATS_CANONICAL_XER:
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+        return xer_decode(opt_codec_ctx, td, sptr, buffer, size);
+#else
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+    case ATS_JER:
+    case ATS_JER_MINIFIED:
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+        return jer_decode(opt_codec_ctx, td, sptr, buffer, size);
+#else
+        errno = ENOENT;
+        ASN__DECODE_FAILED;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+    }
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_application.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_application.h
new file mode 100644
index 000000000..355bc8458
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_application.h
@@ -0,0 +1,179 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * Application-level ASN.1 callbacks.
+ */
+#ifndef	ASN_APPLICATION_H
+#define	ASN_APPLICATION_H
+
+#include "asn_system.h"		/* for platform-dependent types */
+#include "asn_codecs.h"		/* for ASN.1 codecs specifics */
+#include "asn_config.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * A selection of ASN.1 Transfer Syntaxes to use with generalized
+ * encoders and decoders declared further in this .h file.
+ */
+enum asn_transfer_syntax {
+    /* Avoid appearance of a default transfer syntax. */
+    ATS_INVALID = 0,
+    /* Plaintext output (not conforming to any standard), for debugging. */
+    ATS_NONSTANDARD_PLAINTEXT,
+    /* Returns a randomly generated structure. */
+    ATS_RANDOM,
+    /*
+     * X.690:
+     * BER: Basic Encoding Rules.
+     * DER: Distinguished Encoding Rules.
+     * CER: Canonical Encoding Rules.
+     * DER and CER are more strict variants of BER.
+     */
+    ATS_BER,
+    ATS_DER,
+    ATS_CER, /* Only decoding is supported */
+    /*
+     * X.696:
+     * OER: Octet Encoding Rules.
+     * CANONICAL-OER is a more strict variant of BASIC-OER.
+     */
+    ATS_BASIC_OER,
+    ATS_CANONICAL_OER,
+    /*
+     * X.691:
+     * PER: Packed Encoding Rules.
+     * CANONICAL-PER is a more strict variant of BASIC-PER.
+     * NOTE: Produces or consumes a complete encoding (X.691 (08/2015) #11.1).
+     */
+    ATS_UNALIGNED_BASIC_PER,
+    ATS_UNALIGNED_CANONICAL_PER,
+    ATS_ALIGNED_BASIC_PER,
+    ATS_ALIGNED_CANONICAL_PER,
+    /*
+     * X.693:
+     * XER: XML Encoding Rules.
+     * CANONICAL-XER is a more strict variant of BASIC-XER.
+     */
+    ATS_BASIC_XER,
+    ATS_CANONICAL_XER,
+    /*
+     * X.697:
+     * JER: JSON Encoding Rules.
+     * MINIFIED produces a whitespace-free JSON.
+     */
+    ATS_JER,
+    ATS_JER_MINIFIED,
+};
+
+/*
+ * A generic encoder for any supported transfer syntax.
+ * RETURN VALUES:
+ * The (.encoded) field of the return value is REDEFINED to mean the following:
+ * >=0: The computed size of the encoded data. Can exceed the (buffer_size).
+ *  -1: Error encoding the structure. See the error code in (errno):
+ *      EINVAL: Incorrect parameters to the function, such as NULLs.
+ *      ENOENT: Encoding transfer syntax is not defined (for this type).
+ *      EBADF:  The structure has invalid form or content constraint failed.
+ *      The (.failed_type) and (.structure_ptr) MIGHT be set to the appropriate
+ *      values at the place of failure, if at all possible.
+ * WARNING: The (.encoded) field of the return value can exceed the buffer_size.
+ * This is similar to snprintf(3) contract which might return values
+ * greater than the buffer size.
+ */
+asn_enc_rval_t asn_encode_to_buffer(
+    const asn_codec_ctx_t *opt_codec_parameters, /* See asn_codecs.h */
+    enum asn_transfer_syntax,
+    const struct asn_TYPE_descriptor_s *type_to_encode,
+    const void *structure_to_encode, void *buffer, size_t buffer_size);
+
+/*
+ * A variant of asn_encode_to_buffer() with automatically allocated buffer.
+ * RETURN VALUES:
+ * On success, returns a newly allocated (.buffer) containing the whole message.
+ * The message size is returned in (.result.encoded).
+ * On failure:
+ *  (.buffer) is NULL,
+ *  (.result.encoded) as in asn_encode_to_buffer(),
+ *  The errno codes as in asn_encode_to_buffer(), plus the following:
+ *      ENOMEM: Memory allocation failed due to system or internal limits.
+ * The user is responsible for freeing the (.buffer).
+ */
+typedef struct asn_encode_to_new_buffer_result_s {
+    void *buffer;   /* NULL if failed to encode. */
+    asn_enc_rval_t result;
+} asn_encode_to_new_buffer_result_t;
+asn_encode_to_new_buffer_result_t asn_encode_to_new_buffer(
+    const asn_codec_ctx_t *opt_codec_parameters, /* See asn_codecs.h */
+    enum asn_transfer_syntax,
+    const struct asn_TYPE_descriptor_s *type_to_encode,
+    const void *structure_to_encode);
+
+
+/*
+ * Generic type of an application-defined callback to return various
+ * types of data to the application.
+ * EXPECTED RETURN VALUES:
+ *  -1: Failed to consume bytes. Abort the mission.
+ * Non-negative return values indicate success, and ignored.
+ */
+typedef int(asn_app_consume_bytes_f)(const void *buffer, size_t size,
+                                     void *application_specific_key);
+
+
+/*
+ * A generic encoder for any supported transfer syntax.
+ * Returns the comprehensive encoding result descriptor (see asn_codecs.h).
+ * RETURN VALUES:
+ * The negative (.encoded) field of the return values is accompanied with the
+ * following error codes (errno):
+ *      EINVAL: Incorrect parameters to the function, such as NULLs.
+ *      ENOENT: Encoding transfer syntax is not defined (for this type).
+ *      EBADF:  The structure has invalid form or content constraint failed.
+ *      EIO:    The (callback) has returned negative value during encoding.
+ */
+asn_enc_rval_t asn_encode(
+    const asn_codec_ctx_t *opt_codec_parameters, /* See asn_codecs.h */
+    enum asn_transfer_syntax,
+    const struct asn_TYPE_descriptor_s *type_to_encode,
+    const void *structure_to_encode,
+    asn_app_consume_bytes_f *callback, void *callback_key);
+
+
+/*
+ * A generic decoder for any supported transfer syntax.
+ */
+asn_dec_rval_t asn_decode(
+    const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax,
+    const struct asn_TYPE_descriptor_s *type_to_decode,
+    void **structure_ptr, /* Pointer to a target structure's pointer */
+    const void *buffer,   /* Data to be decoded */
+    size_t size           /* Size of that buffer */
+);
+
+
+/*
+ * A callback of this type is called whenever constraint validation fails
+ * on some ASN.1 type. See "constraints.h" for more details on constraint
+ * validation.
+ * This callback specifies a descriptor of the ASN.1 type which failed
+ * the constraint check, as well as human readable message on what
+ * particular constraint has failed.
+ */
+typedef void (asn_app_constraint_failed_f)(void *application_specific_key,
+	const struct asn_TYPE_descriptor_s *type_descriptor_which_failed,
+	const void *structure_which_failed_ptr,
+	const char *error_message_format, ...) CC_PRINTFLIKE(4, 5);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#include "constr_TYPE.h"	/* for asn_TYPE_descriptor_t */
+
+#endif	/* ASN_APPLICATION_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_bit_data.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_bit_data.c
new file mode 100644
index 000000000..8641ed9d6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_bit_data.c
@@ -0,0 +1,333 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_system.h"
+#include "asn_internal.h"
+#include "asn_bit_data.h"
+
+/*
+ * Create a contiguous non-refillable bit data structure.
+ * Can be freed by FREEMEM().
+ */
+asn_bit_data_t *
+asn_bit_data_new_contiguous(const void *data, size_t size_bits) {
+    size_t size_bytes = (size_bits + 7) / 8;
+    asn_bit_data_t *pd;
+    uint8_t *bytes;
+
+    /* Get the extensions map */
+    pd = CALLOC(1, sizeof(*pd) + size_bytes + 1);
+    if(!pd) {
+        return NULL;
+    }
+    bytes = (void *)(((char *)pd) + sizeof(*pd));
+    memcpy(bytes, data, size_bytes);
+    bytes[size_bytes] = 0;
+    pd->buffer = bytes;
+    pd->nboff = 0;
+    pd->nbits = size_bits;
+
+    return pd;
+}
+
+
+char *
+asn_bit_data_string(asn_bit_data_t *pd) {
+	static char buf[2][32];
+	static int n;
+	n = (n+1) % 2;
+    snprintf(buf[n], sizeof(buf[n]),
+             "{m=%" ASN_PRI_SIZE " span %" ASN_PRI_SIZE "[%" ASN_PRI_SIZE
+             "..%" ASN_PRI_SIZE "] (%" ASN_PRI_SIZE ")}",
+             pd->moved, ((uintptr_t)(pd->buffer) & 0xf), pd->nboff, pd->nbits,
+             pd->nbits - pd->nboff);
+    return buf[n];
+}
+
+void
+asn_get_undo(asn_bit_data_t *pd, int nbits) {
+	if((ssize_t)pd->nboff < nbits) {
+		assert((ssize_t)pd->nboff < nbits);
+	} else {
+		pd->nboff -= nbits;
+		pd->moved -= nbits;
+	}
+}
+
+/*
+ * Extract a small number of bits (<= 31) from the specified PER data pointer.
+ */
+int32_t
+asn_get_few_bits(asn_bit_data_t *pd, int nbits) {
+	size_t off;	/* Next after last bit offset */
+	ssize_t nleft;	/* Number of bits left in this stream */
+	uint32_t accum;
+	const uint8_t *buf;
+
+	if(nbits < 0)
+		return -1;
+
+	nleft = pd->nbits - pd->nboff;
+	if(nbits > nleft) {
+		int32_t tailv, vhead;
+		if(!pd->refill || nbits > 31) return -1;
+		/* Accumulate unused bytes before refill */
+		ASN_DEBUG("Obtain the rest %d bits (want %d)",
+			(int)nleft, (int)nbits);
+		tailv = asn_get_few_bits(pd, nleft);
+		if(tailv < 0) return -1;
+		/* Refill (replace pd contents with new data) */
+		if(pd->refill(pd))
+			return -1;
+		nbits -= nleft;
+		vhead = asn_get_few_bits(pd, nbits);
+		/* Combine the rest of previous pd with the head of new one */
+		tailv = (tailv << nbits) | vhead;  /* Could == -1 */
+		return tailv;
+	}
+
+	/*
+	 * Normalize position indicator.
+	 */
+	if(pd->nboff >= 8) {
+		pd->buffer += (pd->nboff >> 3);
+		pd->nbits  -= (pd->nboff & ~0x07);
+		pd->nboff  &= 0x07;
+	}
+	pd->moved += nbits;
+	pd->nboff += nbits;
+	off = pd->nboff;
+	buf = pd->buffer;
+
+	/*
+	 * Extract specified number of bits.
+	 */
+	if(off <= 8)
+		accum = nbits ? (buf[0]) >> (8 - off) : 0;
+	else if(off <= 16)
+		accum = ((buf[0] << 8) + buf[1]) >> (16 - off);
+	else if(off <= 24)
+		accum = ((buf[0] << 16) + (buf[1] << 8) + buf[2]) >> (24 - off);
+	else if(off <= 31)
+		accum = (((uint32_t)buf[0] << 24) + (buf[1] << 16)
+			+ (buf[2] << 8) + (buf[3])) >> (32 - off);
+	else if(nbits <= 31) {
+		asn_bit_data_t tpd = *pd;
+		/* Here are we with our 31-bits limit plus 1..7 bits offset. */
+		asn_get_undo(&tpd, nbits);
+		/* The number of available bits in the stream allow
+		 * for the following operations to take place without
+		 * invoking the ->refill() function */
+		accum  = asn_get_few_bits(&tpd, nbits - 24) << 24;
+		accum |= asn_get_few_bits(&tpd, 24);
+	} else {
+		asn_get_undo(pd, nbits);
+		return -1;
+	}
+
+	accum &= (((uint32_t)1 << nbits) - 1);
+
+	ASN_DEBUG("  [PER got %2d<=%2d bits => span %d %+ld[%d..%d]:%02x (%d) => 0x%x]",
+		(int)nbits, (int)nleft,
+		(int)pd->moved,
+		(((long)pd->buffer) & 0xf),
+		(int)pd->nboff, (int)pd->nbits,
+		((pd->buffer != NULL)?pd->buffer[0]:0),
+		(int)(pd->nbits - pd->nboff),
+		(int)accum);
+
+	return accum;
+}
+
+/*
+ * Extract a large number of bits from the specified PER data pointer.
+ */
+int
+asn_get_many_bits(asn_bit_data_t *pd, uint8_t *dst, int alright, int nbits) {
+	int32_t value;
+
+	if(alright && (nbits & 7)) {
+		/* Perform right alignment of a first few bits */
+		value = asn_get_few_bits(pd, nbits & 0x07);
+		if(value < 0) return -1;
+		*dst++ = value;	/* value is already right-aligned */
+		nbits &= ~7;
+	}
+
+	while(nbits) {
+		if(nbits >= 24) {
+			value = asn_get_few_bits(pd, 24);
+			if(value < 0) return -1;
+			*(dst++) = value >> 16;
+			*(dst++) = value >> 8;
+			*(dst++) = value;
+			nbits -= 24;
+		} else {
+			value = asn_get_few_bits(pd, nbits);
+			if(value < 0) return -1;
+			if(nbits & 7) {	/* implies left alignment */
+				value <<= 8 - (nbits & 7),
+				nbits += 8 - (nbits & 7);
+				if(nbits > 24)
+					*dst++ = value >> 24;
+			}
+			if(nbits > 16)
+				*dst++ = value >> 16;
+			if(nbits > 8)
+				*dst++ = value >> 8;
+			*dst++ = value;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Put a small number of bits (<= 31).
+ */
+int
+asn_put_few_bits(asn_bit_outp_t *po, uint32_t bits, int obits) {
+	size_t off;	/* Next after last bit offset */
+	size_t omsk;	/* Existing last byte meaningful bits mask */
+	uint8_t *buf;
+
+	if(obits <= 0 || obits >= 32) return obits ? -1 : 0;
+
+	ASN_DEBUG("[PER put %d bits %x to %p+%d bits]",
+			obits, (int)bits, (void *)po->buffer, (int)po->nboff);
+
+	/*
+	 * Normalize position indicator.
+	 */
+	if(po->nboff >= 8) {
+		po->buffer += (po->nboff >> 3);
+		po->nbits  -= (po->nboff & ~0x07);
+		po->nboff  &= 0x07;
+	}
+
+	/*
+	 * Flush whole-bytes output, if necessary.
+	 */
+	if(po->nboff + obits > po->nbits) {
+		size_t complete_bytes;
+		if(!po->buffer) po->buffer = po->tmpspace;
+		complete_bytes = (po->buffer - po->tmpspace);
+		ASN_DEBUG("[PER output %ld complete + %ld]",
+			(long)complete_bytes, (long)po->flushed_bytes);
+		if(po->output(po->tmpspace, complete_bytes, po->op_key) < 0)
+			return -1;
+		if(po->nboff)
+			po->tmpspace[0] = po->buffer[0];
+		po->buffer = po->tmpspace;
+		po->nbits = 8 * sizeof(po->tmpspace);
+		po->flushed_bytes += complete_bytes;
+	}
+
+	/*
+	 * Now, due to sizeof(tmpspace), we are guaranteed large enough space.
+	 */
+	buf = po->buffer;
+	omsk = ~((1 << (8 - po->nboff)) - 1);
+	off = (po->nboff + obits);
+
+	/* Clear data of debris before meaningful bits */
+	bits &= (((uint32_t)1 << obits) - 1);
+
+	ASN_DEBUG("[PER out %d %u/%x (t=%d,o=%d) %x&%x=%x]", obits,
+		(int)bits, (int)bits,
+		(int)po->nboff, (int)off,
+		buf[0], (int)(omsk&0xff),
+		(int)(buf[0] & omsk));
+
+	if(off <= 8)	/* Completely within 1 byte */
+		po->nboff = off,
+		bits <<= (8 - off),
+		buf[0] = (buf[0] & omsk) | bits;
+	else if(off <= 16)
+		po->nboff = off,
+		bits <<= (16 - off),
+		buf[0] = (buf[0] & omsk) | (bits >> 8),
+		buf[1] = bits;
+	else if(off <= 24)
+		po->nboff = off,
+		bits <<= (24 - off),
+		buf[0] = (buf[0] & omsk) | (bits >> 16),
+		buf[1] = bits >> 8,
+		buf[2] = bits;
+	else if(off <= 31)
+		po->nboff = off,
+		bits <<= (32 - off),
+		buf[0] = (buf[0] & omsk) | (bits >> 24),
+		buf[1] = bits >> 16,
+		buf[2] = bits >> 8,
+		buf[3] = bits;
+	else {
+		if(asn_put_few_bits(po, bits >> (obits - 24), 24)) return -1;
+		if(asn_put_few_bits(po, bits, obits - 24)) return -1;
+	}
+
+	ASN_DEBUG("[PER out %u/%x => %02x buf+%ld]",
+		(int)bits, (int)bits, buf[0],
+		(long)(po->buffer - po->tmpspace));
+
+	return 0;
+}
+
+
+/*
+ * Output a large number of bits.
+ */
+int
+asn_put_many_bits(asn_bit_outp_t *po, const uint8_t *src, int nbits) {
+
+	while(nbits) {
+		uint32_t value;
+
+		if(nbits >= 24) {
+			value = (src[0] << 16) | (src[1] << 8) | src[2];
+			src += 3;
+			nbits -= 24;
+			if(asn_put_few_bits(po, value, 24))
+				return -1;
+		} else {
+			value = src[0];
+			if(nbits > 8)
+				value = (value << 8) | src[1];
+			if(nbits > 16)
+				value = (value << 8) | src[2];
+			if(nbits & 0x07)
+				value >>= (8 - (nbits & 0x07));
+			if(asn_put_few_bits(po, value, nbits))
+				return -1;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+
+int
+asn_put_aligned_flush(asn_bit_outp_t *po) {
+    uint32_t unused_bits = (0x7 & (8 - (po->nboff & 0x07)));
+    size_t complete_bytes =
+        (po->buffer ? po->buffer - po->tmpspace : 0) + ((po->nboff + 7) >> 3);
+
+    if(unused_bits) {
+        po->buffer[po->nboff >> 3] &= ~0u << unused_bits;
+    }
+
+    if(po->output(po->tmpspace, complete_bytes, po->op_key) < 0) {
+        return -1;
+    } else {
+        po->buffer = po->tmpspace;
+        po->nboff = 0;
+        po->nbits = 8 * sizeof(po->tmpspace);
+        po->flushed_bytes += complete_bytes;
+        return 0;
+    }
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_bit_data.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_bit_data.h
new file mode 100644
index 000000000..222f4fed2
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_bit_data.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN_BIT_DATA
+#define	ASN_BIT_DATA
+
+#include "asn_system.h"		/* Platform-specific types */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * This structure describes a position inside an incoming PER bit stream.
+ */
+typedef struct asn_bit_data_s {
+  const uint8_t *buffer;  /* Pointer to the octet stream */
+         size_t  nboff;   /* Bit offset to the meaningful bit */
+         size_t  nbits;   /* Number of bits in the stream */
+         size_t  moved;   /* Number of bits moved through this bit stream */
+  int (*refill)(struct asn_bit_data_s *);
+  void *refill_key;
+} asn_bit_data_t;
+
+/*
+ * Create a contiguous non-refillable bit data structure.
+ * Can be freed by FREEMEM().
+ */
+asn_bit_data_t *asn_bit_data_new_contiguous(const void *data, size_t size_bits);
+
+/*
+ * Extract a small number of bits (<= 31) from the specified PER data pointer.
+ * This function returns -1 if the specified number of bits could not be
+ * extracted due to EOD or other conditions.
+ */
+int32_t asn_get_few_bits(asn_bit_data_t *, int get_nbits);
+
+/* Undo the immediately preceding "get_few_bits" operation */
+void asn_get_undo(asn_bit_data_t *, int get_nbits);
+
+/*
+ * Extract a large number of bits from the specified PER data pointer.
+ * This function returns -1 if the specified number of bits could not be
+ * extracted due to EOD or other conditions.
+ */
+int asn_get_many_bits(asn_bit_data_t *, uint8_t *dst, int right_align,
+			int get_nbits);
+
+/* Non-thread-safe debugging function, don't use it */
+char *asn_bit_data_string(asn_bit_data_t *);
+
+/*
+ * This structure supports forming bit output.
+ */
+typedef struct asn_bit_outp_s {
+	uint8_t *buffer;	/* Pointer into the (tmpspace) */
+	size_t nboff;		/* Bit offset to the meaningful bit */
+	size_t nbits;		/* Number of bits left in (tmpspace) */
+	uint8_t tmpspace[32];	/* Preliminary storage to hold data */
+	int (*output)(const void *data, size_t size, void *op_key);
+	void *op_key;		/* Key for (output) data callback */
+	size_t flushed_bytes;	/* Bytes already flushed through (output) */
+} asn_bit_outp_t;
+
+/* Output a small number of bits (<= 31) */
+int asn_put_few_bits(asn_bit_outp_t *, uint32_t bits, int obits);
+
+/* Output a large number of bits */
+int asn_put_many_bits(asn_bit_outp_t *, const uint8_t *src, int put_nbits);
+
+/*
+ * Flush whole bytes (0 or more) through (outper) member.
+ * The least significant bits which are not used are guaranteed to be set to 0.
+ * Returns -1 if callback returns -1. Otherwise, 0.
+ */
+int asn_put_aligned_flush(asn_bit_outp_t *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_BIT_DATA */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs.h
new file mode 100644
index 000000000..e75c2709c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN_CODECS_H
+#define	ASN_CODECS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * This structure defines a set of parameters that may be passed
+ * to every ASN.1 encoder or decoder function.
+ * WARNING: if max_stack_size member is set, and you are calling the
+ *   function pointers of the asn_TYPE_descriptor_t directly,
+ *   this structure must be ALLOCATED ON THE STACK!
+ *   If you can't always satisfy this requirement, use ber_decode(),
+ *   xer_decode() and uper_decode() functions instead.
+ */
+typedef struct asn_codec_ctx_s {
+	/*
+	 * Limit the decoder routines to use no (much) more stack than a given
+	 * number of bytes. Most of decoders are stack-based, and this
+	 * would protect against stack overflows if the number of nested
+	 * encodings is high.
+	 * The OCTET STRING, BIT STRING and ANY BER decoders are heap-based,
+	 * and are safe from this kind of overflow.
+	 * A value from getrlimit(RLIMIT_STACK) may be used to initialize
+	 * this variable. Be careful in multithreaded environments, as the
+	 * stack size is rather limited.
+	 */
+	size_t  max_stack_size; /* 0 disables stack bounds checking */
+} asn_codec_ctx_t;
+
+/*
+ * Type of the return value of the encoding functions (der_encode, xer_encode).
+ */
+typedef struct asn_enc_rval_s {
+	/*
+	 * Number of bytes encoded.
+	 * -1 indicates failure to encode the structure.
+	 * In this case, the members below this one are meaningful.
+	 */
+	ssize_t encoded;
+
+	/*
+	 * Members meaningful when (encoded == -1), for post mortem analysis.
+	 */
+
+	/* Type which cannot be encoded */
+	const struct asn_TYPE_descriptor_s *failed_type;
+
+	/* Pointer to the structure of that type */
+	const void *structure_ptr;
+} asn_enc_rval_t;
+#define	ASN__ENCODE_FAILED do {					\
+	asn_enc_rval_t tmp_error;				\
+	tmp_error.encoded = -1;					\
+	tmp_error.failed_type = td;				\
+	tmp_error.structure_ptr = sptr;				\
+	ASN_DEBUG("Failed to encode element %s", td ? td->name : "");	\
+	return tmp_error;					\
+} while(0)
+#define	ASN__ENCODED_OK(rval) do {				\
+	rval.structure_ptr = 0;					\
+	rval.failed_type = 0;					\
+	return rval;						\
+} while(0)
+
+/*
+ * Type of the return value of the decoding functions (ber_decode, xer_decode)
+ * 
+ * Please note that the number of consumed bytes is ALWAYS meaningful,
+ * even if code==RC_FAIL. This is to indicate the number of successfully
+ * decoded bytes, hence providing a possibility to fail with more diagnostics
+ * (i.e., print the offending remainder of the buffer).
+ */
+enum asn_dec_rval_code_e {
+	RC_OK,		/* Decoded successfully */
+	RC_WMORE,	/* More data expected, call again */
+	RC_FAIL		/* Failure to decode data */
+};
+typedef struct asn_dec_rval_s {
+	enum asn_dec_rval_code_e code;	/* Result code */
+	size_t consumed;		/* Number of bytes consumed */
+} asn_dec_rval_t;
+#define	ASN__DECODE_FAILED do {					\
+	asn_dec_rval_t tmp_error;				\
+	tmp_error.code = RC_FAIL;				\
+	tmp_error.consumed = 0;					\
+	ASN_DEBUG("Failed to decode element %s", td ? td->name : "");	\
+	return tmp_error;					\
+} while(0)
+#define	ASN__DECODE_STARVED do {				\
+	asn_dec_rval_t tmp_error;				\
+	tmp_error.code = RC_WMORE;				\
+	tmp_error.consumed = 0;					\
+	return tmp_error;					\
+} while(0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_CODECS_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim.c
new file mode 100644
index 000000000..a07c82990
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim.c
@@ -0,0 +1,31 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+
+void
+ASN__PRIMITIVE_TYPE_free(const asn_TYPE_descriptor_t *td, void *sptr,
+                         enum asn_struct_free_method method) {
+    ASN__PRIMITIVE_TYPE_t *st = (ASN__PRIMITIVE_TYPE_t *)sptr;
+
+	if(!td || !sptr)
+		return;
+
+	ASN_DEBUG("Freeing %s as a primitive type", td->name);
+
+	if(st->buf)
+		FREEMEM(st->buf);
+
+    switch(method) {
+    case ASFM_FREE_EVERYTHING:
+        FREEMEM(sptr);
+        break;
+    case ASFM_FREE_UNDERLYING:
+        break;
+    case ASFM_FREE_UNDERLYING_AND_RESET:
+        memset(sptr, 0, sizeof(ASN__PRIMITIVE_TYPE_t));
+        break;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim.h
new file mode 100644
index 000000000..231a35f1c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim.h
@@ -0,0 +1,82 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN_CODECS_PRIM_H
+#define	ASN_CODECS_PRIM_H
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct ASN__PRIMITIVE_TYPE_s {
+    uint8_t *buf;  /* Buffer with consecutive primitive encoding bytes */
+    size_t size;   /* Size of the buffer */
+} ASN__PRIMITIVE_TYPE_t;  /* Do not use this type directly! */
+
+asn_struct_free_f ASN__PRIMITIVE_TYPE_free;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+ber_type_decoder_f ber_decode_primitive;
+der_type_encoder_f der_encode_primitive;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+/*
+ * A callback specification for the xer_decode_primitive() function below.
+ */
+enum xer_pbd_rval {
+    XPBD_SYSTEM_FAILURE,   /* System failure (memory shortage, etc) */
+    XPBD_DECODER_LIMIT,    /* Hit some decoder limitation or deficiency */
+    XPBD_BROKEN_ENCODING,  /* Encoding of a primitive body is broken */
+    XPBD_NOT_BODY_IGNORE,  /* Not a body format, but safe to ignore */
+    XPBD_BODY_CONSUMED     /* Body is recognized and consumed */
+};
+typedef enum xer_pbd_rval(xer_primitive_body_decoder_f)(
+    const asn_TYPE_descriptor_t *td, void *struct_ptr, const void *chunk_buf,
+    size_t chunk_size);
+
+/*
+ * Specific function to decode simple primitive types.
+ * Also see xer_decode_general() in xer_decoder.h
+ */
+asn_dec_rval_t xer_decode_primitive(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr,
+    size_t struct_size, const char *opt_mname, const void *buf_ptr, size_t size,
+    xer_primitive_body_decoder_f *prim_body_decoder);
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+/*
+ * A callback specification for the jer_decode_primitive() function below.
+ */
+enum jer_pbd_rval {
+    JPBD_SYSTEM_FAILURE,   /* System failure (memory shortage, etc) */
+    JPBD_DECODER_LIMIT,    /* Hit some decoder limitation or deficiency */
+    JPBD_BROKEN_ENCODING,  /* Encoding of a primitive body is broken */
+    JPBD_NOT_BODY_IGNORE,  /* Not a body format, but safe to ignore */
+    JPBD_BODY_CONSUMED     /* Body is recognized and consumed */
+};
+typedef enum jer_pbd_rval(jer_primitive_body_decoder_f)(
+    const asn_TYPE_descriptor_t *td, void *struct_ptr, const void *chunk_buf,
+    size_t chunk_size);
+
+/*
+ * Specific function to decode simple primitive types.
+ * Also see jer_decode_general() in jer_decoder.h
+ */
+asn_dec_rval_t jer_decode_primitive(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr,
+    size_t struct_size, const void *buf_ptr, size_t size,
+    jer_primitive_body_decoder_f *prim_body_decoder);
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_CODECS_PRIM_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_ber.c
new file mode 100644
index 000000000..48fa2c037
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_ber.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+
+/*
+ * Decode an always-primitive type.
+ */
+asn_dec_rval_t
+ber_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td, void **sptr,
+                     const void *buf_ptr, size_t size, int tag_mode) {
+    ASN__PRIMITIVE_TYPE_t *st = (ASN__PRIMITIVE_TYPE_t *)*sptr;
+    asn_dec_rval_t rval;
+    ber_tlv_len_t length = 0;  /* =0 to avoid [incorrect] warning. */
+
+    /*
+     * If the structure is not there, allocate it.
+     */
+    if(st == NULL) {
+        st = (ASN__PRIMITIVE_TYPE_t *)CALLOC(1, sizeof(*st));
+        if(st == NULL) ASN__DECODE_FAILED;
+        *sptr = (void *)st;
+    }
+
+    ASN_DEBUG("Decoding %s as plain primitive (tm=%d)",
+              td->name, tag_mode);
+
+    /*
+     * Check tags and extract value length.
+     */
+    rval = ber_check_tags(opt_codec_ctx, td, 0, buf_ptr, size,
+                          tag_mode, 0, &length, 0);
+    if(rval.code != RC_OK)
+        return rval;
+
+    ASN_DEBUG("%s length is %d bytes", td->name, (int)length);
+
+    /*
+     * Make sure we have this length.
+     */
+    buf_ptr = ((const char *)buf_ptr) + rval.consumed;
+    size -= rval.consumed;
+    if(length > (ber_tlv_len_t)size) {
+        rval.code = RC_WMORE;
+        rval.consumed = 0;
+        return rval;
+    }
+
+    st->size = (int)length;
+    /* The following better be optimized away. */
+    if(sizeof(st->size) != sizeof(length)
+            && (ber_tlv_len_t)st->size != length) {
+        st->size = 0;
+        ASN__DECODE_FAILED;
+    }
+
+    st->buf = (uint8_t *)MALLOC(length + 1);
+    if(!st->buf) {
+        st->size = 0;
+        ASN__DECODE_FAILED;
+    }
+
+    memcpy(st->buf, buf_ptr, length);
+    st->buf[length] = '\0';  /* Just in case */
+
+    rval.code = RC_OK;
+    rval.consumed += length;
+
+    ASN_DEBUG("Took %ld/%ld bytes to encode %s",
+              (long)rval.consumed,
+              (long)length, td->name);
+
+    return rval;
+}
+
+/*
+ * Encode an always-primitive type using DER.
+ */
+asn_enc_rval_t
+der_encode_primitive(const asn_TYPE_descriptor_t *td, const void *sptr,
+                     int tag_mode, ber_tlv_tag_t tag,
+                     asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t erval = {0,0,0};
+    const ASN__PRIMITIVE_TYPE_t *st = (const ASN__PRIMITIVE_TYPE_t *)sptr;
+
+    ASN_DEBUG("%s %s as a primitive type (tm=%d)",
+              cb?"Encoding":"Estimating", td->name, tag_mode);
+
+    erval.encoded = der_write_tags(td, st->size, tag_mode, 0, tag,
+                                   cb, app_key);
+    ASN_DEBUG("%s wrote tags %d", td->name, (int)erval.encoded);
+    if(erval.encoded == -1) {
+        erval.failed_type = td;
+        erval.structure_ptr = sptr;
+        return erval;
+    }
+
+    if(cb && st->buf) {
+        if(cb(st->buf, st->size, app_key) < 0) {
+            erval.encoded = -1;
+            erval.failed_type = td;
+            erval.structure_ptr = sptr;
+            return erval;
+        }
+    } else {
+        assert(st->buf || st->size == 0);
+    }
+
+    erval.encoded += st->size;
+    ASN__ENCODED_OK(erval);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_jer.c
new file mode 100644
index 000000000..5b9fefa8f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_jer.c
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+
+/*
+ * Local internal type passed around as an argument.
+ */
+struct jdp_arg_s {
+    const asn_TYPE_descriptor_t *type_descriptor;
+    void *struct_key;
+    jer_primitive_body_decoder_f *prim_body_decoder;
+    int decoded_something;
+    int want_more;
+};
+
+/*
+ * Since some kinds of primitive values can be encoded using value-specific
+ * tags (<MINUS-INFINITY>, <enum-element>, etc), the primitive decoder must
+ * be supplied with such tags to parse them as needed.
+ */
+static int
+jer_decode__unexpected_tag(void *key, const void *chunk_buf, size_t chunk_size) {
+    struct jdp_arg_s *arg = (struct jdp_arg_s *)key;
+    enum jer_pbd_rval bret;
+
+    /*
+     * The chunk_buf is guaranteed to start at '<'.
+     */
+    assert(chunk_size && ((const char *)chunk_buf)[0] == 0x3c);
+
+    /*
+     * Decoding was performed once already. Prohibit doing it again.
+    */
+    if(arg->decoded_something)
+        return -1;
+
+    bret = arg->prim_body_decoder(arg->type_descriptor,
+                                  arg->struct_key, chunk_buf,
+                                  chunk_size);
+    switch(bret) {
+    case JPBD_SYSTEM_FAILURE:
+    case JPBD_DECODER_LIMIT:
+    case JPBD_BROKEN_ENCODING:
+        break;
+    case JPBD_BODY_CONSUMED:
+        /* Tag decoded successfully */
+        arg->decoded_something = 1;
+        /* Fall through */
+    case JPBD_NOT_BODY_IGNORE:  /* Safe to proceed further */
+        return 0;
+    }
+
+    return -1;
+}
+
+static ssize_t
+jer_decode__primitive_body(void *key, const void *chunk_buf, size_t chunk_size, int have_more) {
+    struct jdp_arg_s *arg = (struct jdp_arg_s *)key;
+    enum jer_pbd_rval bret;
+    size_t lead_wsp_size;
+
+    if(arg->decoded_something) {
+        if(jer_whitespace_span(chunk_buf, chunk_size) == chunk_size) {
+            /*
+             * Example:
+             * "<INTEGER>123<!--/--> </INTEGER>"
+             *                      ^- chunk_buf position.
+             */
+            return chunk_size;
+        }
+        /*
+         * Decoding was done once already. Prohibit doing it again.
+         */
+        return -1;
+    }
+
+    if(!have_more) {
+        /*
+         * If we've received something like "1", we can't really
+         * tell whether it is really `1` or `123`, until we know
+         * that there is no more data coming.
+         * The have_more argument will be set to 1 once something
+         * like this is available to the caller of this callback:
+         * "1<tag_start..."
+         */
+        arg->want_more = 1;
+        return -1;
+    }
+
+    lead_wsp_size = jer_whitespace_span(chunk_buf, chunk_size);
+    chunk_buf   = (chunk_buf == NULL)? NULL : ((const char *)chunk_buf + lead_wsp_size);
+    chunk_size -= lead_wsp_size;
+
+    bret = arg->prim_body_decoder(arg->type_descriptor,
+                                  arg->struct_key, chunk_buf,
+                                  chunk_size);
+    switch(bret) {
+    case JPBD_SYSTEM_FAILURE:
+    case JPBD_DECODER_LIMIT:
+    case JPBD_BROKEN_ENCODING:
+        break;
+    case JPBD_BODY_CONSUMED:
+        /* Tag decoded successfully */
+        arg->decoded_something = 1;
+        /* Fall through */
+    case JPBD_NOT_BODY_IGNORE:  /* Safe to proceed further */
+        return lead_wsp_size + chunk_size;
+    }
+
+    return -1;
+}
+
+asn_dec_rval_t
+jer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td, void **sptr,
+                     size_t struct_size,
+                     const void *buf_ptr, size_t size,
+                     jer_primitive_body_decoder_f *prim_body_decoder) {
+    asn_struct_ctx_t s_ctx;
+    struct jdp_arg_s s_arg;
+    asn_dec_rval_t rc;
+
+    /*
+     * Create the structure if does not exist.
+     */
+    if(!*sptr) {
+        *sptr = CALLOC(1, struct_size);
+        if(!*sptr) ASN__DECODE_FAILED;
+    }
+
+    memset(&s_ctx, 0, sizeof(s_ctx));
+    s_arg.type_descriptor = td;
+    s_arg.struct_key = *sptr;
+    s_arg.prim_body_decoder = prim_body_decoder;
+    s_arg.decoded_something = 0;
+    s_arg.want_more = 0;
+
+    rc = jer_decode_general(opt_codec_ctx, &s_ctx, &s_arg,
+                            buf_ptr, size,
+                            jer_decode__unexpected_tag,
+                            jer_decode__primitive_body);
+    switch(rc.code) {
+    case RC_OK:
+        if(!s_arg.decoded_something) {
+            char ch;
+            ASN_DEBUG("Primitive body is not recognized, "
+                      "supplying empty one");
+            /*
+             * Decoding opportunity has come and gone.
+             * Where's the result?
+             * Try to feed with empty body, see if it eats it.
+             */
+            if(prim_body_decoder(s_arg.type_descriptor,
+                s_arg.struct_key, &ch, 0)
+                    != JPBD_BODY_CONSUMED) {
+                /*
+                 * This decoder does not like empty stuff.
+                 */
+                ASN__DECODE_FAILED;
+            }
+        }
+        break;
+    case RC_WMORE:
+        /*
+         * Redo the whole thing later.
+         * We don't have a context to save intermediate parsing state.
+         */
+        rc.consumed = 0;
+        break;
+    case RC_FAIL:
+        rc.consumed = 0;
+        if(s_arg.want_more)
+            rc.code = RC_WMORE;
+        else
+            ASN__DECODE_FAILED;
+        break;
+    }
+    return rc;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_xer.c
new file mode 100644
index 000000000..145afb843
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_codecs_prim_xer.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+
+/*
+ * Local internal type passed around as an argument.
+ */
+struct xdp_arg_s {
+    const asn_TYPE_descriptor_t *type_descriptor;
+    void *struct_key;
+    xer_primitive_body_decoder_f *prim_body_decoder;
+    int decoded_something;
+    int want_more;
+};
+
+/*
+ * Since some kinds of primitive values can be encoded using value-specific
+ * tags (<MINUS-INFINITY>, <enum-element>, etc), the primitive decoder must
+ * be supplied with such tags to parse them as needed.
+ */
+static int
+xer_decode__unexpected_tag(void *key, const void *chunk_buf, size_t chunk_size) {
+    struct xdp_arg_s *arg = (struct xdp_arg_s *)key;
+    enum xer_pbd_rval bret;
+
+    /*
+     * The chunk_buf is guaranteed to start at '<'.
+     */
+    assert(chunk_size && ((const char *)chunk_buf)[0] == 0x3c);
+
+    /*
+     * Decoding was performed once already. Prohibit doing it again.
+    */
+    if(arg->decoded_something)
+        return -1;
+
+    bret = arg->prim_body_decoder(arg->type_descriptor,
+                                  arg->struct_key, chunk_buf,
+                                  chunk_size);
+    switch(bret) {
+    case XPBD_SYSTEM_FAILURE:
+    case XPBD_DECODER_LIMIT:
+    case XPBD_BROKEN_ENCODING:
+        break;
+    case XPBD_BODY_CONSUMED:
+        /* Tag decoded successfully */
+        arg->decoded_something = 1;
+        /* Fall through */
+    case XPBD_NOT_BODY_IGNORE:  /* Safe to proceed further */
+        return 0;
+    }
+
+    return -1;
+}
+
+static ssize_t
+xer_decode__primitive_body(void *key, const void *chunk_buf, size_t chunk_size, int have_more) {
+    struct xdp_arg_s *arg = (struct xdp_arg_s *)key;
+    enum xer_pbd_rval bret;
+    size_t lead_wsp_size;
+
+    if(arg->decoded_something) {
+        if(xer_whitespace_span(chunk_buf, chunk_size) == chunk_size) {
+            /*
+             * Example:
+             * "<INTEGER>123<!--/--> </INTEGER>"
+             *                      ^- chunk_buf position.
+             */
+            return chunk_size;
+        }
+        /*
+         * Decoding was done once already. Prohibit doing it again.
+         */
+        return -1;
+    }
+
+    if(!have_more) {
+        /*
+         * If we've received something like "1", we can't really
+         * tell whether it is really `1` or `123`, until we know
+         * that there is no more data coming.
+         * The have_more argument will be set to 1 once something
+         * like this is available to the caller of this callback:
+         * "1<tag_start..."
+         */
+        arg->want_more = 1;
+        return -1;
+    }
+
+    lead_wsp_size = xer_whitespace_span(chunk_buf, chunk_size);
+    chunk_buf   = (chunk_buf == NULL)? NULL : ((const char *)chunk_buf + lead_wsp_size);
+    chunk_size -= lead_wsp_size;
+
+    bret = arg->prim_body_decoder(arg->type_descriptor,
+                                  arg->struct_key, chunk_buf,
+                                  chunk_size);
+    switch(bret) {
+    case XPBD_SYSTEM_FAILURE:
+    case XPBD_DECODER_LIMIT:
+    case XPBD_BROKEN_ENCODING:
+        break;
+    case XPBD_BODY_CONSUMED:
+        /* Tag decoded successfully */
+        arg->decoded_something = 1;
+        /* Fall through */
+    case XPBD_NOT_BODY_IGNORE:  /* Safe to proceed further */
+        return lead_wsp_size + chunk_size;
+    }
+
+    return -1;
+}
+
+asn_dec_rval_t
+xer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td, void **sptr,
+                     size_t struct_size, const char *opt_mname,
+                     const void *buf_ptr, size_t size,
+                     xer_primitive_body_decoder_f *prim_body_decoder) {
+    const char *xml_tag = opt_mname ? opt_mname : td->xml_tag;
+    asn_struct_ctx_t s_ctx;
+    struct xdp_arg_s s_arg;
+    asn_dec_rval_t rc;
+
+    /*
+     * Create the structure if does not exist.
+     */
+    if(!*sptr) {
+        *sptr = CALLOC(1, struct_size);
+        if(!*sptr) ASN__DECODE_FAILED;
+    }
+
+    memset(&s_ctx, 0, sizeof(s_ctx));
+    s_arg.type_descriptor = td;
+    s_arg.struct_key = *sptr;
+    s_arg.prim_body_decoder = prim_body_decoder;
+    s_arg.decoded_something = 0;
+    s_arg.want_more = 0;
+
+    rc = xer_decode_general(opt_codec_ctx, &s_ctx, &s_arg,
+                            xml_tag, buf_ptr, size,
+                            xer_decode__unexpected_tag,
+                            xer_decode__primitive_body);
+    switch(rc.code) {
+    case RC_OK:
+        if(!s_arg.decoded_something) {
+            char ch;
+            ASN_DEBUG("Primitive body is not recognized, "
+                      "supplying empty one");
+            /*
+             * Decoding opportunity has come and gone.
+             * Where's the result?
+             * Try to feed with empty body, see if it eats it.
+             */
+            if(prim_body_decoder(s_arg.type_descriptor,
+                s_arg.struct_key, &ch, 0)
+                    != XPBD_BODY_CONSUMED) {
+                /*
+                 * This decoder does not like empty stuff.
+                 */
+                ASN__DECODE_FAILED;
+            }
+        }
+        break;
+    case RC_WMORE:
+        /*
+         * Redo the whole thing later.
+         * We don't have a context to save intermediate parsing state.
+         */
+        rc.consumed = 0;
+        break;
+    case RC_FAIL:
+        rc.consumed = 0;
+        if(s_arg.want_more)
+            rc.code = RC_WMORE;
+        else
+            ASN__DECODE_FAILED;
+        break;
+    }
+    return rc;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_config.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_config.h
new file mode 100644
index 000000000..551bcc7fc
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_config.h
@@ -0,0 +1,2 @@
+// Generated automatically. Don't edit manually!
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_internal.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_internal.c
new file mode 100644
index 000000000..17ba6cf41
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_internal.c
@@ -0,0 +1,50 @@
+#include "asn_internal.h"
+
+ssize_t
+asn__format_to_callback(int (*cb)(const void *, size_t, void *key), void *key,
+                        const char *fmt, ...) {
+    char scratch[64];
+    char *buf = scratch;
+    size_t buf_size = sizeof(scratch);
+    int wrote;
+    int cb_ret;
+
+    do {
+        va_list args;
+        va_start(args, fmt);
+
+        wrote = vsnprintf(buf, buf_size, fmt, args);
+        va_end(args);
+        if(wrote < (ssize_t)buf_size) {
+            if(wrote < 0) {
+                if(buf != scratch) FREEMEM(buf);
+                return -1;
+            }
+            break;
+        }
+
+        buf_size <<= 1;
+        if(buf == scratch) {
+            buf = MALLOC(buf_size);
+            if(!buf) {
+              return -1;
+            }
+        } else {
+            void *p = REALLOC(buf, buf_size);
+            if(!p) {
+                FREEMEM(buf);
+                return -1;
+            }
+            buf = p;
+        }
+    } while(1);
+
+    cb_ret = cb(buf, wrote, key);
+    if(buf != scratch) FREEMEM(buf);
+    if(cb_ret < 0) {
+        return -1;
+    }
+
+    return wrote;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_internal.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_internal.h
new file mode 100644
index 000000000..447f19a2d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_internal.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * Declarations internally useful for the ASN.1 support code.
+ */
+#ifndef	ASN_INTERNAL_H
+#define	ASN_INTERNAL_H
+#ifndef __EXTENSIONS__
+#define __EXTENSIONS__          /* for Sun */
+#endif
+
+#include "asn_application.h"	/* Application-visible API */
+
+#ifndef	__NO_ASSERT_H__		/* Include assert.h only for internal use. */
+#include <assert.h>		/* for assert() macro */
+#endif
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+#include "uper_decoder.h"
+#include "uper_encoder.h"
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+#include "aper_decoder.h"
+#include "aper_encoder.h"
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+/* Environment version might be used to avoid running with the old library */
+#define	ASN1C_ENVIRONMENT_VERSION	923	/* Compile-time version */
+int get_asn1c_environment_version(void);	/* Run-time version */
+
+#define	CALLOC(nmemb, size)	calloc(nmemb, size)
+#define	MALLOC(size)		malloc(size)
+#define	REALLOC(oldptr, size)	realloc(oldptr, size)
+#define	FREEMEM(ptr)		free(ptr)
+
+#define	asn_debug_indent	0
+#define ASN_DEBUG_INDENT_ADD(i) do{}while(0)
+
+#ifdef  EMIT_ASN_DEBUG
+#warning "Use ASN_EMIT_DEBUG instead of EMIT_ASN_DEBUG"
+#define ASN_EMIT_DEBUG  EMIT_ASN_DEBUG
+#endif
+
+/*
+ * A macro for debugging the ASN.1 internals.
+ * You may enable or override it.
+ */
+#ifndef	ASN_DEBUG	/* If debugging code is not defined elsewhere... */
+#if	ASN_EMIT_DEBUG == 1	/* And it was asked to emit this code... */
+#if __STDC_VERSION__ >= 199901L
+#ifdef	ASN_THREAD_SAFE
+/* Thread safety requires sacrifice in output indentation:
+ * Retain empty definition of ASN_DEBUG_INDENT_ADD. */
+#else	/* !ASN_THREAD_SAFE */
+#undef  ASN_DEBUG_INDENT_ADD
+#undef  asn_debug_indent
+int asn_debug_indent;
+#define ASN_DEBUG_INDENT_ADD(i) do { asn_debug_indent += i; } while(0)
+#endif	/* ASN_THREAD_SAFE */
+#define	ASN_DEBUG(fmt, args...)	do {			\
+		int adi = asn_debug_indent;		\
+		while(adi--) fprintf(stderr, " ");	\
+		fprintf(stderr, fmt, ##args);		\
+		fprintf(stderr, " (%s:%d)\n",		\
+			__FILE__, __LINE__);		\
+	} while(0)
+#else	/* !C99 */
+void CC_PRINTFLIKE(1, 2) ASN_DEBUG_f(const char *fmt, ...);
+#define	ASN_DEBUG	ASN_DEBUG_f
+#endif	/* C99 */
+#else	/* ASN_EMIT_DEBUG != 1 */
+#if __STDC_VERSION__ >= 199901L
+#define ASN_DEBUG(...) do{}while(0)
+#else   /* not C99 */
+static void CC_PRINTFLIKE(1, 2) ASN_DEBUG(const char *fmt, ...) { (void)fmt; }
+#endif  /* C99 or better */
+#endif	/* ASN_EMIT_DEBUG */
+#endif	/* ASN_DEBUG */
+
+/*
+ * Print to a callback.
+ * The callback is expected to return negative values on error.
+ * 0 and positive values are treated as success.
+ * RETURN VALUES:
+ *  -1: Failed to format or invoke the callback.
+ *  >0: Size of the data that got delivered to the callback.
+ */
+ssize_t CC_PRINTFLIKE(3, 4)
+asn__format_to_callback(
+    int (*callback)(const void *, size_t, void *key), void *key,
+    const char *fmt, ...);
+
+/*
+ * Invoke the application-supplied callback and fail, if something is wrong.
+ */
+#define ASN__E_cbc(buf, size) (cb((buf), (size), app_key) < 0)
+#define ASN__E_CALLBACK(size, foo) \
+    do {                           \
+        if(foo) goto cb_failed;    \
+        er.encoded += (size);      \
+    } while(0)
+#define ASN__CALLBACK(buf, size) ASN__E_CALLBACK(size, ASN__E_cbc(buf, size))
+#define ASN__CALLBACK2(buf1, size1, buf2, size2) \
+    ASN__E_CALLBACK((size1) + (size2),           \
+                    ASN__E_cbc(buf1, size1) || ASN__E_cbc(buf2, size2))
+#define ASN__CALLBACK3(buf1, size1, buf2, size2, buf3, size3)          \
+    ASN__E_CALLBACK((size1) + (size2) + (size3),                       \
+                    ASN__E_cbc(buf1, size1) || ASN__E_cbc(buf2, size2) \
+                        || ASN__E_cbc(buf3, size3))
+
+#define ASN__TEXT_INDENT(nl, level)                                          \
+    do {                                                                     \
+        int tmp_level = (level);                                             \
+        int tmp_nl = ((nl) != 0);                                            \
+        int tmp_i;                                                           \
+        if(tmp_nl) ASN__CALLBACK("\n", 1);                                   \
+        if(tmp_level < 0) tmp_level = 0;                                     \
+        for(tmp_i = 0; tmp_i < tmp_level; tmp_i++) ASN__CALLBACK("    ", 4); \
+    } while(0)
+
+#define	_i_INDENT(nl)	do {                        \
+        int tmp_i;                                  \
+        if((nl) && cb("\n", 1, app_key) < 0)        \
+            return -1;                              \
+        for(tmp_i = 0; tmp_i < ilevel; tmp_i++)     \
+            if(cb("    ", 4, app_key) < 0)          \
+                return -1;                          \
+    } while(0)
+
+/*
+ * Check stack against overflow, if limit is set.
+ */
+
+/* Since GCC 13, AddressSanitizer started defaulting to
+* ASAN_OPTIONS="detect_stack_use_after_return=1", which makes this check
+* fail due to apparently jumping stack pointers.
+* Hence, disable this check if building with ASan, as documented in:
+* GCC: https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
+* Clang: https://clang.llvm.org/docs/AddressSanitizer.html#conditional-compilation-with-has-feature-address-sanitizer
+*/
+#if defined(__SANITIZE_ADDRESS__)
+	#define ASN__SANITIZE_ENABLED 1
+#elif defined(__has_feature)
+#if __has_feature(address_sanitizer)
+	#define ASN__SANITIZE_ENABLED 1
+#endif
+#endif
+
+#define	ASN__DEFAULT_STACK_MAX	(30000)
+
+#if defined(ASN__SANITIZE_ENABLED) || defined(ASN_DISABLE_STACK_OVERFLOW_CHECK)
+static int CC_NOTUSED
+ASN__STACK_OVERFLOW_CHECK(const asn_codec_ctx_t *ctx) {
+   (void)ctx;
+   return 0;
+}
+#else
+static int CC_NOTUSED
+ASN__STACK_OVERFLOW_CHECK(const asn_codec_ctx_t *ctx) {
+	if(ctx && ctx->max_stack_size) {
+
+		/* ctx MUST be allocated on the stack */
+		ptrdiff_t usedstack = ((const char *)ctx - (const char *)&ctx);
+		if(usedstack > 0) usedstack = -usedstack; /* grows up! */
+
+		/* double negative required to avoid int wrap-around */
+		if(usedstack < -(ptrdiff_t)ctx->max_stack_size) {
+			ASN_DEBUG("Stack limit %ld reached",
+				(long)ctx->max_stack_size);
+			return -1;
+		}
+	}
+	return 0;
+}
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* ASN_INTERNAL_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_ioc.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_ioc.h
new file mode 100644
index 000000000..c1d28890f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_ioc.h
@@ -0,0 +1,51 @@
+/*
+ * Run-time support for Information Object Classes.
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN_IOC_H
+#define	ASN_IOC_H
+
+#include "asn_system.h"		/* Platform-specific types */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;
+struct asn_ioc_cell_s;
+
+/*
+ * X.681, #13
+ */
+typedef struct asn_ioc_set_s {
+    size_t rows_count;
+    size_t columns_count;
+    const struct asn_ioc_cell_s *rows;
+} asn_ioc_set_t;
+
+
+typedef struct asn_ioc_cell_s {
+    const char *field_name; /* Is equal to corresponding column_name */
+    enum {
+        aioc__undefined = 0,
+        aioc__value,
+        aioc__type,
+        aioc__open_type,
+    } cell_kind;
+    struct asn_TYPE_descriptor_s *type_descriptor;
+    const void *value_sptr;
+    struct {
+        size_t types_count;
+        struct {
+            unsigned choice_position;
+        } *types;
+    } open_type;
+} asn_ioc_cell_t;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN_IOC_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_random_fill.c /ext/source/modules/EVSE/EvseV2G/asn1/asn_random_fill.c
new file mode 100644
index 000000000..136089041
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_random_fill.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_random_fill.h"
+#include "constr_TYPE.h"
+#include <stdlib.h>
+
+int
+asn_random_fill(const struct asn_TYPE_descriptor_s *td, void **struct_ptr,
+                size_t length) {
+
+    if(td && td->op->random_fill) {
+        asn_random_fill_result_t res =
+            td->op->random_fill(td, struct_ptr, 0, length);
+        return (res.code == ARFILL_OK) ? 0 : -1;
+    } else {
+        return -1;
+    }
+}
+
+static uintmax_t
+asn__intmax_range(intmax_t lb, intmax_t ub) {
+    assert(lb <= ub);
+    if((ub < 0) == (lb < 0)) {
+        return ub - lb;
+    } else if(lb < 0) {
+        return 1 + ((uintmax_t)ub + (uintmax_t)-(lb + 1));
+    } else {
+        assert(!"Unreachable");
+        return 0;
+    }
+}
+
+intmax_t
+asn_random_between(intmax_t lb, intmax_t rb) {
+    if(lb == rb) {
+        return lb;
+    } else {
+        const uintmax_t intmax_max = ((~(uintmax_t)0) >> 1);
+        uintmax_t range = asn__intmax_range(lb, rb);
+        uintmax_t value = 0;
+        uintmax_t got_entropy = 0;
+        (void)intmax_max;
+        int max = 0xffffff;
+
+#ifdef __WIN32__
+        max = RAND_MAX-1;
+#endif
+
+        assert(RAND_MAX > max);    /* Seen 7ffffffd! */
+        assert(range < intmax_max);
+
+        for(; got_entropy < range;) {
+            got_entropy = (got_entropy << 24) | max;
+#ifdef HAVE_RANDOM
+            value = (value << 24) | (random() % max);
+#else
+            value = (value << 24) | (rand() % max);
+#endif
+        }
+
+        return lb + (intmax_t)(value % (range + 1));
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_random_fill.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_random_fill.h
new file mode 100644
index 000000000..47f9b8af0
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_random_fill.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN_RANDOM_FILL
+#define	ASN_RANDOM_FILL
+
+/* Forward declarations */
+struct asn_TYPE_descriptor_s;
+struct asn_encoding_constraints_s;
+
+/*
+ * Initialize a structure with random data according to the type specification
+ * and optional member constraints.
+ * ARGUMENTS:
+ *  (max_length)        - See (approx_max_length_limit).
+ *  (memb_constraints)  - Member constraints, if exist.
+ *                        The type can be constrained differently according
+ *                        to PER and OER specifications, so we find a value
+ *                        at the intersection of these constraints.
+ * In case the return differs from ARFILL_OK, the (struct_ptr) contents
+ * and (current_length) value remain in their original state.
+ */
+typedef struct asn_random_fill_result_s {
+    enum {
+        ARFILL_FAILED = -1, /* System error (memory?) */
+        ARFILL_OK = 0,      /* Initialization succeeded */
+        ARFILL_SKIPPED = 1  /* Not done due to (length?) constraint */
+    } code;
+    size_t length; /* Approximate number of bytes created. */
+} asn_random_fill_result_t;
+typedef asn_random_fill_result_t(asn_random_fill_f)(
+    const struct asn_TYPE_descriptor_s *td, void **struct_ptr,
+    const struct asn_encoding_constraints_s *memb_constraints,
+    size_t max_length);
+
+/*
+ * Returns 0 if the structure was properly initialized, -1 otherwise.
+ * The (approx_max_length_limit) specifies the approximate limit of the
+ * resulting structure in units closely resembling bytes. The actual result
+ * might be several times larger or smaller than the length limit.
+ */
+int asn_random_fill(const struct asn_TYPE_descriptor_s *td, void **struct_ptr,
+                    size_t approx_max_length_limit);
+
+/*
+ * Returns a random number between min and max.
+ */
+intmax_t asn_random_between(intmax_t min, intmax_t max);
+
+#endif	/* ASN_RANDOM_FILL */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/asn_system.h /ext/source/modules/EVSE/EvseV2G/asn1/asn_system.h
new file mode 100644
index 000000000..194f96a5f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/asn_system.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * Miscellaneous system-dependent types.
+ */
+#ifndef	ASN_SYSTEM_H
+#define	ASN_SYSTEM_H
+
+#ifdef	HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef _DEFAULT_SOURCE
+#define _DEFAULT_SOURCE 1
+#endif
+
+#ifndef _BSD_SOURCE
+#define _BSD_SOURCE /* for snprintf() on some linux systems  */
+#endif
+
+#include <stdio.h>	/* For snprintf(3) */
+#include <stdlib.h>	/* For *alloc(3) */
+#include <string.h>	/* For memcpy(3) */
+#include <sys/types.h>	/* For size_t */
+#include <limits.h>	/* For LONG_MAX */
+#include <stdarg.h>	/* For va_start */
+#include <stddef.h>	/* for offsetof and ptrdiff_t */
+#include <inttypes.h>	/* for PRIdMAX */
+
+#ifdef	_WIN32
+
+#include <malloc.h>
+#ifndef __MINGW32__
+#define	 snprintf	_snprintf
+#define	 vsnprintf	_vsnprintf
+#endif
+
+/* To avoid linking with ws2_32.lib, here's the definition of ntohl() */
+#define sys_ntohl(l)	((((l) << 24)  & 0xff000000)	\
+			| (((l) << 8) & 0xff0000)	\
+			| (((l) >> 8)  & 0xff00)	\
+			| ((l >> 24) & 0xff))
+
+#ifdef _MSC_VER			/* MSVS.Net */
+#ifndef __cplusplus
+#define inline __inline
+#endif
+#ifndef	ASSUMESTDTYPES	/* Standard types have been defined elsewhere */
+#define	ssize_t		SSIZE_T
+#if _MSC_VER < 1600
+typedef	char		int8_t;
+typedef	short		int16_t;
+typedef	int		int32_t;
+typedef	unsigned char	uint8_t;
+typedef	unsigned short	uint16_t;
+typedef	unsigned int	uint32_t;
+#else /* _MSC_VER >= 1600 */
+#include <stdint.h>
+#endif /* _MSC_VER < 1600 */
+#endif	/* ASSUMESTDTYPES */
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <float.h>
+#define isnan _isnan
+#define finite _finite
+#define copysign _copysign
+#define	ilogb	_logb
+#else	/* !_MSC_VER */
+#include <stdint.h>
+#endif	/* _MSC_VER */
+
+#else	/* !_WIN32 */
+
+#if defined(__vxworks)
+#include <types/vxTypes.h>
+#else	/* !defined(__vxworks) */
+
+#include <inttypes.h>	/* C99 specifies this file */
+#ifdef HAVE_ARPA_INET_H
+#include <arp/ext/sourceinet.h> /* for ntohl() */
+#define	sys_ntohl(foo)	ntohl(foo)
+#else /* !_HAVE_ARPA_INET_H */
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h> /* for ntohl() */
+#define	sys_ntohl(foo)	ntohl(foo)
+#else /* !_HAVE_NETINET_IN_H */
+/* Here's the definition of ntohl() */
+#define sys_ntohl(l)   ((((l) << 24)  & 0xff000000)    \
+            | (((l) << 8) & 0xff0000)  \
+            | (((l) >> 8)  & 0xff00)   \
+            | ((l >> 24) & 0xff))
+#endif /* HAVE_NETINET_IN_H */
+#endif /* HAVE_ARPA_INET_H */
+#endif	/* defined(__vxworks) */
+
+
+#endif	/* _WIN32 */
+
+#if	__GNUC__ >= 3 || defined(__clang__)
+#define CC_ATTRIBUTE(attr)    __attribute__((attr))
+#else
+#define CC_ATTRIBUTE(attr)
+#endif
+#if defined(__GNUC__) && ((__GNUC__ == 4 && __GNUC_MINOR__>= 4) || __GNUC__ > 4)
+#define CC_PRINTFLIKE(fmt, var) CC_ATTRIBUTE(format(gnu_printf, fmt, var))
+#elif defined(__GNUC__)
+#if defined(ANDROID)
+#define CC_PRINTFLIKE(fmt, var) CC_ATTRIBUTE(__format__(__printf__, fmt, var))
+#else
+#define CC_PRINTFLIKE(fmt, var) CC_ATTRIBUTE(format(printf, fmt, var))
+#endif
+#else
+#define CC_PRINTFLIKE(fmt, var)
+#endif
+#define	CC_NOTUSED                  CC_ATTRIBUTE(unused)
+#ifndef CC_ATTR_NO_SANITIZE
+#if	__GNUC__ < 8
+#define CC_ATTR_NO_SANITIZE(what)
+#else
+#define CC_ATTR_NO_SANITIZE(what)   CC_ATTRIBUTE(no_sanitize(what))
+#endif
+#endif
+
+/* Figure out if thread safety is requested */
+#if !defined(ASN_THREAD_SAFE) && (defined(THREAD_SAFE) || defined(_REENTRANT))
+#define	ASN_THREAD_SAFE
+#endif	/* Thread safety */
+
+#ifndef	offsetof	/* If not defined by <stddef.h> */
+#define	offsetof(s, m)	((ptrdiff_t)&(((s *)0)->m) - (ptrdiff_t)((s *)0))
+#endif	/* offsetof */
+
+#ifndef	MIN		/* Suitable for comparing primitive types (integers) */
+#if defined(__GNUC__)
+#define	MIN(a,b)	({ __typeof a _a = a; __typeof b _b = b;	\
+	((_a)<(_b)?(_a):(_b)); })
+#else	/* !__GNUC__ */
+#define	MIN(a,b)	((a)<(b)?(a):(b))	/* Unsafe variant */
+#endif /* __GNUC__ */
+#endif	/* MIN */
+
+#if __STDC_VERSION__ >= 199901L
+#ifndef SIZE_MAX
+#define SIZE_MAX   ((~((size_t)0)) >> 1)
+#endif
+
+#ifndef RSIZE_MAX   /* C11, Annex K */
+#define RSIZE_MAX   (SIZE_MAX >> 1)
+#endif
+#ifndef RSSIZE_MAX   /* Halve signed size even further than unsigned */
+#define RSSIZE_MAX   ((ssize_t)(RSIZE_MAX >> 1))
+#endif
+#else   /* Old compiler */
+#undef  SIZE_MAX
+#undef  RSIZE_MAX
+#undef  RSSIZE_MAX
+#define SIZE_MAX   ((~((size_t)0)) >> 1)
+#define RSIZE_MAX   (SIZE_MAX >> 1)
+#define RSSIZE_MAX   ((ssize_t)(RSIZE_MAX >> 1))
+#endif
+
+#if __STDC_VERSION__ >= 199901L
+#define ASN_PRI_SIZE "zu"
+#define ASN_PRI_SSIZE "zd"
+#define ASN_PRIuMAX PRIuMAX
+#define ASN_PRIdMAX PRIdMAX
+#define ASN_PRIu64 PRIu64
+#define ASN_PRId64 PRId64
+#else
+#define ASN_PRI_SIZE "lu"
+#define ASN_PRI_SSIZE "ld"
+#define ASN_PRIu64 "llu"
+#define ASN_PRId64 "lld"
+#if LLONG_MAX > LONG_MAX
+#define ASN_PRIuMAX "llu"
+#define ASN_PRIdMAX "lld"
+#else
+#define ASN_PRIuMAX "lu"
+#define ASN_PRIdMAX "ld"
+#endif
+#endif
+
+#endif	/* ASN_SYSTEM_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ber_decoder.c /ext/source/modules/EVSE/EvseV2G/asn1/ber_decoder.c
new file mode 100644
index 000000000..79d2fad49
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ber_decoder.c
@@ -0,0 +1,283 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+
+#undef	ADVANCE
+#define	ADVANCE(num_bytes)	do {					\
+		size_t num = num_bytes;					\
+		ptr = ((const char *)ptr) + num;			\
+		size -= num;						\
+		consumed_myself += num;					\
+	} while(0)
+#undef	RETURN
+#define	RETURN(_code)	do {						\
+		asn_dec_rval_t rval;					\
+		rval.code = _code;					\
+		if(opt_ctx) opt_ctx->step = step; /* Save context */	\
+		if(_code == RC_OK || opt_ctx)				\
+			rval.consumed = consumed_myself;		\
+		else							\
+			rval.consumed = 0;	/* Context-free */	\
+		return rval;						\
+	} while(0)
+
+/*
+ * The BER decoder of any type.
+ */
+asn_dec_rval_t
+ber_decode(const asn_codec_ctx_t *opt_codec_ctx,
+           const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr,
+           const void *ptr, size_t size) {
+    asn_codec_ctx_t s_codec_ctx;
+
+	/*
+	 * Stack checker requires that the codec context
+	 * must be allocated on the stack.
+	 */
+	if(opt_codec_ctx) {
+		if(opt_codec_ctx->max_stack_size) {
+			s_codec_ctx = *opt_codec_ctx;
+			opt_codec_ctx = &s_codec_ctx;
+		}
+	} else {
+		/* If context is not given, be security-conscious anyway */
+		memset(&s_codec_ctx, 0, sizeof(s_codec_ctx));
+		s_codec_ctx.max_stack_size = ASN__DEFAULT_STACK_MAX;
+		opt_codec_ctx = &s_codec_ctx;
+	}
+
+	/*
+	 * Invoke type-specific decoder.
+	 */
+	return type_descriptor->op->ber_decoder(opt_codec_ctx, type_descriptor,
+		struct_ptr,	/* Pointer to the destination structure */
+		ptr, size,	/* Buffer and its size */
+		0		/* Default tag mode is 0 */
+		);
+}
+
+/*
+ * Check the set of <TL<TL<TL...>>> tags matches the definition.
+ */
+asn_dec_rval_t
+ber_check_tags(const asn_codec_ctx_t *opt_codec_ctx,
+               const asn_TYPE_descriptor_t *td, asn_struct_ctx_t *opt_ctx,
+               const void *ptr, size_t size, int tag_mode, int last_tag_form,
+               ber_tlv_len_t *last_length, int *opt_tlv_form) {
+    ssize_t consumed_myself = 0;
+	ssize_t tag_len;
+	ssize_t len_len;
+	ber_tlv_tag_t tlv_tag;
+	ber_tlv_len_t tlv_len;
+	ber_tlv_len_t limit_len = -1;
+	int expect_00_terminators = 0;
+	int tlv_constr = -1;	/* If CHOICE, opt_tlv_form is not given */
+	int step = opt_ctx ? opt_ctx->step : 0;	/* Where we left previously */
+	int tagno;
+
+	/*
+	 * Make sure we didn't exceed the maximum stack size.
+	 */
+	if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+		RETURN(RC_FAIL);
+
+	/*
+	 * So what does all this implicit skip stuff mean?
+	 * Imagine two types,
+	 * 	A ::= [5] IMPLICIT	T
+	 * 	B ::= [2] EXPLICIT	T
+	 * Where T is defined as
+	 *	T ::= [4] IMPLICIT SEQUENCE { ... }
+	 * 
+	 * Let's say, we are starting to decode type A, given the
+	 * following TLV stream: <5> <0>. What does this mean?
+	 * It means that the type A contains type T which is,
+	 * in turn, empty.
+	 * Remember though, that we are still in A. We cannot
+	 * just pass control to the type T decoder. Why? Because
+	 * the type T decoder expects <4> <0>, not <5> <0>.
+	 * So, we must make sure we are going to receive <5> while
+	 * still in A, then pass control to the T decoder, indicating
+	 * that the tag <4> was implicitly skipped. The decoder of T
+	 * hence will be prepared to treat <4> as valid tag, and decode
+	 * it appropriately.
+	 */
+
+	tagno = step	/* Continuing where left previously */
+		+ (tag_mode==1?-1:0)
+		;
+	ASN_DEBUG("ber_check_tags(%s, size=%ld, tm=%d, step=%d, tagno=%d)",
+		td->name, (long)size, tag_mode, step, tagno);
+	/* assert(td->tags_count >= 1) May not be the case for CHOICE or ANY */
+
+	if(tag_mode == 0 && tagno == (int)td->tags_count) {
+		/*
+		 * This must be the _untagged_ ANY type,
+		 * which outermost tag isn't known in advance.
+		 * Fetch the tag and length separately.
+		 */
+		tag_len = ber_fetch_tag(ptr, size, &tlv_tag);
+		switch(tag_len) {
+		case -1: RETURN(RC_FAIL);
+		case 0: RETURN(RC_WMORE);
+		}
+		tlv_constr = BER_TLV_CONSTRUCTED(ptr);
+		len_len = ber_fetch_length(tlv_constr,
+			(const char *)ptr + tag_len, size - tag_len, &tlv_len);
+		switch(len_len) {
+		case -1: RETURN(RC_FAIL);
+		case 0: RETURN(RC_WMORE);
+		}
+		ASN_DEBUG("Advancing %ld in ANY case",
+			(long)(tag_len + len_len));
+		ADVANCE(tag_len + len_len);
+	} else {
+		assert(tagno < (int)td->tags_count);	/* At least one loop */
+	}
+	for((void)tagno; tagno < (int)td->tags_count; tagno++, step++) {
+
+		/*
+		 * Fetch and process T from TLV.
+		 */
+		tag_len = ber_fetch_tag(ptr, size, &tlv_tag);
+			ASN_DEBUG("Fetching tag from {%p,%ld}: "
+				"len %ld, step %d, tagno %d got %s",
+				ptr, (long)size,
+				(long)tag_len, step, tagno,
+				ber_tlv_tag_string(tlv_tag));
+		switch(tag_len) {
+		case -1: RETURN(RC_FAIL);
+		case 0: RETURN(RC_WMORE);
+		}
+
+		tlv_constr = BER_TLV_CONSTRUCTED(ptr);
+
+		/*
+		 * If {I}, don't check anything.
+		 * If {I,B,C}, check B and C unless we're at I.
+		 */
+		if(tag_mode != 0 && step == 0) {
+			/*
+			 * We don't expect tag to match here.
+			 * It's just because we don't know how the tag
+			 * is supposed to look like.
+			 */
+		} else {
+		    assert(tagno >= 0);	/* Guaranteed by the code above */
+		    if(tlv_tag != td->tags[tagno]) {
+			/*
+			 * Unexpected tag. Too bad.
+			 */
+		    	ASN_DEBUG("Expected: %s, "
+				"expectation failed (tn=%d, tm=%d)",
+				ber_tlv_tag_string(td->tags[tagno]),
+				tagno, tag_mode
+			);
+			RETURN(RC_FAIL);
+		    }
+		}
+
+		/*
+		 * Attention: if there are more tags expected,
+		 * ensure that the current tag is presented
+		 * in constructed form (it contains other tags!).
+		 * If this one is the last one, check that the tag form
+		 * matches the one given in descriptor.
+		 */
+		if(tagno < ((int)td->tags_count - 1)) {
+			if(tlv_constr == 0) {
+				ASN_DEBUG("tlv_constr = %d, expfail",
+					tlv_constr);
+				RETURN(RC_FAIL);
+			}
+		} else {
+			if(last_tag_form != tlv_constr
+			&& last_tag_form != -1) {
+				ASN_DEBUG("last_tag_form %d != %d",
+					last_tag_form, tlv_constr);
+				RETURN(RC_FAIL);
+			}
+		}
+
+		/*
+		 * Fetch and process L from TLV.
+		 */
+		len_len = ber_fetch_length(tlv_constr,
+			(const char *)ptr + tag_len, size - tag_len, &tlv_len);
+		ASN_DEBUG("Fetching len = %ld", (long)len_len);
+		switch(len_len) {
+		case -1: RETURN(RC_FAIL);
+		case 0: RETURN(RC_WMORE);
+		}
+
+		/*
+		 * FIXME
+		 * As of today, the chain of tags
+		 * must either contain several indefinite length TLVs,
+		 * or several definite length ones.
+		 * No mixing is allowed.
+		 */
+		if(tlv_len == -1) {
+			/*
+			 * Indefinite length.
+			 */
+			if(limit_len == -1) {
+				expect_00_terminators++;
+			} else {
+				ASN_DEBUG("Unexpected indefinite length "
+					"in a chain of definite lengths");
+				RETURN(RC_FAIL);
+			}
+			ADVANCE(tag_len + len_len);
+			continue;
+		} else {
+			if(expect_00_terminators) {
+				ASN_DEBUG("Unexpected definite length "
+					"in a chain of indefinite lengths");
+				RETURN(RC_FAIL);
+			}
+		}
+
+		/*
+		 * Check that multiple TLVs specify ever decreasing length,
+		 * which is consistent.
+		 */
+		if(limit_len == -1) {
+			limit_len    = tlv_len + tag_len + len_len;
+			if(limit_len < 0) {
+				/* Too great tlv_len value? */
+				RETURN(RC_FAIL);
+			}
+		} else if(limit_len != tlv_len + tag_len + len_len) {
+			/*
+			 * Inner TLV specifies length which is inconsistent
+			 * with the outer TLV's length value.
+			 */
+			ASN_DEBUG("Outer TLV is %ld and inner is %ld",
+				(long)limit_len, (long)tlv_len);
+			RETURN(RC_FAIL);
+		}
+
+		ADVANCE(tag_len + len_len);
+
+		limit_len -= (tag_len + len_len);
+		if((ssize_t)size > limit_len) {
+			/*
+			 * Make sure that we won't consume more bytes
+			 * from the parent frame than the inferred limit.
+			 */
+			size = limit_len;
+		}
+	}
+
+	if(opt_tlv_form)
+		*opt_tlv_form = tlv_constr;
+	if(expect_00_terminators)
+		*last_length = -expect_00_terminators;
+	else
+		*last_length = tlv_len;
+
+	RETURN(RC_OK);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ber_decoder.h /ext/source/modules/EVSE/EvseV2G/asn1/ber_decoder.h
new file mode 100644
index 000000000..5f13cbb3f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ber_decoder.h
@@ -0,0 +1,66 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_BER_DECODER_H_
+#define	_BER_DECODER_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+struct asn_codec_ctx_s;		/* Forward declaration */
+
+/*
+ * The BER decoder of any type.
+ * This function may be invoked directly from the application.
+ * Decodes BER, DER and CER data (DER and CER are different subsets of BER).
+ *
+ * NOTE: Use the der_encode() function (der_encoder.h) to produce encoding
+ * which is compliant with ber_decode().
+ */
+asn_dec_rval_t ber_decode(
+    const struct asn_codec_ctx_s *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    void **struct_ptr,  /* Pointer to a target structure's pointer */
+    const void *buffer, /* Data to be decoded */
+    size_t size         /* Size of that buffer */
+);
+
+/*
+ * Type of generic function which decodes the byte stream into the structure.
+ */
+typedef asn_dec_rval_t(ber_type_decoder_f)(
+    const struct asn_codec_ctx_s *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr,
+    const void *buf_ptr, size_t size, int tag_mode);
+
+/*******************************
+ * INTERNALLY USEFUL FUNCTIONS *
+ *******************************/
+
+/*
+ * Check that all tags correspond to the type definition (as given in head).
+ * On return, last_length would contain either a non-negative length of the
+ * value part of the last TLV, or the negative number of expected
+ * "end of content" sequences. The number may only be negative if the
+ * head->last_tag_form is non-zero.
+ */
+asn_dec_rval_t ber_check_tags(
+    const struct asn_codec_ctx_s *opt_codec_ctx, /* codec options */
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    asn_struct_ctx_t *opt_ctx, /* saved decoding context */
+    const void *ptr, size_t size,
+    int tag_mode,      /* {-1,0,1}: IMPLICIT, no, EXPLICIT */
+    int last_tag_form, /* {-1,0:1}: any, primitive, constr */
+    ber_tlv_len_t *last_length, int *opt_tlv_form /* optional tag form */
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _BER_DECODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_length.c /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_length.c
new file mode 100644
index 000000000..064c291a7
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_length.c
@@ -0,0 +1,168 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ber_tlv_length.h"
+#include "ber_tlv_tag.h"
+
+ssize_t
+ber_fetch_length(int _is_constructed, const void *bufptr, size_t size,
+		ber_tlv_len_t *len_r) {
+	const uint8_t *buf = (const uint8_t *)bufptr;
+	unsigned oct;
+
+	if(size == 0)
+		return 0;	/* Want more */
+
+	oct = *(const uint8_t *)buf;
+	if((oct & 0x80) == 0) {
+		/*
+		 * Short definite length.
+		 */
+		*len_r = oct;	/* & 0x7F */
+		return 1;
+	} else {
+		ber_tlv_len_t len;
+		size_t skipped;
+
+		if(_is_constructed && oct == 0x80) {
+			*len_r = -1;	/* Indefinite length */
+			return 1;
+		}
+
+		if(oct == 0xff) {
+			/* Reserved in standard for future use. */
+			return -1;
+		}
+
+		oct &= 0x7F;	/* Leave only the 7 LS bits */
+		for(len = 0, buf++, skipped = 1;
+			oct && (++skipped <= size); buf++, oct--) {
+
+			/* Verify that we won't overflow. */
+			if(!(len >> ((8 * sizeof(len)) - (8+1)))) {
+				len = (len << 8) | *buf;
+			} else {
+				/* Too large length value. */
+				return -1;
+			}
+		}
+
+		if(oct == 0) {
+			if(len < 0 || len > RSSIZE_MAX) {
+				/* Length value out of sane range. */
+				return -1;
+			}
+
+			*len_r = len;
+			return skipped;
+		}
+
+		return 0;	/* Want more */
+	}
+
+}
+
+ssize_t
+ber_skip_length(const asn_codec_ctx_t *opt_codec_ctx,
+		int _is_constructed, const void *ptr, size_t size) {
+	ber_tlv_len_t vlen;	/* Length of V in TLV */
+	ssize_t tl;		/* Length of L in TLV */
+	ssize_t ll;		/* Length of L in TLV */
+	size_t skip;
+
+	/*
+	 * Make sure we didn't exceed the maximum stack size.
+	 */
+	if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+		return -1;
+
+	/*
+	 * Determine the size of L in TLV.
+	 */
+	ll = ber_fetch_length(_is_constructed, ptr, size, &vlen);
+	if(ll <= 0) return ll;
+
+	/*
+	 * Definite length.
+	 */
+	if(vlen >= 0) {
+		skip = ll + vlen;
+		if(skip > size)
+			return 0;	/* Want more */
+		return skip;
+	}
+
+	/*
+	 * Indefinite length!
+	 */
+	ASN_DEBUG("Skipping indefinite length");
+	for(skip = ll, ptr = ((const char *)ptr) + ll, size -= ll;;) {
+		ber_tlv_tag_t tag;
+
+		/* Fetch the tag */
+		tl = ber_fetch_tag(ptr, size, &tag);
+		if(tl <= 0) return tl;
+
+		ll = ber_skip_length(opt_codec_ctx,
+			BER_TLV_CONSTRUCTED(ptr),
+			((const char *)ptr) + tl, size - tl);
+		if(ll <= 0) return ll;
+
+		skip += tl + ll;
+
+		/*
+		 * This may be the end of the indefinite length structure,
+		 * two consecutive 0 octets.
+		 * Check if it is true.
+		 */
+		if(((const uint8_t *)ptr)[0] == 0
+		&& ((const uint8_t *)ptr)[1] == 0)
+			return skip;
+
+		ptr = ((const char *)ptr) + tl + ll;
+		size -= tl + ll;
+	}
+
+	/* UNREACHABLE */
+}
+
+size_t
+der_tlv_length_serialize(ber_tlv_len_t len, void *bufp, size_t size) {
+	size_t required_size;	/* Size of len encoding */
+	uint8_t *buf = (uint8_t *)bufp;
+	uint8_t *end;
+	int i;
+
+	if(len <= 127) {
+		/* Encoded in 1 octet */
+		if(size) *buf = (uint8_t)len;
+		return 1;
+	}
+
+	/*
+	 * Compute the size of the subsequent bytes.
+	 */
+	for(required_size = 1, i = 8; i < 8 * (int)sizeof(len); i += 8) {
+		if(len >> i)
+			required_size++;
+		else
+			break;
+	}
+
+	if(size <= required_size)
+		return required_size + 1;
+
+	*buf++ = (uint8_t)(0x80 | required_size);  /* Length of the encoding */
+
+	/*
+	 * Produce the len encoding, space permitting.
+	 */
+	end = buf + required_size;
+	for(i -= 8; buf < end; i -= 8, buf++)
+		*buf = (uint8_t)(len >> i);
+
+	return required_size + 1;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_length.h /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_length.h
new file mode 100644
index 000000000..d1e4d48dd
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_length.h
@@ -0,0 +1,50 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_BER_TLV_LENGTH_H_
+#define	_BER_TLV_LENGTH_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef ssize_t ber_tlv_len_t;
+
+/*
+ * This function tries to fetch the length of the BER TLV value and place it
+ * in *len_r.
+ * RETURN VALUES:
+ *	 0:	More data expected than bufptr contains.
+ *	-1:	Fatal error deciphering length.
+ *	>0:	Number of bytes used from bufptr.
+ * On return with >0, len_r is constrained as -1..MAX, where -1 mean
+ * that the value is of indefinite length.
+ */
+ssize_t ber_fetch_length(int _is_constructed, const void *bufptr, size_t size,
+	ber_tlv_len_t *len_r);
+
+/*
+ * This function expects bufptr to be positioned over L in TLV.
+ * It returns number of bytes occupied by L and V together, suitable
+ * for skipping. The function properly handles indefinite length.
+ * RETURN VALUES:
+ * 	Standard {-1,0,>0} convention.
+ */
+ssize_t ber_skip_length(
+	const struct asn_codec_ctx_s *opt_codec_ctx,	/* optional context */
+	int _is_constructed, const void *bufptr, size_t size);
+
+/*
+ * This function serializes the length (L from TLV) in DER format.
+ * It always returns number of bytes necessary to represent the length,
+ * it is a caller's responsibility to check the return value
+ * against the supplied buffer's size.
+ */
+size_t der_tlv_length_serialize(ber_tlv_len_t len, void *bufptr, size_t size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _BER_TLV_LENGTH_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_tag.c /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_tag.c
new file mode 100644
index 000000000..7c9201ad3
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_tag.c
@@ -0,0 +1,144 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "ber_tlv_tag.h"
+#include <errno.h>
+
+ssize_t
+ber_fetch_tag(const void *ptr, size_t size, ber_tlv_tag_t *tag_r) {
+	ber_tlv_tag_t val;
+	ber_tlv_tag_t tclass;
+	size_t skipped;
+
+	if(size == 0)
+		return 0;
+
+	val = *(const uint8_t *)ptr;
+	tclass = (val >> 6);
+	if((val &= 0x1F) != 0x1F) {
+		/*
+		 * Simple form: everything encoded in a single octet.
+		 * Tag Class is encoded using two least significant bits.
+		 */
+		*tag_r = (val << 2) | tclass;
+		return 1;
+	}
+
+	/*
+	 * Each octet contains 7 bits of useful information.
+	 * The MSB is 0 if it is the last octet of the tag.
+	 */
+	for(val = 0, ptr = ((const char *)ptr) + 1, skipped = 2;
+			skipped <= size;
+				ptr = ((const char *)ptr) + 1, skipped++) {
+		unsigned int oct = *(const uint8_t *)ptr;
+		if(oct & 0x80) {
+			val = (val << 7) | (oct & 0x7F);
+			/*
+			 * Make sure there are at least 9 bits spare
+			 * at the MS side of a value.
+			 */
+			if(val >> ((8 * sizeof(val)) - 9)) {
+				/*
+				 * We would not be able to accommodate
+				 * any more tag bits.
+				 */
+				return -1;
+			}
+		} else {
+			val = (val << 7) | oct;
+			*tag_r = (val << 2) | tclass;
+			return skipped;
+		}
+	}
+
+	return 0;	/* Want more */
+}
+
+
+ssize_t
+ber_tlv_tag_fwrite(ber_tlv_tag_t tag, FILE *f) {
+	char buf[sizeof("[APPLICATION ]") + 32];
+	ssize_t ret;
+
+	ret = ber_tlv_tag_snprint(tag, buf, sizeof(buf));
+	if(ret >= (ssize_t)sizeof(buf) || ret < 2) {
+		errno = EPERM;
+		return -1;
+	}
+
+	return fwrite(buf, 1, ret, f);
+}
+
+ssize_t
+ber_tlv_tag_snprint(ber_tlv_tag_t tag, char *buf, size_t size) {
+	const char *type = 0;
+	int ret;
+
+	switch(tag & 0x3) {
+	case ASN_TAG_CLASS_UNIVERSAL:	type = "UNIVERSAL ";	break;
+	case ASN_TAG_CLASS_APPLICATION:	type = "APPLICATION ";	break;
+	case ASN_TAG_CLASS_CONTEXT:	type = "";		break;
+	case ASN_TAG_CLASS_PRIVATE:	type = "PRIVATE ";	break;
+	}
+
+	ret = snprintf(buf, size, "[%s%u]", type, ((unsigned)tag) >> 2);
+	if(ret <= 0 && size) buf[0] = '\0';	/* against broken libc's */
+
+	return ret;
+}
+
+char *
+ber_tlv_tag_string(ber_tlv_tag_t tag) {
+	static char buf[sizeof("[APPLICATION ]") + 32];
+
+	(void)ber_tlv_tag_snprint(tag, buf, sizeof(buf));
+
+	return buf;
+}
+
+
+size_t
+ber_tlv_tag_serialize(ber_tlv_tag_t tag, void *bufp, size_t size) {
+	int tclass = BER_TAG_CLASS(tag);
+	ber_tlv_tag_t tval = BER_TAG_VALUE(tag);
+	uint8_t *buf = (uint8_t *)bufp;
+	uint8_t *end;
+	size_t required_size;
+	size_t i;
+
+	if(tval <= 30) {
+		/* Encoded in 1 octet */
+		if(size) buf[0] = (tclass << 6) | tval;
+		return 1;
+	} else if(size) {
+		*buf++ = (tclass << 6) | 0x1F;
+		size--;
+	}
+
+	/*
+	 * Compute the size of the subsequent bytes.
+	 */
+	for(required_size = 1, i = 7; i < 8 * sizeof(tval); i += 7) {
+		if(tval >> i)
+			required_size++;
+		else
+			break;
+	}
+
+	if(size < required_size)
+		return required_size + 1;
+
+	/*
+	 * Fill in the buffer, space permitting.
+	 */
+	end = buf + required_size - 1;
+	for(i -= 7; buf < end; i -= 7, buf++)
+		*buf = 0x80 | ((tval >> i) & 0x7F);
+	*buf = (tval & 0x7F);	/* Last octet without high bit */
+
+	return required_size + 1;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_tag.h /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_tag.h
new file mode 100644
index 000000000..ce227add6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/ber_tlv_tag.h
@@ -0,0 +1,60 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_BER_TLV_TAG_H_
+#define	_BER_TLV_TAG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum asn_tag_class {
+	ASN_TAG_CLASS_UNIVERSAL		= 0,	/* 0b00 */
+	ASN_TAG_CLASS_APPLICATION	= 1,	/* 0b01 */
+	ASN_TAG_CLASS_CONTEXT		= 2,	/* 0b10 */
+	ASN_TAG_CLASS_PRIVATE		= 3	/* 0b11 */
+};
+typedef unsigned ber_tlv_tag_t;	/* BER TAG from Tag-Length-Value */
+
+/*
+ * Tag class is encoded together with tag value for optimization purposes.
+ */
+#define	BER_TAG_CLASS(tag)	((tag) & 0x3)
+#define	BER_TAG_VALUE(tag)	((tag) >> 2)
+#define	BER_TLV_CONSTRUCTED(tagptr)	(((*(const uint8_t *)tagptr)&0x20)?1:0)
+
+#define	BER_TAGS_EQUAL(tag1, tag2)	((tag1) == (tag2))
+
+/*
+ * Several functions for printing the TAG in the canonical form
+ * (i.e. "[PRIVATE 0]").
+ * Return values correspond to their libc counterparts (if any).
+ */
+ssize_t ber_tlv_tag_snprint(ber_tlv_tag_t tag, char *buf, size_t buflen);
+ssize_t ber_tlv_tag_fwrite(ber_tlv_tag_t tag, FILE *);
+char *ber_tlv_tag_string(ber_tlv_tag_t tag);
+
+
+/*
+ * This function tries to fetch the tag from the input stream.
+ * RETURN VALUES:
+ * 	 0:	More data expected than bufptr contains.
+ * 	-1:	Fatal error deciphering tag.
+ *	>0:	Number of bytes used from bufptr. tag_r will contain the tag.
+ */
+ssize_t ber_fetch_tag(const void *bufptr, size_t size, ber_tlv_tag_t *tag_r);
+
+/*
+ * This function serializes the tag (T from TLV) in BER format.
+ * It always returns number of bytes necessary to represent the tag,
+ * it is a caller's responsibility to check the return value
+ * against the supplied buffer's size.
+ */
+size_t ber_tlv_tag_serialize(ber_tlv_tag_t tag, void *bufptr, size_t size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _BER_TLV_TAG_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE.c
new file mode 100644
index 000000000..506fe74a5
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+
+asn_TYPE_operation_t asn_OP_CHOICE = {
+    CHOICE_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    CHOICE_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    CHOICE_compare,
+    CHOICE_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    CHOICE_decode_ber,
+    CHOICE_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    CHOICE_decode_xer,
+    CHOICE_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    CHOICE_decode_jer,
+    CHOICE_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    CHOICE_decode_oer,
+    CHOICE_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    CHOICE_decode_uper,
+    CHOICE_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    CHOICE_decode_aper,
+    CHOICE_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    CHOICE_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    CHOICE_outmost_tag
+};
+
+ber_tlv_tag_t
+CHOICE_outmost_tag(const asn_TYPE_descriptor_t *td, const void *ptr, int tag_mode, ber_tlv_tag_t tag) {
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+    unsigned present;
+
+    assert(tag_mode == 0); (void)tag_mode;
+    assert(tag == 0); (void)tag;
+
+    /*
+     * Figure out which CHOICE element is encoded.
+     */
+    present = _fetch_present_idx(ptr, specs->pres_offset, specs->pres_size);
+
+    if(present > 0 && present <= td->elements_count) {
+        const asn_TYPE_member_t *elm = &td->elements[present-1];
+        const void *memb_ptr;
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr = *(const void * const *)
+                    ((const char *)ptr + elm->memb_offset);
+        } else {
+            memb_ptr = (const void *)
+                    ((const char *)ptr + elm->memb_offset);
+        }
+
+        return asn_TYPE_outmost_tag(elm->type, memb_ptr,
+                                    elm->tag_mode, elm->tag);
+    } else {
+        return (ber_tlv_tag_t)-1;
+    }
+}
+
+/*
+ * See the definitions.
+ */
+static const void *_get_member_ptr(const asn_TYPE_descriptor_t *,
+                                   const void *sptr, asn_TYPE_member_t **elm,
+                                   unsigned *present);
+
+int
+CHOICE_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
+                  asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    unsigned present;
+
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+
+	/*
+	 * Figure out which CHOICE element is encoded.
+	 */
+	present = _fetch_present_idx(sptr, specs->pres_offset,specs->pres_size);
+	if(present > 0 && present <= td->elements_count) {
+		asn_TYPE_member_t *elm = &td->elements[present-1];
+		const void *memb_ptr;
+
+		if(elm->flags & ATF_POINTER) {
+			memb_ptr = *(const void * const *)((const char *)sptr + elm->memb_offset);
+			if(!memb_ptr) {
+				if(elm->optional)
+					return 0;
+				ASN__CTFAIL(app_key, td, sptr,
+					"%s: mandatory CHOICE element %s absent (%s:%d)",
+					td->name, elm->name, __FILE__, __LINE__);
+				return -1;
+			}
+		} else {
+			memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+		}
+
+		if(elm->encoding_constraints.general_constraints) {
+			return elm->encoding_constraints.general_constraints(elm->type, memb_ptr,
+				ctfailcb, app_key);
+		} else {
+			return elm->type->encoding_constraints.general_constraints(elm->type,
+					memb_ptr, ctfailcb, app_key);
+		}
+	} else {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: no CHOICE element given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+}
+
+void
+CHOICE_free(const asn_TYPE_descriptor_t *td, void *ptr,
+            enum asn_struct_free_method method) {
+    const asn_CHOICE_specifics_t *specs;
+    unsigned present;
+
+	if(!td || !ptr)
+		return;
+
+    specs = (const asn_CHOICE_specifics_t *)td->specifics;
+
+	ASN_DEBUG("Freeing %s as CHOICE", td->name);
+
+	/*
+	 * Figure out which CHOICE element is encoded.
+	 */
+	present = _fetch_present_idx(ptr, specs->pres_offset, specs->pres_size);
+
+	/*
+	 * Free that element.
+	 */
+	if(present > 0 && present <= td->elements_count) {
+		asn_TYPE_member_t *elm = &td->elements[present-1];
+		void *memb_ptr;
+
+		if(elm->flags & ATF_POINTER) {
+			memb_ptr = *(void **)((char *)ptr + elm->memb_offset);
+			if(memb_ptr)
+				ASN_STRUCT_FREE(*elm->type, memb_ptr);
+		} else {
+			memb_ptr = (void *)((char *)ptr + elm->memb_offset);
+			ASN_STRUCT_FREE_CONTENTS_ONLY(*elm->type, memb_ptr);
+		}
+	}
+
+    switch(method) {
+    case ASFM_FREE_EVERYTHING:
+        FREEMEM(ptr);
+        break;
+    case ASFM_FREE_UNDERLYING:
+        break;
+    case ASFM_FREE_UNDERLYING_AND_RESET:
+        memset(ptr, 0, specs->struct_size);
+        break;
+    }
+}
+
+
+/*
+ * The following functions functions offer protection against -fshort-enums,
+ * compatible with little- and big-endian machines.
+ * If assertion is triggered, either disable -fshort-enums, or add an entry
+ * here with the ->pres_size of your target stracture.
+ * Unless the target structure is packed, the ".present" member
+ * is guaranteed to be aligned properly. ASN.1 compiler itself does not
+ * produce packed code.
+ */
+unsigned
+_fetch_present_idx(const void *struct_ptr, unsigned pres_offset,
+                   unsigned pres_size) {
+    const void *present_ptr;
+	unsigned present;
+
+	present_ptr = ((const char *)struct_ptr) + pres_offset;
+
+	switch(pres_size) {
+	case sizeof(int):	present = *(const unsigned int *)present_ptr; break;
+	case sizeof(short):	present = *(const unsigned short *)present_ptr; break;
+	case sizeof(char):	present = *(const unsigned char *)present_ptr; break;
+	default:
+		/* ANSI C mandates enum to be equivalent to integer */
+		assert(pres_size != sizeof(int));
+		return 0;	/* If not aborted, pass back safe value */
+	}
+
+	return present;
+}
+
+void
+_set_present_idx(void *struct_ptr, unsigned pres_offset, unsigned pres_size,
+                 unsigned present) {
+    void *present_ptr;
+	present_ptr = ((char *)struct_ptr) + pres_offset;
+
+	switch(pres_size) {
+	case sizeof(int):	*(unsigned int *)present_ptr   = present; break;
+	case sizeof(short):	*(unsigned short *)present_ptr = present; break;
+	case sizeof(char):	*(unsigned char *)present_ptr  = present; break;
+	default:
+		/* ANSI C mandates enum to be equivalent to integer */
+		assert(pres_size != sizeof(int));
+	}
+}
+
+static const void *
+_get_member_ptr(const asn_TYPE_descriptor_t *td, const void *sptr,
+                asn_TYPE_member_t **elm_ptr, unsigned *present_out) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    unsigned present;
+
+    if(!sptr) {
+        *elm_ptr = NULL;
+        *present_out = 0;
+        return NULL;
+    }
+
+    /*
+	 * Figure out which CHOICE element is encoded.
+	 */
+	present = _fetch_present_idx(sptr, specs->pres_offset, specs->pres_size);
+    *present_out = present;
+
+    /*
+     * The presence index is intentionally 1-based to avoid
+     * treating zeroed structure as a valid one.
+     */
+	if(present > 0 && present <= td->elements_count) {
+        asn_TYPE_member_t *const elm = &td->elements[present - 1];
+        const void *memb_ptr;
+
+		if(elm->flags & ATF_POINTER) {
+            memb_ptr =
+                *(const void *const *)((const char *)sptr + elm->memb_offset);
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+        }
+        *elm_ptr = elm;
+        return memb_ptr;
+    } else {
+        *elm_ptr = NULL;
+        return NULL;
+    }
+
+}
+
+int
+CHOICE_compare(const asn_TYPE_descriptor_t *td, const void *aptr, const void *bptr) {
+    asn_TYPE_member_t *aelm;
+    asn_TYPE_member_t *belm;
+    unsigned apresent = 0;
+    unsigned bpresent = 0;
+    const void *amember = _get_member_ptr(td, aptr, &aelm, &apresent);
+    const void *bmember = _get_member_ptr(td, bptr, &belm, &bpresent);
+
+    if(amember && bmember) {
+        if(apresent == bpresent) {
+            assert(aelm == belm);
+            return aelm->type->op->compare_struct(aelm->type, amember, bmember);
+        } else if(apresent < bpresent) {
+            return -1;
+        } else {
+            return 1;
+        }
+    } else if(!amember) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+int
+CHOICE_copy(const asn_TYPE_descriptor_t *td, void **aptr, const void *bptr) {
+    if(!td) return -1;
+
+    void *st = *aptr;
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm;  /* CHOICE's element */
+    int present;
+    int ret;
+	void *amemb;
+    void **amembp;
+    const void *bmemb;
+
+    if(!bptr) {
+        if(st) {
+            ASN_STRUCT_FREE(*td, st);
+            *aptr = NULL;
+        }
+        return 0;
+    }
+
+    if(!st) {
+        st = *aptr = CALLOC(1, specs->struct_size);
+        if(!st) return -1;
+    }
+
+    present = _fetch_present_idx(bptr,
+                                 specs->pres_offset, specs->pres_size);
+
+    if(present <= 0 && (unsigned)present > td->elements_count) return -1;
+    --present;
+
+    elm = &td->elements[present];
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        amembp = (void **)((char *)st + elm->memb_offset);
+        bmemb = *(const void* const*)((const char*)bptr + elm->memb_offset);
+    } else {
+        amemb = (char *)st + elm->memb_offset;
+        amembp = &amemb;
+        bmemb = (const void*)((const char*)bptr + elm->memb_offset);
+    }
+    ret = elm->type->op->copy_struct(elm->type, amembp, bmemb);
+    if (ret != 0) return ret;
+
+    _set_present_idx(st,
+            specs->pres_offset,
+            specs->pres_size, present + 1);
+
+    return 0;
+}
+
+/*
+ * Return the 1-based choice variant presence index.
+ * Returns 0 in case of error.
+ */
+unsigned
+CHOICE_variant_get_presence(const asn_TYPE_descriptor_t *td, const void *sptr) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    return _fetch_present_idx(sptr, specs->pres_offset, specs->pres_size);
+}
+
+/*
+ * Sets or resets the 1-based choice variant presence index.
+ * In case a previous index is not zero, the currently selected structure
+ * member is freed and zeroed-out first.
+ * Returns 0 on success and -1 on error.
+ */
+int
+CHOICE_variant_set_presence(const asn_TYPE_descriptor_t *td, void *sptr,
+                            unsigned present) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    unsigned old_present;
+
+    if(!sptr) {
+        return -1;
+    }
+
+    if(present > td->elements_count)
+        return -1;
+
+    old_present =
+        _fetch_present_idx(sptr, specs->pres_offset, specs->pres_size);
+    if(present == old_present)
+        return 0;
+
+    if(old_present != 0) {
+        assert(old_present <= td->elements_count);
+        ASN_STRUCT_RESET(*td, sptr);
+    }
+
+    _set_present_idx(sptr, specs->pres_offset, specs->pres_size, present);
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE.h /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE.h
new file mode 100644
index 000000000..f83d06b46
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_CONSTR_CHOICE_H_
+#define	_CONSTR_CHOICE_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct asn_CHOICE_specifics_s {
+	/*
+	 * Target structure description.
+	 */
+	unsigned struct_size;       /* Size of the target structure. */
+	unsigned ctx_offset;        /* Offset of the asn_codec_ctx_t member */
+	unsigned pres_offset;       /* Identifier of the present member */
+	unsigned pres_size;         /* Size of the identifier (enum) */
+
+	/*
+	 * Tags to members mapping table.
+	 */
+	const asn_TYPE_tag2member_t *tag2el;
+	unsigned tag2el_count;
+
+	/* Canonical ordering of CHOICE elements, for PER */
+	const unsigned *to_canonical_order;
+	const unsigned *from_canonical_order;
+
+	/*
+	 * Extensions-related stuff.
+	 */
+	signed ext_start; /* First member of extensions, or -1 */
+} asn_CHOICE_specifics_t;
+
+/*
+ * A set specialized functions dealing with the CHOICE type.
+ */
+asn_struct_free_f CHOICE_free;
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f CHOICE_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f CHOICE_compare;
+asn_struct_copy_f    CHOICE_copy;
+
+asn_constr_check_f CHOICE_constraint;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+ber_type_decoder_f CHOICE_decode_ber;
+der_type_encoder_f CHOICE_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f CHOICE_decode_xer;
+xer_type_encoder_f CHOICE_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f CHOICE_decode_jer;
+jer_type_encoder_f CHOICE_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f CHOICE_decode_oer;
+oer_type_encoder_f CHOICE_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f CHOICE_decode_uper;
+per_type_encoder_f CHOICE_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f CHOICE_decode_aper;
+per_type_encoder_f CHOICE_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f CHOICE_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+asn_outmost_tag_f CHOICE_outmost_tag;
+
+extern asn_TYPE_operation_t asn_OP_CHOICE;
+
+unsigned _fetch_present_idx(
+        const void *struct_ptr,
+        unsigned off,
+        unsigned size);
+
+void _set_present_idx(
+        void *sptr,
+        unsigned offset,
+        unsigned size,
+        unsigned present);
+
+/*
+ * Return the 1-based choice variant presence index.
+ * Returns 0 in case of error.
+ */
+unsigned CHOICE_variant_get_presence(const asn_TYPE_descriptor_t *td,
+                                     const void *structure_ptr);
+
+/*
+ * Sets or resets the 1-based choice variant presence index.
+ * In case a previous index is not zero, the currently selected structure
+ * member is freed and zeroed-out first.
+ * Returns 0 on success and -1 on error.
+ */
+int CHOICE_variant_set_presence(const asn_TYPE_descriptor_t *td,
+                                void *structure_ptr, unsigned present);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _CONSTR_CHOICE_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_aper.c
new file mode 100644
index 000000000..9c0001988
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_aper.c
@@ -0,0 +1,179 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+#include "aper_opentype.h"
+
+asn_dec_rval_t
+CHOICE_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_dec_rval_t rv;
+    const asn_per_constraint_t *ct = NULL;
+    asn_TYPE_member_t *elm = NULL;  /* CHOICE's element */
+    void *memb_ptr = NULL;
+    void **memb_ptr2 = NULL;
+    void *st = *sptr;
+    int value = 0;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(!st) {
+        st = *sptr = CALLOC(1, specs->struct_size);
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->value;
+    else ct = 0;
+
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        value = per_get_few_bits(pd, 1);
+        if(value < 0) ASN__DECODE_STARVED;
+        if(value) ct = 0;  /* Not restricted */
+        if((unsigned)value >= td->elements_count)
+            ASN__DECODE_FAILED;
+    }
+
+    if(ct && ct->range_bits >= 0) {
+        value = per_get_few_bits(pd, ct->range_bits);
+        if(value < 0) ASN__DECODE_STARVED;
+        ASN_DEBUG("CHOICE %s got index %d in range %d",
+                  td->name, value, ct->range_bits);
+        if(value > ct->upper_bound)
+            ASN__DECODE_FAILED;
+    } else {
+        if(specs->ext_start == -1)
+            ASN__DECODE_FAILED;
+
+        if(specs && specs->tag2el_count > (unsigned)specs->ext_start) {
+            value = aper_get_nsnnwn(pd); /* extension elements range */
+            if(value < 0) ASN__DECODE_STARVED;
+            value += specs->ext_start;
+            if((unsigned)value >= td->elements_count)
+                ASN__DECODE_FAILED;
+        }
+    }
+
+    /* Adjust if canonical order is different from natural order */
+    if(specs->from_canonical_order)
+        value = specs->from_canonical_order[value];
+
+    /* Set presence to be able to free it later */
+    _set_present_idx(st, specs->pres_offset, specs->pres_size, value + 1);
+
+    elm = &td->elements[value];
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)st + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    ASN_DEBUG("Discovered CHOICE %s encodes %s", td->name, elm->name);
+
+    if(ct && ct->range_bits >= 0) {
+        rv = elm->type->op->aper_decoder(opt_codec_ctx, elm->type,
+                                         elm->encoding_constraints.per_constraints, memb_ptr2, pd);
+    } else {
+        rv = aper_open_type_get(opt_codec_ctx, elm->type,
+                                elm->encoding_constraints.per_constraints, memb_ptr2, pd);
+    }
+
+    if(rv.code != RC_OK)
+        ASN_DEBUG("Failed to decode %s in %s (CHOICE) %d",
+                  elm->name, td->name, rv.code);
+    return rv;
+}
+
+asn_enc_rval_t
+CHOICE_encode_aper(const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints,
+                   const void *sptr, asn_per_outp_t *po) {
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm;  /* CHOICE's element */
+    const asn_per_constraint_t *ct;
+    const void *memb_ptr;
+    int present;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Encoding %s as CHOICE using ALIGNED PER", td->name);
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->value;
+    else ct = 0;
+
+    present = _fetch_present_idx(sptr,
+                                 specs->pres_offset, specs->pres_size);
+
+    /*
+     * If the structure was not initialized properly, it cannot be encoded:
+     * can't deduce what to encode in the choice type.
+     */
+    if(present <= 0 || (unsigned)present > td->elements_count)
+        ASN__ENCODE_FAILED;
+    else
+        present--;
+
+    /* Adjust if canonical order is different from natural order */
+    if(specs->to_canonical_order)
+        present = specs->to_canonical_order[present];
+
+    ASN_DEBUG("Encoding %s CHOICE element %d", td->name, present);
+
+    if(ct && ct->range_bits >= 0) {
+        if(present < ct->lower_bound
+                || present > ct->upper_bound) {
+            if(ct->flags & APC_EXTENSIBLE) {
+                if(per_put_few_bits(po, 1, 1))
+                    ASN__ENCODE_FAILED;
+            } else {
+                ASN__ENCODE_FAILED;
+            }
+            ct = 0;
+        }
+    }
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        if(per_put_few_bits(po, 0, 1))
+            ASN__ENCODE_FAILED;
+    }
+
+    elm = &td->elements[present];
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        memb_ptr = *(const void *const *)((const char *)sptr + elm->memb_offset);
+        if(!memb_ptr) ASN__ENCODE_FAILED;
+    } else {
+        memb_ptr = (const char *)sptr + elm->memb_offset;
+    }
+
+    if(ct && ct->range_bits >= 0) {
+        if(per_put_few_bits(po, present, ct->range_bits))
+            ASN__ENCODE_FAILED;
+
+        return elm->type->op->aper_encoder(elm->type, elm->encoding_constraints.per_constraints,
+                                           memb_ptr, po);
+    } else {
+        asn_enc_rval_t rval = {0,0,0};
+        if(specs->ext_start == -1)
+            ASN__ENCODE_FAILED;
+        if(aper_put_nsnnwn(po, present - specs->ext_start))
+            ASN__ENCODE_FAILED;
+        if(aper_open_type_put(elm->type, elm->encoding_constraints.per_constraints,
+                              memb_ptr, po))
+            ASN__ENCODE_FAILED;
+        rval.encoded = 0;
+        ASN__ENCODED_OK(rval);
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_ber.c
new file mode 100644
index 000000000..b436de077
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_ber.c
@@ -0,0 +1,447 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+
+/*
+ * Number of bytes left for this structure.
+ * (ctx->left) indicates the number of bytes _transferred_ for the structure.
+ * (size) contains the number of bytes in the buffer passed.
+ */
+#define LEFT ((size<(size_t)ctx->left)?size:(size_t)ctx->left)
+
+/*
+ * If the subprocessor function returns with an indication that it wants
+ * more data, it may well be a fatal decoding problem, because the
+ * size is constrained by the <TLV>'s L, even if the buffer size allows
+ * reading more data.
+ * For example, consider the buffer containing the following TLVs:
+ * <T:5><L:1><V> <T:6>...
+ * The TLV length clearly indicates that one byte is expected in V, but
+ * if the V processor returns with "want more data" even if the buffer
+ * contains way more data than the V processor have seen.
+ */
+#define SIZE_VIOLATION (ctx->left >= 0 && (size_t)ctx->left <= size)
+
+/*
+ * This macro "eats" the part of the buffer which is definitely "consumed",
+ * i.e. was correctly converted into local representation or rightfully skipped.
+ */
+#undef ADVANCE
+#define ADVANCE(num_bytes)                \
+    do {                                  \
+        size_t num = num_bytes;           \
+        ptr = ((const char *)ptr) + num;  \
+        size -= num;                      \
+        if(ctx->left >= 0)                \
+            ctx->left -= num;             \
+        consumed_myself += num;           \
+    } while(0)
+
+/*
+ * Switch to the next phase of parsing.
+ */
+#undef NEXT_PHASE
+#define NEXT_PHASE(ctx)  \
+    do {                 \
+        ctx->phase++;    \
+        ctx->step = 0;   \
+    } while(0)
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+/*
+ * Tags are canonically sorted in the tag to member table.
+ */
+static int
+_search4tag(const void *ap, const void *bp) {
+    const asn_TYPE_tag2member_t *a = (const asn_TYPE_tag2member_t *)ap;
+    const asn_TYPE_tag2member_t *b = (const asn_TYPE_tag2member_t *)bp;
+
+    int a_class = BER_TAG_CLASS(a->el_tag);
+    int b_class = BER_TAG_CLASS(b->el_tag);
+
+    if(a_class == b_class) {
+        ber_tlv_tag_t a_value = BER_TAG_VALUE(a->el_tag);
+        ber_tlv_tag_t b_value = BER_TAG_VALUE(b->el_tag);
+
+        if(a_value == b_value)
+            return 0;
+        else if(a_value < b_value)
+            return -1;
+        else
+            return 1;
+    } else if(a_class < b_class) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+/*
+ * The decoder of the CHOICE type.
+ */
+asn_dec_rval_t
+CHOICE_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td, void **struct_ptr,
+                  const void *ptr, size_t size, int tag_mode) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_TYPE_member_t *elements = td->elements;
+
+    /*
+     * Parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    ber_tlv_tag_t tlv_tag;  /* T from TLV */
+    ssize_t tag_len;        /* Length of TLV's T */
+    asn_dec_rval_t rval;    /* Return code from subparsers */
+
+    ssize_t consumed_myself = 0;  /* Consumed bytes from ptr */
+
+    ASN_DEBUG("Decoding %s as CHOICE", td->name);
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) {
+            RETURN(RC_FAIL);
+        }
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Start to parse where left previously
+     */
+    switch(ctx->phase) {
+    case 0:
+        /*
+         * PHASE 0.
+         * Check that the set of tags associated with given structure
+         * perfectly fits our expectations.
+         */
+
+        if(tag_mode || td->tags_count) {
+            rval = ber_check_tags(opt_codec_ctx, td, ctx, ptr, size,
+                                  tag_mode, -1, &ctx->left, 0);
+            if(rval.code != RC_OK) {
+                ASN_DEBUG("%s tagging check failed: %d",
+                          td->name, rval.code);
+                return rval;
+            }
+
+            if(ctx->left >= 0) {
+                /* ?Subtracted below! */
+                ctx->left += rval.consumed;
+            }
+            ADVANCE(rval.consumed);
+        } else {
+            ctx->left = -1;
+        }
+
+        NEXT_PHASE(ctx);
+
+        ASN_DEBUG("Structure consumes %ld bytes, buffer %ld",
+                  (long)ctx->left, (long)size);
+
+        /* Fall through */
+    case 1:
+        /*
+         * Fetch the T from TLV.
+         */
+        tag_len = ber_fetch_tag(ptr, LEFT, &tlv_tag);
+        ASN_DEBUG("In %s CHOICE tag length %d", td->name, (int)tag_len);
+        switch(tag_len) {
+        case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+            /* Fall through */
+        case -1: RETURN(RC_FAIL);
+        }
+
+        do {
+            const asn_TYPE_tag2member_t *t2m;
+            asn_TYPE_tag2member_t key;
+
+            key.el_tag = tlv_tag;
+            t2m = (const asn_TYPE_tag2member_t *)bsearch(&key,
+                    specs->tag2el, specs->tag2el_count,
+                    sizeof(specs->tag2el[0]), _search4tag);
+            if(t2m) {
+                /*
+                 * Found the element corresponding to the tag.
+                 */
+                NEXT_PHASE(ctx);
+                ctx->step = t2m->el_no;
+                break;
+            } else if(specs->ext_start == -1) {
+                ASN_DEBUG("Unexpected tag %s "
+                          "in non-extensible CHOICE %s",
+                          ber_tlv_tag_string(tlv_tag), td->name);
+                RETURN(RC_FAIL);
+            } else {
+                /* Skip this tag */
+                ssize_t skip;
+
+                ASN_DEBUG("Skipping unknown tag %s",
+                          ber_tlv_tag_string(tlv_tag));
+
+                skip = ber_skip_length(opt_codec_ctx,
+                                       BER_TLV_CONSTRUCTED(ptr),
+                                       (const char *)ptr + tag_len,
+                                       LEFT - tag_len);
+
+                switch(skip) {
+                case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+                    /* Fall through */
+                case -1: RETURN(RC_FAIL);
+                }
+
+                ADVANCE(skip + tag_len);
+                RETURN(RC_OK);
+            }
+        } while(0);
+
+    case 2:
+        /*
+         * PHASE 2.
+         * Read in the element.
+         */
+        do {
+            asn_TYPE_member_t *elm;/* CHOICE's element */
+            void *memb_ptr;    /* Pointer to the member */
+            void **memb_ptr2;  /* Pointer to that pointer */
+
+            elm = &elements[ctx->step];
+
+            /*
+             * Compute the position of the member inside a structure,
+             * and also a type of containment (it may be contained
+             * as pointer or using inline inclusion).
+             */
+            if(elm->flags & ATF_POINTER) {
+                /* Member is a pointer to another structure */
+                memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+            } else {
+                /*
+                 * A pointer to a pointer
+                 * holding the start of the structure
+                 */
+                memb_ptr = (char *)st + elm->memb_offset;
+                memb_ptr2 = &memb_ptr;
+            }
+            /* Set presence to be able to free it properly at any time */
+            _set_present_idx(st, specs->pres_offset,
+                             specs->pres_size, ctx->step + 1);
+            /*
+             * Invoke the member fetch routine according to member's type
+             */
+            rval = elm->type->op->ber_decoder(opt_codec_ctx, elm->type,
+                                              memb_ptr2, ptr, LEFT,
+                                              elm->tag_mode);
+            switch(rval.code) {
+            case RC_OK:
+                break;
+            case RC_WMORE: /* More data expected */
+                if(!SIZE_VIOLATION) {
+                    ADVANCE(rval.consumed);
+                    RETURN(RC_WMORE);
+                }
+                RETURN(RC_FAIL);
+            case RC_FAIL: /* Fatal error */
+                RETURN(rval.code);
+            } /* switch(rval) */
+
+            ADVANCE(rval.consumed);
+        } while(0);
+
+        NEXT_PHASE(ctx);
+
+        /* Fall through */
+    case 3:
+        ASN_DEBUG("CHOICE %s Leftover: %ld, size = %ld, tm=%d, tc=%d",
+                  td->name, (long)ctx->left, (long)size,
+                  tag_mode, td->tags_count);
+
+        if(ctx->left > 0) {
+            /*
+             * The type must be fully decoded
+             * by the CHOICE member-specific decoder.
+             */
+            RETURN(RC_FAIL);
+        }
+
+        if(ctx->left == -1
+        && !(tag_mode || td->tags_count)) {
+            /*
+             * This is an untagged CHOICE.
+             * It doesn't contain nothing
+             * except for the member itself, including all its tags.
+             * The decoding is completed.
+             */
+            NEXT_PHASE(ctx);
+            break;
+        }
+
+        /*
+         * Read in the "end of data chunks"'s.
+         */
+        while(ctx->left < 0) {
+            ssize_t tl;
+
+            tl = ber_fetch_tag(ptr, LEFT, &tlv_tag);
+            switch(tl) {
+            case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+                /* Fall through */
+            case -1: RETURN(RC_FAIL);
+            }
+
+            /*
+             * Expected <0><0>...
+             */
+            if(((const uint8_t *)ptr)[0] == 0) {
+                if(LEFT < 2) {
+                    if(SIZE_VIOLATION)
+                        RETURN(RC_FAIL);
+                    else
+                        RETURN(RC_WMORE);
+                } else if(((const uint8_t *)ptr)[1] == 0) {
+                    /*
+                     * Correctly finished with <0><0>.
+                     */
+                    ADVANCE(2);
+                    ctx->left++;
+                    continue;
+                }
+            } else {
+                ASN_DEBUG("Unexpected continuation in %s",
+                          td->name);
+                RETURN(RC_FAIL);
+            }
+
+            /* UNREACHABLE */
+        }
+
+        NEXT_PHASE(ctx);
+    case 4:
+        /* No meaningful work here */
+        break;
+    }
+
+    RETURN(RC_OK);
+}
+
+asn_enc_rval_t
+CHOICE_encode_der(const asn_TYPE_descriptor_t *td, const void *sptr,
+                  int tag_mode, ber_tlv_tag_t tag, asn_app_consume_bytes_f *cb,
+                  void *app_key) {
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_TYPE_member_t *elm;  /* CHOICE element */
+    asn_enc_rval_t erval = {0,0,0};
+    const void *memb_ptr;
+    size_t computed_size = 0;
+    unsigned present;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("%s %s as CHOICE",
+              cb ? "Encoding" : "Estimating", td->name);
+
+    present = _fetch_present_idx(sptr,
+        specs->pres_offset, specs->pres_size);
+
+    /*
+     * If the structure was not initialized, it cannot be encoded:
+     * can't deduce what to encode in the choice type.
+     */
+    if(present == 0 || present > td->elements_count) {
+        if(present == 0 && td->elements_count == 0) {
+            /* The CHOICE is empty?! */
+            erval.encoded = 0;
+            ASN__ENCODED_OK(erval);
+        }
+        ASN__ENCODE_FAILED;
+    }
+
+    /*
+     * Seek over the present member of the structure.
+     */
+    elm = &td->elements[present-1];
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr =
+            *(const void *const *)((const char *)sptr + elm->memb_offset);
+        if(memb_ptr == 0) {
+            if(elm->optional) {
+                erval.encoded = 0;
+                ASN__ENCODED_OK(erval);
+            }
+            /* Mandatory element absent */
+            ASN__ENCODE_FAILED;
+        }
+    } else {
+        memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+    }
+
+    /*
+     * If the CHOICE itself is tagged EXPLICIT:
+     * T ::= [2] EXPLICIT CHOICE { ... }
+     * Then emit the appropriate tags.
+     */
+    if(tag_mode == 1 || td->tags_count) {
+        /*
+         * For this, we need to pre-compute the member.
+         */
+        ssize_t ret;
+
+        /* Encode member with its tag */
+        erval = elm->type->op->der_encoder(elm->type, memb_ptr,
+                                           elm->tag_mode,
+                                           elm->tag, 0, 0);
+        if(erval.encoded == -1)
+            return erval;
+
+        /* Encode CHOICE with parent or my own tag */
+        ret = der_write_tags(td, erval.encoded, tag_mode, 1, tag,
+                             cb, app_key);
+        if(ret == -1)
+            ASN__ENCODE_FAILED;
+        computed_size += ret;
+    }
+
+    /*
+     * Encode the single underlying member.
+     */
+    erval = elm->type->op->der_encoder(elm->type, memb_ptr,
+                                       elm->tag_mode, elm->tag,
+                                       cb, app_key);
+    if(erval.encoded == -1)
+        return erval;
+
+    ASN_DEBUG("Encoded CHOICE member in %ld bytes (+%ld)",
+              (long)erval.encoded, (long)computed_size);
+
+    erval.encoded += computed_size;
+
+    return erval;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_jer.c
new file mode 100644
index 000000000..f65216277
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_jer.c
@@ -0,0 +1,327 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+#undef JER_ADVANCE
+#define JER_ADVANCE(num_bytes)                                    \
+    do {                                                          \
+        size_t num = num_bytes;                                   \
+        buf_ptr = (const void *)(((const char *)buf_ptr) + num);  \
+        size -= num;                                              \
+        consumed_myself += num;                                   \
+    } while(0)
+
+/*
+ * Decode the JER (JSON) data.
+ */
+asn_dec_rval_t
+CHOICE_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td,
+                  const asn_jer_constraints_t *constraints,
+                  void **struct_ptr, const void *buf_ptr, size_t size) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+
+    /*
+     * Parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    asn_dec_rval_t rval;          /* Return value of a decoder */
+    ssize_t consumed_myself = 0;  /* Consumed bytes from ptr */
+    size_t edx;                   /* Element index */
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) RETURN(RC_FAIL);
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Phases of JER/JSON processing:
+     * Phase 0: Check that the opening key matches our expectations.
+     * Phase 1: Processing body and reacting on closing token.
+     * Phase 2: Processing inner type.
+     * Phase 3: Only waiting for closing token.
+     * Phase 4: Skipping unknown extensions.
+     * Phase 5: PHASED OUT
+     */
+    for(edx = ctx->step; ctx->phase <= 4;) {
+        pjer_chunk_type_e ch_type;  /* JER chunk type */
+        ssize_t ch_size;            /* Chunk size */
+        jer_check_sym_e scv;        /* Tag check value */
+        asn_TYPE_member_t *elm;
+
+        /*
+         * Go inside the member.
+         */
+        if(ctx->phase == 2) {
+            asn_dec_rval_t tmprval;
+            void *memb_ptr;    /* Pointer to the member */
+            void **memb_ptr2;  /* Pointer to that pointer */
+            unsigned old_present __attribute__((unused));
+
+            elm = &td->elements[edx];
+
+            if(elm->flags & ATF_POINTER) {
+                /* Member is a pointer to another structure */
+                memb_ptr2 = (void **)((char *)st
+                    + elm->memb_offset);
+            } else {
+                memb_ptr = (char *)st + elm->memb_offset;
+                memb_ptr2 = &memb_ptr;
+            }
+
+            /* Start/Continue decoding the inner member */
+            tmprval = elm->type->op->jer_decoder(opt_codec_ctx,
+                                                 elm->type,
+                                                 elm->encoding_constraints.jer_constraints,
+                                                 memb_ptr2,
+                                                 buf_ptr, size);
+            JER_ADVANCE(tmprval.consumed);
+            ASN_DEBUG("JER/CHOICE: itdf: [%s] code=%d",
+                      elm->type->name, tmprval.code);
+            old_present = _fetch_present_idx(st,
+                                             specs->pres_offset,
+                                             specs->pres_size);
+            assert(old_present == 0 || old_present == edx + 1);
+            /* Record what we've got */
+            _set_present_idx(st,
+                             specs->pres_offset,
+                             specs->pres_size, edx + 1);
+            if(tmprval.code != RC_OK)
+                RETURN(tmprval.code);
+            ctx->phase = 3;
+            /* Fall through */
+        }
+
+        /*
+         * Get the next part of the JSON stream.
+         */
+        ch_size = jer_next_token(&ctx->context, buf_ptr, size, &ch_type);
+        if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+            switch(ch_type) {
+            case PJER_WMORE:
+                RETURN(RC_WMORE);
+
+            case PJER_TEXT:  /* Ignore free-standing text */
+                JER_ADVANCE(ch_size);  /* Skip silently */
+                continue;
+
+            case PJER_DLM:
+            case PJER_VALUE: 
+            case PJER_KEY:
+                break;  /* Check the rest down there */
+            }
+        }
+
+        scv = jer_check_sym(buf_ptr, ch_size, NULL);
+        ASN_DEBUG("JER/CHOICE checked [%c%c%c%c] of [%s], scv=%d",
+                  ch_size>0?((const uint8_t *)buf_ptr)[0]:'?',
+                  ch_size>1?((const uint8_t *)buf_ptr)[1]:'?',
+                  ch_size>2?((const uint8_t *)buf_ptr)[2]:'?',
+                  ch_size>3?((const uint8_t *)buf_ptr)[3]:'?',
+                  td->name, scv);
+
+        /* Skip the extensions section */
+        if(ctx->phase == 4) {
+            ASN_DEBUG("skip_unknown(%d, %ld)",
+                      scv, (long)ctx->left);
+            switch(jer_skip_unknown(scv, &ctx->left)) {
+            case -1:
+                ctx->phase = 5;
+                RETURN(RC_FAIL);
+            case 1:
+                ctx->phase = 3;
+                /* Fall through */
+            case 0:
+                JER_ADVANCE(ch_size);
+                continue;
+            case 2:
+                ctx->phase = 3;
+                break;
+            }
+        }
+
+        switch(scv) {
+        case JCK_OEND:
+            if(ctx->phase != 3)
+                break;
+            JER_ADVANCE(ch_size);
+            ctx->phase = 5;  /* Phase out */
+            RETURN(RC_OK);
+
+        case JCK_COMMA:
+            JER_ADVANCE(ch_size);
+            continue;
+
+        case JCK_OSTART:
+            if(ctx->phase == 0) {
+                JER_ADVANCE(ch_size);
+                ctx->phase = 1;  /* Processing body phase */
+                continue;
+            }
+            /* Fall through */
+        case JCK_KEY:
+        case JCK_UNKNOWN:
+
+            if(ctx->phase != 1)
+                break;  /* Really unexpected */
+
+            /*
+             * Search which inner member corresponds to this key.
+             */
+            for(edx = 0; edx < td->elements_count; edx++) {
+                elm = &td->elements[edx];
+                scv = jer_check_sym(buf_ptr,ch_size,elm->name);
+                switch(scv) {
+                case JCK_KEY:
+                    /*
+                     * Process this member.
+                     */
+                    ctx->step = edx;
+                    ctx->phase = 2;
+                    JER_ADVANCE(ch_size); /* skip key */
+                    /* skip colon */
+                    ch_size = jer_next_token(&ctx->context, buf_ptr, size,
+                            &ch_type);
+                    if(ch_size == -1) {
+                        RETURN(RC_FAIL);
+                    } else {
+                        switch(ch_type) {
+                        case PJER_WMORE:
+                            RETURN(RC_WMORE);
+                        case PJER_TEXT:  
+                            JER_ADVANCE(ch_size);
+                            break;
+                        default:
+                            RETURN(RC_FAIL);
+                        }
+                    }
+                    break;
+                case JCK_UNKNOWN:
+                    continue;
+                default:
+                    edx = td->elements_count;
+                    break;  /* Phase out */
+                }
+                break;
+            }
+            if(edx != td->elements_count)
+                continue;
+
+            /* It is expected extension */
+            if(specs->ext_start != -1) {
+                ASN_DEBUG("Got anticipated extension");
+                ctx->left = 1;
+                ctx->phase = 4; /* Skip ...'s */
+                JER_ADVANCE(ch_size);
+                continue;
+            }
+
+            /* Fall through */
+        default:
+            break;
+        }
+
+        ASN_DEBUG("Unexpected JSON token [%c%c%c%c] in CHOICE [%s]"
+                  " (ph=%d)",
+                  ch_size>0?((const uint8_t *)buf_ptr)[0]:'?',
+                  ch_size>1?((const uint8_t *)buf_ptr)[1]:'?',
+                  ch_size>2?((const uint8_t *)buf_ptr)[2]:'?',
+                  ch_size>3?((const uint8_t *)buf_ptr)[3]:'?',
+                  td->name, ctx->phase);
+        break;
+    }
+
+    ctx->phase = 5;  /* Phase out, just in case */
+    RETURN(RC_FAIL);
+}
+
+asn_enc_rval_t
+CHOICE_encode_jer(const asn_TYPE_descriptor_t *td, const asn_jer_constraints_t *constraints,
+                  const void *sptr, int ilevel, enum jer_encoder_flags_e flags,
+                  asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    unsigned present = 0;
+    int jmin = (flags & JER_F_MINIFIED);
+
+    if(!sptr)
+        ASN__ENCODE_FAILED;
+
+    /*
+     * Figure out which CHOICE element is encoded.
+     */
+    present = _fetch_present_idx(sptr, specs->pres_offset,specs->pres_size);
+
+    if(present == 0 || present > td->elements_count) {
+        ASN__ENCODE_FAILED;
+    } else {
+        asn_enc_rval_t tmper = {0,0,0};
+        asn_TYPE_member_t *elm = &td->elements[present-1];
+        const void *memb_ptr = NULL;
+        const char *mname = elm->name;
+        unsigned int mlen = strlen(mname);
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr =
+                *(const void *const *)((const char *)sptr + elm->memb_offset);
+            if(!memb_ptr) ASN__ENCODE_FAILED;
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+        }
+
+        er.encoded = 0;
+
+        ASN__CALLBACK("{",1);
+        if(!jmin) {
+            ASN__TEXT_INDENT(1, ilevel + 1);
+            ASN__CALLBACK3("\"", 1, mname, mlen, "\": ", 3);
+        } else {
+            ASN__CALLBACK3("\"", 1, mname, mlen, "\":", 2);
+        }
+
+        tmper = elm->type->op->jer_encoder(elm->type,
+                                           elm->encoding_constraints.jer_constraints,
+                                           memb_ptr,
+                                           ilevel + 1, flags, cb, app_key);
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+
+        if(!jmin) ASN__TEXT_INDENT(1, ilevel);
+        ASN__CALLBACK("}", 1);
+    }
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_oer.c
new file mode 100644
index 000000000..abece11b6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_oer.c
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef  RETURN
+#define RETURN(_code)                    \
+    do {                                 \
+        asn_dec_rval_t rval;             \
+        rval.code = _code;               \
+        rval.consumed = consumed_myself; \
+        return rval;                     \
+    } while(0)
+
+#undef  ADVANCE
+#define ADVANCE(num_bytes)               \
+    do {                                 \
+        size_t num = num_bytes;          \
+        ptr = ((const char *)ptr) + num; \
+        size -= num;                     \
+        consumed_myself += num;          \
+    } while(0)
+
+/*
+ * Switch to the next phase of parsing.
+ */
+#undef  NEXT_PHASE
+#define NEXT_PHASE(ctx) \
+    do {                \
+        ctx->phase++;   \
+        ctx->step = 0;  \
+    } while(0)
+#undef  SET_PHASE
+#define SET_PHASE(ctx, value) \
+    do {                      \
+        ctx->phase = value;   \
+        ctx->step = 0;        \
+    } while(0)
+
+/*
+ * Tags are canonically sorted in the tag to member table.
+ */
+static int
+_search4tag(const void *ap, const void *bp) {
+    const asn_TYPE_tag2member_t *a = (const asn_TYPE_tag2member_t *)ap;
+    const asn_TYPE_tag2member_t *b = (const asn_TYPE_tag2member_t *)bp;
+
+    int a_class = BER_TAG_CLASS(a->el_tag);
+    int b_class = BER_TAG_CLASS(b->el_tag);
+
+    if(a_class == b_class) {
+        ber_tlv_tag_t a_value = BER_TAG_VALUE(a->el_tag);
+        ber_tlv_tag_t b_value = BER_TAG_VALUE(b->el_tag);
+
+        if(a_value == b_value)
+            return 0;
+        else if(a_value < b_value)
+            return -1;
+        else
+            return 1;
+    } else if(a_class < b_class) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+/*
+ * X.696 (08/2015) #8.7 Encoding of tags
+ */
+static ssize_t
+oer_fetch_tag(const void *ptr, size_t size, ber_tlv_tag_t *tag_r) {
+    ber_tlv_tag_t val;
+    ber_tlv_tag_t tclass;
+    size_t skipped;
+
+    if(size == 0)
+        return 0;
+
+    val = *(const uint8_t *)ptr;
+    tclass = (val >> 6);
+    if((val & 0x3F) != 0x3F) {
+        /* #8.7.1 */
+        *tag_r = ((val & 0x3F) << 2) | tclass;
+        return 1;
+    }
+
+    /*
+     * Each octet contains 7 bits of useful information.
+     * The MSB is 0 if it is the last octet of the tag.
+     */
+    for(val = 0, ptr = ((const char *)ptr) + 1, skipped = 2; skipped <= size;
+        ptr = ((const char *)ptr) + 1, skipped++) {
+        unsigned int oct = *(const uint8_t *)ptr;
+        if(oct & 0x80) {
+            val = (val << 7) | (oct & 0x7F);
+            /*
+             * Make sure there are at least 9 bits spare
+             * at the MS side of a value.
+             */
+            if(val >> ((8 * sizeof(val)) - 9)) {
+                /*
+                 * We would not be able to accommodate
+                 * any more tag bits.
+                 */
+                return -1;
+            }
+        } else {
+            val = (val << 7) | oct;
+            *tag_r = (val << 2) | tclass;
+            return skipped;
+        }
+    }
+
+    return 0; /* Want more */
+}
+
+asn_dec_rval_t
+CHOICE_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td,
+                  const asn_oer_constraints_t *constraints, void **struct_ptr,
+                  const void *ptr, size_t size) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_TYPE_member_t *elements = td->elements;
+
+    /*
+     * Parts of the structure being constructed.
+     */
+    void *st = *struct_ptr; /* Target structure. */
+    asn_struct_ctx_t *ctx;  /* Decoder context */
+
+    ssize_t consumed_myself = 0; /* Consumed bytes from ptr */
+
+    (void)constraints;
+
+    ASN_DEBUG("Decoding %s as CHOICE", td->name);
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) {
+            RETURN(RC_FAIL);
+        }
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+    switch(ctx->phase) {
+    case 0: {
+        /*
+         * Discover the tag.
+         */
+        ber_tlv_tag_t tlv_tag; /* T from TLV */
+        ssize_t tag_len;       /* Length of TLV's T */
+
+        tag_len = oer_fetch_tag(ptr, size, &tlv_tag);
+        switch(tag_len) {
+        case 0:
+            ASN__DECODE_STARVED;
+        case -1:
+            ASN__DECODE_FAILED;
+        }
+
+        do {
+            const asn_TYPE_tag2member_t *t2m;
+            asn_TYPE_tag2member_t key = {0, 0, 0, 0};
+            key.el_tag = tlv_tag;
+
+            t2m = (const asn_TYPE_tag2member_t *)bsearch(
+                &key, specs->tag2el, specs->tag2el_count,
+                sizeof(specs->tag2el[0]), _search4tag);
+            if(t2m) {
+                /*
+                 * Found the element corresponding to the tag.
+                 */
+                NEXT_PHASE(ctx);
+                ctx->step = t2m->el_no;
+                break;
+            } else if(specs->ext_start == -1) {
+                ASN_DEBUG(
+                    "Unexpected tag %s "
+                    "in non-extensible CHOICE %s",
+                    ber_tlv_tag_string(tlv_tag), td->name);
+                RETURN(RC_FAIL);
+            } else {
+                /* Skip open type extension */
+                ASN_DEBUG(
+                    "Not implemented skipping open type extension for tag %s",
+                    ber_tlv_tag_string(tlv_tag));
+                RETURN(RC_FAIL);
+            }
+        } while(0);
+
+
+        ADVANCE(tag_len);
+    }
+        /* Fall through */
+    case 1: {
+        asn_TYPE_member_t *elm = &elements[ctx->step]; /* CHOICE's element */
+        void *memb_ptr;         /* Pointer to the member */
+        void **memb_ptr2;       /* Pointer to that pointer */
+        asn_dec_rval_t rval = {0,0};
+
+        /*
+         * Compute the position of the member inside a structure,
+         * and also a type of containment (it may be contained
+         * as pointer or using inline inclusion).
+         */
+        if(elm->flags & ATF_POINTER) {
+            /* Member is a pointer to another structure */
+            memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+        } else {
+            /*
+             * A pointer to a pointer
+             * holding the start of the structure
+             */
+            memb_ptr = (char *)st + elm->memb_offset;
+            memb_ptr2 = &memb_ptr;
+        }
+
+        /* Set presence to be able to free it properly at any time */
+        (void)CHOICE_variant_set_presence(td, st, ctx->step + 1);
+
+        if(specs->ext_start >= 0 && specs->ext_start <= ctx->step) {
+            ssize_t got =
+                oer_open_type_get(opt_codec_ctx, elm->type,
+                                  elm->encoding_constraints.oer_constraints,
+                                  memb_ptr2, ptr, size);
+            if(got < 0) ASN__DECODE_FAILED;
+            if(got == 0) ASN__DECODE_STARVED;
+            rval.code = RC_OK;
+            rval.consumed = got;
+        } else {
+            rval = elm->type->op->oer_decoder(
+                opt_codec_ctx, elm->type,
+                elm->encoding_constraints.oer_constraints, memb_ptr2, ptr,
+                size);
+        }
+        rval.consumed += consumed_myself;
+        switch(rval.code) {
+        case RC_OK:
+            NEXT_PHASE(ctx);
+        case RC_WMORE:
+            break;
+        case RC_FAIL:
+            SET_PHASE(ctx, 3);  /* => 3 */
+        }
+        return rval;
+    }
+    case 2:
+        /* Already decoded everything */
+        RETURN(RC_OK);
+    case 3:
+        /* Failed to decode, after all */
+        RETURN(RC_FAIL);
+    }
+
+    RETURN(RC_FAIL);
+}
+
+/*
+ * X.696 (08/2015) #8.7 Encoding of tags
+ */
+static ssize_t
+oer_put_tag(ber_tlv_tag_t tag, asn_app_consume_bytes_f *cb, void *app_key) {
+    uint8_t tclass = BER_TAG_CLASS(tag);
+    ber_tlv_tag_t tval = BER_TAG_VALUE(tag);
+
+    if(tval < 0x3F) {
+        uint8_t b = (uint8_t)((tclass << 6) | tval);
+        if(cb(&b, 1, app_key) < 0) {
+            return -1;
+        }
+        return 1;
+    } else {
+        uint8_t buf[1 + 2 * sizeof(tval)];
+        uint8_t *b = &buf[sizeof(buf)-1]; /* Last addressable */
+        size_t encoded;
+        for(; ; tval >>= 7) {
+            if(tval >> 7) {
+                *b-- = 0x80 | (tval & 0x7f);
+            } else {
+                *b-- = tval & 0x7f;
+                break;
+            }
+        }
+        *b = (uint8_t)((tclass << 6) | 0x3F);
+        encoded = sizeof(buf) - (b - buf);
+        if(cb(b, encoded, app_key) < 0) {
+            return -1;
+        }
+        return encoded;
+    }
+
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+CHOICE_encode_oer(const asn_TYPE_descriptor_t *td,
+                  const asn_oer_constraints_t *constraints, const void *sptr,
+                  asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_TYPE_member_t *elm; /* CHOICE element */
+    unsigned present;
+    const void *memb_ptr;
+    ber_tlv_tag_t tag;
+    ssize_t tag_len;
+    asn_enc_rval_t er = {0, 0, 0};
+
+    (void)constraints;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("OER %s encoding as CHOICE", td->name);
+
+    present = CHOICE_variant_get_presence(td, sptr);
+    if(present == 0 || present > td->elements_count) {
+        ASN_DEBUG("CHOICE %s member is not selected", td->name);
+        ASN__ENCODE_FAILED;
+    }
+
+    elm = &td->elements[present-1];
+    if(elm->flags & ATF_POINTER) {
+        memb_ptr =
+            *(const void *const *)((const char *)sptr + elm->memb_offset);
+        if(memb_ptr == 0) {
+            /* Mandatory element absent */
+            ASN__ENCODE_FAILED;
+        }
+    } else {
+        memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+    }
+
+    tag = asn_TYPE_outmost_tag(elm->type, memb_ptr, elm->tag_mode, elm->tag);
+    if(tag == 0) {
+        ASN__ENCODE_FAILED;
+    }
+
+    tag_len = oer_put_tag(tag, cb, app_key);
+    if(tag_len < 0) {
+        ASN__ENCODE_FAILED;
+    }
+
+    if(specs->ext_start >= 0 && (unsigned)specs->ext_start <= (present-1)) {
+        ssize_t encoded = oer_open_type_put(elm->type,
+                               elm->encoding_constraints.oer_constraints,
+                               memb_ptr, cb, app_key);
+        if(encoded < 0) ASN__ENCODE_FAILED;
+        er.encoded = tag_len + encoded;
+    } else {
+        er = elm->type->op->oer_encoder(
+            elm->type, elm->encoding_constraints.oer_constraints, memb_ptr, cb,
+            app_key);
+        if(er.encoded >= 0) er.encoded += tag_len;
+    }
+
+    return er;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_print.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_print.c
new file mode 100644
index 000000000..1f7958cd3
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_print.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+
+int
+CHOICE_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+             asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+    unsigned present;
+
+    if(!sptr) return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+
+    /*
+     * Figure out which CHOICE element is encoded.
+     */
+    present = _fetch_present_idx(sptr, specs->pres_offset,specs->pres_size);
+
+    /*
+     * Print that element.
+     */
+    if(present > 0 && present <= td->elements_count) {
+        asn_TYPE_member_t *elm = &td->elements[present-1];
+        const void *memb_ptr;
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr = *(const void * const *)((const char *)sptr + elm->memb_offset);
+            if(!memb_ptr) return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+        }
+
+        /* Print member's name and stuff */
+        if(0) {
+            if(cb(elm->name, strlen(elm->name), app_key) < 0
+            || cb(": ", 2, app_key) < 0)
+                return -1;
+        }
+
+        return elm->type->op->print_struct(elm->type, memb_ptr, ilevel,
+                                           cb, app_key);
+    } else {
+        return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_rfill.c
new file mode 100644
index 000000000..925857ce8
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_rfill.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+
+asn_random_fill_result_t
+CHOICE_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                   const asn_encoding_constraints_t *constr,
+                   size_t max_length) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_random_fill_result_t res;
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    const asn_TYPE_member_t *elm;
+    unsigned present;
+    void *memb_ptr;    /* Pointer to the member */
+    void **memb_ptr2;  /* Pointer to that pointer */
+    void *st = *sptr;
+
+    if(max_length == 0) return result_skipped;
+
+    (void)constr;
+
+    if(st == NULL) {
+        st = CALLOC(1, specs->struct_size);
+        if(st == NULL) {
+            return result_failed;
+        }
+    }
+
+    present = asn_random_between(1, td->elements_count);
+    elm = &td->elements[present - 1];
+
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)st + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+
+    res = elm->type->op->random_fill(elm->type, memb_ptr2,
+                                    &elm->encoding_constraints, max_length);
+    _set_present_idx(st, specs->pres_offset, specs->pres_size, present);
+    if(res.code == ARFILL_OK) {
+        *sptr = st;
+    } else {
+        if(st == *sptr) {
+            ASN_STRUCT_RESET(*td, st);
+        } else {
+            ASN_STRUCT_FREE(*td, st);
+        }
+    }
+
+    return res;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_uper.c
new file mode 100644
index 000000000..17ab77cc9
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_uper.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+#include "uper_opentype.h"
+
+asn_dec_rval_t
+CHOICE_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, void **sptr,
+                   asn_per_data_t *pd) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_dec_rval_t rv;
+    const asn_per_constraint_t *ct;
+    asn_TYPE_member_t *elm;  /* CHOICE's element */
+    void *memb_ptr;
+    void **memb_ptr2;
+    void *st = *sptr;
+    int value;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(!st) {
+        st = *sptr = CALLOC(1, specs->struct_size);
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints) ct = &td->encoding_constraints.per_constraints->value;
+    else ct = 0;
+
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        value = per_get_few_bits(pd, 1);
+        if(value < 0) ASN__DECODE_STARVED;
+        if(value) ct = 0;  /* Not restricted */
+    }
+
+    if(ct && ct->range_bits >= 0) {
+        value = per_get_few_bits(pd, ct->range_bits);
+        if(value < 0) ASN__DECODE_STARVED;
+        ASN_DEBUG("CHOICE %s got index %d in range %d",
+                  td->name, value, ct->range_bits);
+        if(value > ct->upper_bound)
+            ASN__DECODE_FAILED;
+    } else {
+        if(specs->ext_start == -1)
+            ASN__DECODE_FAILED;
+        value = uper_get_nsnnwn(pd);
+        if(value < 0) ASN__DECODE_STARVED;
+        value += specs->ext_start;
+        if((unsigned)value >= td->elements_count)
+            ASN__DECODE_FAILED;
+    }
+
+    /* Adjust if canonical order is different from natural order */
+    if(specs->from_canonical_order) {
+        ASN_DEBUG("CHOICE presence from wire %d", value);
+        value = specs->from_canonical_order[value];
+        ASN_DEBUG("CHOICE presence index effective %d", value);
+    }
+
+    /* Set presence to be able to free it later */
+    _set_present_idx(st, specs->pres_offset, specs->pres_size, value + 1);
+
+    elm = &td->elements[value];
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+    } else {
+        memb_ptr = (char *)st + elm->memb_offset;
+        memb_ptr2 = &memb_ptr;
+    }
+    ASN_DEBUG("Discovered CHOICE %s encodes %s", td->name, elm->name);
+
+    if(ct && ct->range_bits >= 0) {
+        rv = elm->type->op->uper_decoder(opt_codec_ctx, elm->type,
+                                         elm->encoding_constraints.per_constraints,
+                                         memb_ptr2, pd);
+    } else {
+        rv = uper_open_type_get(opt_codec_ctx, elm->type,
+                                elm->encoding_constraints.per_constraints,
+                                memb_ptr2, pd);
+    }
+
+    if(rv.code != RC_OK)
+        ASN_DEBUG("Failed to decode %s in %s (CHOICE) %d",
+                  elm->name, td->name, rv.code);
+    return rv;
+}
+
+asn_enc_rval_t
+CHOICE_encode_uper(const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, const void *sptr,
+                   asn_per_outp_t *po) {
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_TYPE_member_t *elm;  /* CHOICE's element */
+    const asn_per_constraint_t *ct;
+    const void *memb_ptr;
+    unsigned present;
+    int present_enc;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Encoding %s as CHOICE", td->name);
+
+    if(constraints) ct = &constraints->value;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->value;
+    else ct = 0;
+
+    present = _fetch_present_idx(sptr, specs->pres_offset, specs->pres_size);
+
+    /*
+     * If the structure was not initialized properly, it cannot be encoded:
+     * can't deduce what to encode in the choice type.
+     */
+    if(present == 0 || present > td->elements_count)
+        ASN__ENCODE_FAILED;
+    else
+        present--;
+
+    ASN_DEBUG("Encoding %s CHOICE element %d", td->name, present);
+
+    /* Adjust if canonical order is different from natural order */
+    if(specs->to_canonical_order)
+        present_enc = specs->to_canonical_order[present];
+    else
+        present_enc = present;
+
+    if(ct && ct->range_bits >= 0) {
+        if(present_enc < ct->lower_bound
+        || present_enc > ct->upper_bound) {
+            if(ct->flags & APC_EXTENSIBLE) {
+                ASN_DEBUG(
+                    "CHOICE member %d (enc %d) is an extension (%"ASN_PRIdMAX"..%"ASN_PRIdMAX")",
+                    present, present_enc, ct->lower_bound, ct->upper_bound);
+                if(per_put_few_bits(po, 1, 1))
+                    ASN__ENCODE_FAILED;
+            } else {
+                ASN__ENCODE_FAILED;
+            }
+            ct = 0;
+        }
+    }
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        ASN_DEBUG("CHOICE member %d (enc %d) is not an extension (%"ASN_PRIdMAX"..%"ASN_PRIdMAX")",
+                  present, present_enc, ct->lower_bound, ct->upper_bound);
+        if(per_put_few_bits(po, 0, 1))
+            ASN__ENCODE_FAILED;
+    }
+
+
+    elm = &td->elements[present];
+    ASN_DEBUG("CHOICE member \"%s\" %d (as %d)", elm->name, present,
+              present_enc);
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        memb_ptr =
+            *(const void *const *)((const char *)sptr + elm->memb_offset);
+        if(!memb_ptr) ASN__ENCODE_FAILED;
+    } else {
+        memb_ptr = (const char *)sptr + elm->memb_offset;
+    }
+
+    if(ct && ct->range_bits >= 0) {
+        if(per_put_few_bits(po, present_enc, ct->range_bits))
+            ASN__ENCODE_FAILED;
+
+        return elm->type->op->uper_encoder(
+            elm->type, elm->encoding_constraints.per_constraints, memb_ptr, po);
+    } else {
+        asn_enc_rval_t rval = {0,0,0};
+        if(specs->ext_start == -1) ASN__ENCODE_FAILED;
+        if(uper_put_nsnnwn(po, present_enc - specs->ext_start))
+            ASN__ENCODE_FAILED;
+        if(uper_open_type_put(elm->type,
+                              elm->encoding_constraints.per_constraints,
+                              memb_ptr, po))
+            ASN__ENCODE_FAILED;
+        rval.encoded = 0;
+        ASN__ENCODED_OK(rval);
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_xer.c
new file mode 100644
index 000000000..2770994f6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_CHOICE_xer.c
@@ -0,0 +1,316 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_CHOICE.h"
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+#undef XER_ADVANCE
+#define XER_ADVANCE(num_bytes)                                    \
+    do {                                                          \
+        size_t num = num_bytes;                                   \
+        buf_ptr = (const void *)(((const char *)buf_ptr) + num);  \
+        size -= num;                                              \
+        consumed_myself += num;                                   \
+    } while(0)
+
+/*
+ * Decode the XER (XML) data.
+ */
+asn_dec_rval_t
+CHOICE_decode_xer(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td, void **struct_ptr,
+                  const char *opt_mname, const void *buf_ptr, size_t size) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_CHOICE_specifics_t *specs = (const asn_CHOICE_specifics_t *)td->specifics;
+    const char *xml_tag = opt_mname ? opt_mname : td->xml_tag;
+
+    /*
+     * Parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    asn_dec_rval_t rval;          /* Return value of a decoder */
+    ssize_t consumed_myself = 0;  /* Consumed bytes from ptr */
+    size_t edx;                   /* Element index */
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) RETURN(RC_FAIL);
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+    if(ctx->phase == 0 && !*xml_tag)
+        ctx->phase = 1;  /* Skip the outer tag checking phase */
+
+    /*
+     * Phases of XER/XML processing:
+     * Phase 0: Check that the opening tag matches our expectations.
+     * Phase 1: Processing body and reacting on closing tag.
+     * Phase 2: Processing inner type.
+     * Phase 3: Only waiting for closing tag.
+     * Phase 4: Skipping unknown extensions.
+     * Phase 5: PHASED OUT
+     */
+    for(edx = ctx->step; ctx->phase <= 4;) {
+        pxer_chunk_type_e ch_type;  /* XER chunk type */
+        ssize_t ch_size;            /* Chunk size */
+        xer_check_tag_e tcv;        /* Tag check value */
+        asn_TYPE_member_t *elm;
+
+        /*
+         * Go inside the member.
+         */
+        if(ctx->phase == 2) {
+            asn_dec_rval_t tmprval;
+            void *memb_ptr;    /* Pointer to the member */
+            void **memb_ptr2;  /* Pointer to that pointer */
+            unsigned old_present __attribute__((unused));
+
+            elm = &td->elements[edx];
+
+            if(elm->flags & ATF_POINTER) {
+                /* Member is a pointer to another structure */
+                memb_ptr2 = (void **)((char *)st
+                    + elm->memb_offset);
+            } else {
+                memb_ptr = (char *)st + elm->memb_offset;
+                memb_ptr2 = &memb_ptr;
+            }
+
+            /* Start/Continue decoding the inner member */
+            tmprval = elm->type->op->xer_decoder(opt_codec_ctx,
+                                                 elm->type, memb_ptr2,
+                                                 elm->name,
+                                                 buf_ptr, size);
+            XER_ADVANCE(tmprval.consumed);
+            ASN_DEBUG("XER/CHOICE: itdf: [%s] code=%d",
+                      elm->type->name, tmprval.code);
+            old_present = _fetch_present_idx(st,
+                                             specs->pres_offset,
+                                             specs->pres_size);
+            assert(old_present == 0 || old_present == edx + 1);
+            /* Record what we've got */
+            _set_present_idx(st,
+                             specs->pres_offset,
+                             specs->pres_size, edx + 1);
+            if(tmprval.code != RC_OK)
+                RETURN(tmprval.code);
+            ctx->phase = 3;
+            /* Fall through */
+        }
+
+        /* No need to wait for closing tag; special mode. */
+        if(ctx->phase == 3 && !*xml_tag) {
+            ctx->phase = 5;  /* Phase out */
+            RETURN(RC_OK);
+        }
+
+        /*
+         * Get the next part of the XML stream.
+         */
+        ch_size = xer_next_token(&ctx->context, buf_ptr, size, &ch_type);
+        if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+            switch(ch_type) {
+            case PXER_WMORE:
+                RETURN(RC_WMORE);
+            case PXER_COMMENT:  /* Got XML comment */
+            case PXER_TEXT:  /* Ignore free-standing text */
+                XER_ADVANCE(ch_size);  /* Skip silently */
+                continue;
+            case PXER_TAG:
+                break;  /* Check the rest down there */
+            }
+        }
+
+        tcv = xer_check_tag(buf_ptr, ch_size, xml_tag);
+        ASN_DEBUG("XER/CHOICE checked [%c%c%c%c] vs [%s], tcv=%d",
+                  ch_size>0?((const uint8_t *)buf_ptr)[0]:'?',
+                  ch_size>1?((const uint8_t *)buf_ptr)[1]:'?',
+                  ch_size>2?((const uint8_t *)buf_ptr)[2]:'?',
+                  ch_size>3?((const uint8_t *)buf_ptr)[3]:'?',
+                  xml_tag, tcv);
+
+        /* Skip the extensions section */
+        if(ctx->phase == 4) {
+            ASN_DEBUG("skip_unknown(%d, %ld)",
+                      tcv, (long)ctx->left);
+            switch(xer_skip_unknown(tcv, &ctx->left)) {
+            case -1:
+                ctx->phase = 5;
+                RETURN(RC_FAIL);
+            case 1:
+                ctx->phase = 3;
+                /* Fall through */
+            case 0:
+                XER_ADVANCE(ch_size);
+                continue;
+            case 2:
+                ctx->phase = 3;
+                break;
+            }
+        }
+
+        switch(tcv) {
+        case XCT_BOTH:
+            break;  /* No CHOICE? */
+        case XCT_CLOSING:
+            if(ctx->phase != 3)
+                break;
+            XER_ADVANCE(ch_size);
+            ctx->phase = 5;  /* Phase out */
+            RETURN(RC_OK);
+        case XCT_OPENING:
+            if(ctx->phase == 0) {
+                XER_ADVANCE(ch_size);
+                ctx->phase = 1;  /* Processing body phase */
+                continue;
+            }
+            /* Fall through */
+        case XCT_UNKNOWN_OP:
+        case XCT_UNKNOWN_BO:
+
+            if(ctx->phase != 1)
+                break;  /* Really unexpected */
+
+            /*
+             * Search which inner member corresponds to this tag.
+             */
+            for(edx = 0; edx < td->elements_count; edx++) {
+                elm = &td->elements[edx];
+                tcv = xer_check_tag(buf_ptr,ch_size,elm->name);
+                switch(tcv) {
+                case XCT_BOTH:
+                case XCT_OPENING:
+                    /*
+                     * Process this member.
+                     */
+                    ctx->step = edx;
+                    ctx->phase = 2;
+                    break;
+                case XCT_UNKNOWN_OP:
+                case XCT_UNKNOWN_BO:
+                    continue;
+                default:
+                    edx = td->elements_count;
+                    break;  /* Phase out */
+                }
+                break;
+            }
+            if(edx != td->elements_count)
+                continue;
+
+            /* It is expected extension */
+            if(specs->ext_start != -1) {
+                ASN_DEBUG("Got anticipated extension");
+                /*
+                 * Check for (XCT_BOTH or XCT_UNKNOWN_BO)
+                 * By using a mask. Only record a pure
+                 * <opening> tags.
+                 */
+                if(tcv & XCT_CLOSING) {
+                    /* Found </extension> without body */
+                    ctx->phase = 3;  /* Terminating */
+                } else {
+                    ctx->left = 1;
+                    ctx->phase = 4;  /* Skip ...'s */
+                }
+                XER_ADVANCE(ch_size);
+                continue;
+            }
+
+            /* Fall through */
+        default:
+            break;
+        }
+
+        ASN_DEBUG("Unexpected XML tag [%c%c%c%c] in CHOICE [%s]"
+                  " (ph=%d, tag=%s)",
+                  ch_size>0?((const uint8_t *)buf_ptr)[0]:'?',
+                  ch_size>1?((const uint8_t *)buf_ptr)[1]:'?',
+                  ch_size>2?((const uint8_t *)buf_ptr)[2]:'?',
+                  ch_size>3?((const uint8_t *)buf_ptr)[3]:'?',
+                  td->name, ctx->phase, xml_tag);
+        break;
+    }
+
+    ctx->phase = 5;  /* Phase out, just in case */
+    RETURN(RC_FAIL);
+}
+
+asn_enc_rval_t
+CHOICE_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+                  enum xer_encoder_flags_e flags, asn_app_consume_bytes_f *cb,
+                  void *app_key) {
+    const asn_CHOICE_specifics_t *specs =
+        (const asn_CHOICE_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    unsigned present = 0;
+
+    if(!sptr)
+        ASN__ENCODE_FAILED;
+
+    /*
+     * Figure out which CHOICE element is encoded.
+     */
+    present = _fetch_present_idx(sptr, specs->pres_offset,specs->pres_size);
+
+    if(present == 0 || present > td->elements_count) {
+        ASN__ENCODE_FAILED;
+    } else {
+        asn_enc_rval_t tmper = {0,0,0};
+        asn_TYPE_member_t *elm = &td->elements[present-1];
+        const void *memb_ptr = NULL;
+        const char *mname = elm->name;
+        unsigned int mlen = strlen(mname);
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr =
+                *(const void *const *)((const char *)sptr + elm->memb_offset);
+            if(!memb_ptr) ASN__ENCODE_FAILED;
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+        }
+
+        er.encoded = 0;
+
+        if(!(flags & XER_F_CANONICAL)) ASN__TEXT_INDENT(1, ilevel);
+        ASN__CALLBACK3("<", 1, mname, mlen, ">", 1);
+
+        tmper = elm->type->op->xer_encoder(elm->type, memb_ptr,
+                                           ilevel + 1, flags, cb, app_key);
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+
+        ASN__CALLBACK3("</", 2, mname, mlen, ">", 1);
+    }
+
+    if(!(flags & XER_F_CANONICAL)) ASN__TEXT_INDENT(1, ilevel - 1);
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE.c
new file mode 100644
index 000000000..d7c5401a5
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE.c
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+
+asn_TYPE_operation_t asn_OP_SEQUENCE = {
+    SEQUENCE_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    SEQUENCE_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    SEQUENCE_compare,
+    SEQUENCE_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    SEQUENCE_decode_ber,
+    SEQUENCE_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    SEQUENCE_decode_xer,
+    SEQUENCE_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    SEQUENCE_decode_jer,
+    SEQUENCE_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    SEQUENCE_decode_oer,
+    SEQUENCE_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    SEQUENCE_decode_uper,
+    SEQUENCE_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    SEQUENCE_decode_aper,
+    SEQUENCE_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    SEQUENCE_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+
+void
+SEQUENCE_free(const asn_TYPE_descriptor_t *td, void *sptr,
+              enum asn_struct_free_method method) {
+    size_t edx;
+    const asn_SEQUENCE_specifics_t *specs;
+    asn_struct_ctx_t *ctx; /* Decoder context */
+
+	if(!td || !sptr)
+		return;
+
+    specs = (const asn_SEQUENCE_specifics_t *)td->specifics;
+
+	ASN_DEBUG("Freeing %s as SEQUENCE", td->name);
+
+	for(edx = 0; edx < td->elements_count; edx++) {
+		asn_TYPE_member_t *elm = &td->elements[edx];
+		void *memb_ptr;
+		if(elm->flags & ATF_POINTER) {
+			memb_ptr = *(void **)((char *)sptr + elm->memb_offset);
+			if(memb_ptr)
+				ASN_STRUCT_FREE(*elm->type, memb_ptr);
+		} else {
+			memb_ptr = (void *)((char *)sptr + elm->memb_offset);
+			ASN_STRUCT_FREE_CONTENTS_ONLY(*elm->type, memb_ptr);
+		}
+	}
+
+	/* Clean parsing context */
+	ctx = (asn_struct_ctx_t *)((char *)sptr + specs->ctx_offset);
+	FREEMEM(ctx->ptr);
+
+    switch(method) {
+    case ASFM_FREE_EVERYTHING:
+        FREEMEM(sptr);
+        break;
+    case ASFM_FREE_UNDERLYING:
+        break;
+    case ASFM_FREE_UNDERLYING_AND_RESET:
+        memset(
+            sptr, 0,
+            ((const asn_SEQUENCE_specifics_t *)(td->specifics))->struct_size);
+        break;
+    }
+}
+
+int
+SEQUENCE_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
+                    asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+    size_t edx;
+
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+
+	/*
+	 * Iterate over structure members and check their validity.
+	 */
+	for(edx = 0; edx < td->elements_count; edx++) {
+		asn_TYPE_member_t *elm = &td->elements[edx];
+		const void *memb_ptr;
+		asn_constr_check_f *constr;
+		int ret;
+
+		if(elm->flags & ATF_POINTER) {
+			memb_ptr = *(const void * const *)((const char *)sptr + elm->memb_offset);
+			if(!memb_ptr) {
+				if(elm->optional)
+					continue;
+				ASN__CTFAIL(app_key, td, sptr,
+				"%s: mandatory element %s absent (%s:%d)",
+				td->name, elm->name, __FILE__, __LINE__);
+				return -1;
+			}
+		} else {
+			memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+		}
+
+		constr = elm->encoding_constraints.general_constraints;
+		if(!constr)
+			constr = elm->type->encoding_constraints.general_constraints;
+
+		ret = constr(elm->type, memb_ptr, ctfailcb, app_key);
+		if(ret) return ret;
+	}
+
+	return 0;
+}
+
+int
+SEQUENCE_compare(const asn_TYPE_descriptor_t *td, const void *aptr,
+                 const void *bptr) {
+    size_t edx;
+
+	for(edx = 0; edx < td->elements_count; edx++) {
+		asn_TYPE_member_t *elm = &td->elements[edx];
+		const void *amemb;
+		const void *bmemb;
+        int ret;
+
+		if(elm->flags & ATF_POINTER) {
+            amemb =
+                *(const void *const *)((const char *)aptr + elm->memb_offset);
+            bmemb =
+                *(const void *const *)((const char *)bptr + elm->memb_offset);
+            if(!amemb) {
+                if(!bmemb) continue;
+                if(elm->default_value_cmp
+                   && elm->default_value_cmp(bmemb) == 0) {
+                    /* A is absent, but B is present and equal to DEFAULT */
+                    continue;
+                }
+                return -1;
+            } else if(!bmemb) {
+                if(elm->default_value_cmp
+                   && elm->default_value_cmp(amemb) == 0) {
+                    /* B is absent, but A is present and equal to DEFAULT */
+                    continue;
+                }
+                return 1;
+            }
+		} else {
+            amemb = (const void *)((const char *)aptr + elm->memb_offset);
+            bmemb = (const void *)((const char *)bptr + elm->memb_offset);
+		}
+
+        ret = elm->type->op->compare_struct(elm->type, amemb, bmemb);
+        if(ret != 0) return ret;
+    }
+
+    return 0;
+}
+
+int
+SEQUENCE_copy(const asn_TYPE_descriptor_t *td, void **aptr,
+                 const void *bptr) {
+    if(!td) return -1;
+
+    const asn_SEQUENCE_specifics_t *specs =
+        (const asn_SEQUENCE_specifics_t *)td->specifics;
+    size_t edx;
+    void *st = *aptr;        /* Target structure */
+
+    if(!bptr) {
+        if(st) {
+            SEQUENCE_free(td, st, 0);
+            *aptr = 0;
+        }
+        return 0;
+    }
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *aptr = CALLOC(1, specs->struct_size);
+        if(st == 0) return -1;
+    }
+
+	for(edx = 0; edx < td->elements_count; edx++) {
+		asn_TYPE_member_t *elm = &td->elements[edx];
+		void *amemb;
+		void **amembp;
+		const void *bmemb;
+        int ret;
+
+        if(elm->flags & ATF_POINTER) {
+            /* Member is a pointer to another structure */
+            amembp = (void **)((char *)st + elm->memb_offset);
+            bmemb = *(const void* const*)((const char*)bptr + elm->memb_offset);
+        } else {
+            amemb = (char *)st + elm->memb_offset;
+            amembp = &amemb;
+            bmemb = (const void*)((const char*)bptr + elm->memb_offset);
+        }
+
+        ret = elm->type->op->copy_struct(elm->type, amembp, bmemb);
+        if(ret != 0) return ret;
+    }
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE.h /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE.h
new file mode 100644
index 000000000..8073eb271
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE.h
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_CONSTR_SEQUENCE_H_
+#define	_CONSTR_SEQUENCE_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct asn_SEQUENCE_specifics_s {
+	/*
+	 * Target structure description.
+	 */
+	unsigned struct_size;	/* Size of the target structure. */
+	unsigned ctx_offset;	/* Offset of the asn_struct_ctx_t member */
+
+	/*
+	 * Tags to members mapping table (sorted).
+	 */
+	const asn_TYPE_tag2member_t *tag2el;
+	unsigned tag2el_count;
+
+	/*
+	 * Optional members of the extensions root (roms) or additions (aoms).
+	 * Meaningful for PER.
+	 */
+	const int *oms;         /* Optional MemberS */
+	unsigned roms_count;    /* Root optional members count */
+	unsigned aoms_count;    /* Additions optional members count */
+
+	/*
+	 * Description of an extensions group.
+	 * Root components are clustered at the beginning of the structure,
+	 * whereas extensions are clustered at the end. -1 means not extensible.
+	 */
+	signed first_extension;       /* First extension addition */
+} asn_SEQUENCE_specifics_t;
+
+
+/*
+ * A set specialized functions dealing with the SEQUENCE type.
+ */
+asn_struct_free_f SEQUENCE_free;
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f SEQUENCE_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f SEQUENCE_compare;
+asn_struct_copy_f SEQUENCE_copy;
+
+asn_constr_check_f SEQUENCE_constraint;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+ber_type_decoder_f SEQUENCE_decode_ber;
+der_type_encoder_f SEQUENCE_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f SEQUENCE_decode_xer;
+xer_type_encoder_f SEQUENCE_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f SEQUENCE_decode_jer;
+jer_type_encoder_f SEQUENCE_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f SEQUENCE_decode_oer;
+oer_type_encoder_f SEQUENCE_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f SEQUENCE_decode_uper;
+per_type_encoder_f SEQUENCE_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f SEQUENCE_decode_aper;
+per_type_encoder_f SEQUENCE_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f SEQUENCE_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+extern asn_TYPE_operation_t asn_OP_SEQUENCE;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _CONSTR_SEQUENCE_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF.c
new file mode 100644
index 000000000..679086fa8
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF.c
@@ -0,0 +1,95 @@
+/*-
+ * Copyright (c) 2003, 2004, 2006 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE_OF.h"
+#include "asn_SEQUENCE_OF.h"
+
+asn_TYPE_operation_t asn_OP_SEQUENCE_OF = {
+    SEQUENCE_OF_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    SEQUENCE_OF_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    SEQUENCE_OF_compare,
+    SEQUENCE_OF_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    SEQUENCE_OF_decode_ber,
+    SEQUENCE_OF_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    SEQUENCE_OF_decode_xer,
+    SEQUENCE_OF_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    SEQUENCE_OF_decode_jer,
+    SEQUENCE_OF_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    SEQUENCE_OF_decode_oer,  /* Same as SET OF decoder. */
+    SEQUENCE_OF_encode_oer,  /* Same as SET OF encoder */
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    SEQUENCE_OF_decode_uper,  /* Same as SET OF decoder */
+    SEQUENCE_OF_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    SEQUENCE_OF_decode_aper,
+    SEQUENCE_OF_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    SEQUENCE_OF_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+
+int
+SEQUENCE_OF_compare(const asn_TYPE_descriptor_t *td, const void *aptr,
+               const void *bptr) {
+    const asn_anonymous_sequence_ *a = _A_CSEQUENCE_FROM_VOID(aptr);
+    const asn_anonymous_sequence_ *b = _A_CSEQUENCE_FROM_VOID(bptr);
+    ssize_t idx;
+
+    if(a && b) {
+        ssize_t common_length = (a->count < b->count ? a->count : b->count);
+        for(idx = 0; idx < common_length; idx++) {
+            int ret = td->elements->type->op->compare_struct(
+                td->elements->type, a->array[idx], b->array[idx]);
+            if(ret) return ret;
+        }
+
+        if(idx < b->count) /* more elements in b */
+            return -1;    /* a is shorter, so put it first */
+        if(idx < a->count) return 1;
+
+    } else if(!a) {
+        return -1;
+    } else if(!b) {
+        return 1;
+    }
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF.h /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF.h
new file mode 100644
index 000000000..6a363d9c5
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF.h
@@ -0,0 +1,69 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_CONSTR_SEQUENCE_OF_H_
+#define	_CONSTR_SEQUENCE_OF_H_
+
+#include "asn_application.h"
+#include "constr_SET_OF.h"		/* Implemented using SET OF */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * A set specialized functions dealing with the SEQUENCE OF type.
+ * Generally implemented using SET OF.
+ */
+#define SEQUENCE_OF_free SET_OF_free
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+#define SEQUENCE_OF_print SET_OF_print
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f SEQUENCE_OF_compare;
+#define SEQUENCE_OF_copy SET_OF_copy
+
+#define SEQUENCE_OF_constraint SET_OF_constraint
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#define SEQUENCE_OF_decode_ber SET_OF_decode_ber
+der_type_encoder_f SEQUENCE_OF_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#define SEQUENCE_OF_decode_xer SET_OF_decode_xer
+xer_type_encoder_f SEQUENCE_OF_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+#define SEQUENCE_OF_decode_jer SET_OF_decode_jer
+jer_type_encoder_f SEQUENCE_OF_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+#define SEQUENCE_OF_decode_oer SET_OF_decode_oer
+#define SEQUENCE_OF_encode_oer SET_OF_encode_oer
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+#define SEQUENCE_OF_decode_uper SET_OF_decode_uper
+per_type_encoder_f SEQUENCE_OF_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+#define SEQUENCE_OF_decode_aper SET_OF_decode_aper
+per_type_encoder_f SEQUENCE_OF_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+#define SEQUENCE_OF_random_fill SET_OF_random_fill
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+extern asn_TYPE_operation_t asn_OP_SEQUENCE_OF;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _CONSTR_SET_OF_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_aper.c
new file mode 100644
index 000000000..7d685deb4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_aper.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE_OF.h"
+#include "asn_SEQUENCE_OF.h"
+
+asn_enc_rval_t
+SEQUENCE_OF_encode_aper(const asn_TYPE_descriptor_t *td,
+                        const asn_per_constraints_t *constraints,
+                        const void *sptr, asn_per_outp_t *po) {
+    const asn_anonymous_sequence_ *list;
+    const asn_per_constraint_t *ct;
+    asn_enc_rval_t er = {0,0,0};
+    asn_TYPE_member_t *elm = td->elements;
+    int seq;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+    list = _A_CSEQUENCE_FROM_VOID(sptr);
+
+    er.encoded = 0;
+
+    ASN_DEBUG("Encoding %s as SEQUENCE OF size (%d) using ALIGNED PER", td->name, list->count);
+
+    if(constraints) ct = &constraints->size;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->size;
+    else ct = 0;
+
+    /* If extensible constraint, check if size is in root */
+    if(ct) {
+        int not_in_root = (list->count < ct->lower_bound
+                || list->count > ct->upper_bound);
+        ASN_DEBUG("lb %lld ub %lld %s",
+                  (long long int)ct->lower_bound,
+                  (long long int)ct->upper_bound,
+                  ct->flags & APC_EXTENSIBLE ? "ext" : "fix");
+        if(ct->flags & APC_EXTENSIBLE) {
+            /* Declare whether size is in extension root */
+            if(per_put_few_bits(po, not_in_root, 1))
+                ASN__ENCODE_FAILED;
+            if(not_in_root) ct = 0;
+        } else if(not_in_root && ct->effective_bits >= 0)
+            ASN__ENCODE_FAILED;
+    }
+
+    if(ct && ct->effective_bits >= 0) {
+        /* X.691, #19.5: No length determinant */
+/*
+        if(per_put_few_bits(po, list->count - ct->lower_bound,
+                            ct->effective_bits))
+            ASN__ENCODE_FAILED;
+*/
+        if (ct->lower_bound == ct->upper_bound && ct->upper_bound < 65536) {
+            /* No length determinant */
+    } else if (aper_put_length(po, ct->lower_bound, ct->upper_bound, list->count - ct->lower_bound, 0) < 0)
+            ASN__ENCODE_FAILED;
+    }
+
+    for(seq = -1; seq < list->count;) {
+        ssize_t mayEncode;
+        int need_eom = 0;
+        if(seq < 0) seq = 0;
+        if(ct && ct->effective_bits >= 0) {
+            mayEncode = list->count;
+        } else {
+            mayEncode = aper_put_length(po, -1, -1, list->count - seq, &need_eom);
+            if(mayEncode < 0) ASN__ENCODE_FAILED;
+        }
+
+        while(mayEncode--) {
+            void *memb_ptr = list->array[seq++];
+            if(!memb_ptr) ASN__ENCODE_FAILED;
+            er = elm->type->op->aper_encoder(elm->type,
+                                             elm->encoding_constraints.per_constraints,
+                                             memb_ptr, po);
+            if(er.encoded == -1)
+                ASN__ENCODE_FAILED;
+        }
+
+        if(need_eom && (aper_put_length(po, -1, -1, 0, NULL) < 0))
+            ASN__ENCODE_FAILED;  /* End of Message length */
+    }
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_ber.c
new file mode 100644
index 000000000..b718571fd
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_ber.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE_OF.h"
+#include "asn_SEQUENCE_OF.h"
+
+/*
+ * The DER encoder of the SEQUENCE OF type.
+ */
+asn_enc_rval_t
+SEQUENCE_OF_encode_der(const asn_TYPE_descriptor_t *td, const void *ptr,
+                       int tag_mode, ber_tlv_tag_t tag,
+                       asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_TYPE_member_t *elm = td->elements;
+    const asn_anonymous_sequence_ *list = _A_CSEQUENCE_FROM_VOID(ptr);
+    size_t computed_size = 0;
+    ssize_t encoding_size = 0;
+    asn_enc_rval_t erval = {0,0,0};
+    int edx;
+
+    ASN_DEBUG("Estimating size of SEQUENCE OF %s", td->name);
+
+    /*
+     * Gather the length of the underlying members sequence.
+     */
+    for(edx = 0; edx < list->count; edx++) {
+        void *memb_ptr = list->array[edx];
+        if(!memb_ptr) continue;
+        erval = elm->type->op->der_encoder(elm->type, memb_ptr,
+                                           0, elm->tag,
+                                           0, 0);
+        if(erval.encoded == -1)
+            return erval;
+        computed_size += erval.encoded;
+    }
+
+    /*
+     * Encode the TLV for the sequence itself.
+     */
+    encoding_size = der_write_tags(td, computed_size, tag_mode, 1, tag,
+                                   cb, app_key);
+    if(encoding_size == -1) {
+        erval.encoded = -1;
+        erval.failed_type = td;
+        erval.structure_ptr = ptr;
+        return erval;
+    }
+
+    computed_size += encoding_size;
+    if(!cb) {
+        erval.encoded = computed_size;
+        ASN__ENCODED_OK(erval);
+    }
+
+    ASN_DEBUG("Encoding members of SEQUENCE OF %s", td->name);
+
+    /*
+     * Encode all members.
+     */
+    for(edx = 0; edx < list->count; edx++) {
+        void *memb_ptr = list->array[edx];
+        if(!memb_ptr) continue;
+        erval = elm->type->op->der_encoder(elm->type, memb_ptr,
+                                           0, elm->tag,
+                                           cb, app_key);
+        if(erval.encoded == -1)
+            return erval;
+        encoding_size += erval.encoded;
+    }
+
+    if(computed_size != (size_t)encoding_size) {
+        /*
+         * Encoded size is not equal to the computed size.
+         */
+        erval.encoded = -1;
+        erval.failed_type = td;
+        erval.structure_ptr = ptr;
+    } else {
+        erval.encoded = computed_size;
+        erval.structure_ptr = 0;
+        erval.failed_type = 0;
+    }
+
+    return erval;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_jer.c
new file mode 100644
index 000000000..abb52fbc7
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_jer.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE_OF.h"
+#include "asn_SEQUENCE_OF.h"
+
+asn_enc_rval_t
+SEQUENCE_OF_encode_jer(const asn_TYPE_descriptor_t *td, const asn_jer_constraints_t *constraints,
+                       const void *sptr, int ilevel, enum jer_encoder_flags_e flags,
+                       asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0,0,0};
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm = td->elements;
+    const asn_anonymous_sequence_ *list = _A_CSEQUENCE_FROM_VOID(sptr);
+    int jmin = (flags & JER_F_MINIFIED);
+    int i;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+    ASN__CALLBACK("[", 1);
+
+    for(i = 0; i < list->count; i++) {
+        asn_enc_rval_t tmper = {0,0,0};
+        void *memb_ptr = list->array[i];
+        if(!memb_ptr) continue;
+
+        if(!jmin) ASN__TEXT_INDENT(1, ilevel + 1);
+        tmper = elm->type->op->jer_encoder(elm->type,
+                                           elm->encoding_constraints.jer_constraints,
+                                           memb_ptr, ilevel + 1,
+                                           flags, cb, app_key);
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+        if(tmper.encoded == 0 && specs->as_XMLValueList) {
+            const char *name = elm->type->xml_tag;
+            size_t len = strlen(name);
+            if(!jmin) ASN__TEXT_INDENT(1, ilevel + 1);
+            ASN__CALLBACK3("\"", 1, name, len, "\"", 1);
+        }
+
+        if (i != list->count - 1) {
+          ASN__CALLBACK(",", 1);
+        }
+    }
+
+    if(!jmin) ASN__TEXT_INDENT(1, ilevel);
+    ASN__CALLBACK("]", 1);
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_uper.c
new file mode 100644
index 000000000..800843001
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_uper.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE_OF.h"
+#include "asn_SEQUENCE_OF.h"
+
+asn_enc_rval_t
+SEQUENCE_OF_encode_uper(const asn_TYPE_descriptor_t *td,
+                        const asn_per_constraints_t *constraints,
+                        const void *sptr, asn_per_outp_t *po) {
+    const asn_anonymous_sequence_ *list;
+	const asn_per_constraint_t *ct;
+	asn_enc_rval_t er = {0,0,0};
+	const asn_TYPE_member_t *elm = td->elements;
+	size_t encoded_edx;
+
+	if(!sptr) ASN__ENCODE_FAILED;
+    list = _A_CSEQUENCE_FROM_VOID(sptr);
+
+    er.encoded = 0;
+
+	ASN_DEBUG("Encoding %s as SEQUENCE OF (%d)", td->name, list->count);
+
+    if(constraints) ct = &constraints->size;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->size;
+    else ct = 0;
+
+    /* If extensible constraint, check if size is in root */
+    if(ct) {
+        int not_in_root =
+            (list->count < ct->lower_bound || list->count > ct->upper_bound);
+        ASN_DEBUG("lb %"ASN_PRIdMAX" ub %"ASN_PRIdMAX" %s", ct->lower_bound, ct->upper_bound,
+                  ct->flags & APC_EXTENSIBLE ? "ext" : "fix");
+        if(ct->flags & APC_EXTENSIBLE) {
+            /* Declare whether size is in extension root */
+            if(per_put_few_bits(po, not_in_root, 1)) ASN__ENCODE_FAILED;
+            if(not_in_root) ct = 0;
+        } else if(not_in_root && ct->effective_bits >= 0) {
+            ASN__ENCODE_FAILED;
+        }
+
+    }
+
+    if(ct && ct->effective_bits >= 0) {
+        /* X.691, #19.5: No length determinant */
+        if(per_put_few_bits(po, list->count - ct->lower_bound,
+                            ct->effective_bits))
+            ASN__ENCODE_FAILED;
+    } else if(list->count == 0) {
+        /* When the list is empty add only the length determinant
+         * X.691, #20.6 and #11.9.4.1
+         */
+        if (uper_put_length(po, 0, 0)) {
+            ASN__ENCODE_FAILED;
+        }
+        ASN__ENCODED_OK(er);
+    }
+
+    for(encoded_edx = 0; (ssize_t)encoded_edx < list->count;) {
+        ssize_t may_encode;
+        size_t edx;
+        int need_eom = 0;
+
+        if(ct && ct->effective_bits >= 0) {
+            may_encode = list->count;
+        } else {
+            may_encode =
+                uper_put_length(po, list->count - encoded_edx, &need_eom);
+            if(may_encode < 0) ASN__ENCODE_FAILED;
+        }
+
+        for(edx = encoded_edx; edx < encoded_edx + may_encode; edx++) {
+            void *memb_ptr = list->array[edx];
+            if(!memb_ptr) ASN__ENCODE_FAILED;
+            er = elm->type->op->uper_encoder(
+                elm->type, elm->encoding_constraints.per_constraints, memb_ptr,
+                po);
+            if(er.encoded == -1) ASN__ENCODE_FAILED;
+        }
+
+        if(need_eom && uper_put_length(po, 0, 0))
+            ASN__ENCODE_FAILED; /* End of Message length */
+
+        encoded_edx += may_encode;
+    }
+
+	ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_xer.c
new file mode 100644
index 000000000..ccd6bfb28
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_OF_xer.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE_OF.h"
+#include "asn_SEQUENCE_OF.h"
+
+asn_enc_rval_t
+SEQUENCE_OF_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                       int ilevel, enum xer_encoder_flags_e flags,
+                       asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0,0,0};
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm = td->elements;
+    const asn_anonymous_sequence_ *list = _A_CSEQUENCE_FROM_VOID(sptr);
+    const char *mname = specs->as_XMLValueList
+                            ? 0
+                            : ((*elm->name) ? elm->name : elm->type->xml_tag);
+    size_t mlen = mname ? strlen(mname) : 0;
+    int xcan = (flags & XER_F_CANONICAL);
+    int i;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    for(i = 0; i < list->count; i++) {
+        asn_enc_rval_t tmper = {0,0,0};
+        void *memb_ptr = list->array[i];
+        if(!memb_ptr) continue;
+
+        if(mname) {
+            if(!xcan) ASN__TEXT_INDENT(1, ilevel);
+            ASN__CALLBACK3("<", 1, mname, mlen, ">", 1);
+        }
+
+        tmper = elm->type->op->xer_encoder(elm->type, memb_ptr, ilevel + 1,
+                                           flags, cb, app_key);
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+        if(tmper.encoded == 0 && specs->as_XMLValueList) {
+            const char *name = elm->type->xml_tag;
+            size_t len = strlen(name);
+            if(!xcan) ASN__TEXT_INDENT(1, ilevel + 1);
+            ASN__CALLBACK3("<", 1, name, len, "/>", 2);
+        }
+
+        if(mname) {
+            ASN__CALLBACK3("</", 2, mname, mlen, ">", 1);
+        }
+    }
+
+    if(!xcan) ASN__TEXT_INDENT(1, ilevel - 1);
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_aper.c
new file mode 100644
index 000000000..c57eff6fc
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_aper.c
@@ -0,0 +1,457 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+#include "OPEN_TYPE.h"
+#include "aper_opentype.h"
+
+/*
+ * Check whether we are inside the extensions group.
+ */
+#define IN_EXTENSION_GROUP(specs, memb_idx)                \
+    ((specs)->first_extension >= 0                         \
+     && (unsigned)(specs)->first_extension <= (memb_idx))
+
+asn_dec_rval_t
+SEQUENCE_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td,
+                     const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+    const asn_SEQUENCE_specifics_t *specs = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    void *st = *sptr;  /* Target structure. */
+    int extpresent;    /* Extension additions are present */
+    uint8_t *opres;    /* Presence of optional root members */
+    asn_per_data_t opmd;
+    asn_dec_rval_t rv;
+    size_t edx;
+
+    (void)constraints;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    if(!st) {
+        st = *sptr = CALLOC(1, specs->struct_size);
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    ASN_DEBUG("Decoding %s as SEQUENCE (APER)", td->name);
+
+    /* Handle extensions */
+    if(specs->first_extension < 0) {
+        extpresent = 0;
+    } else {
+        extpresent = per_get_few_bits(pd, 1);
+        if(extpresent < 0) ASN__DECODE_STARVED;
+    }
+
+    /* Prepare a place and read-in the presence bitmap */
+    memset(&opmd, 0, sizeof(opmd));
+    if(specs->roms_count) {
+        opres = (uint8_t *)MALLOC(((specs->roms_count + 7) >> 3) + 1);
+        if(!opres) ASN__DECODE_FAILED;
+        /* Get the presence map */
+        if(per_get_many_bits(pd, opres, 0, specs->roms_count)) {
+            FREEMEM(opres);
+            ASN__DECODE_STARVED;
+        }
+        opmd.buffer = opres;
+        opmd.nbits = specs->roms_count;
+        ASN_DEBUG("Read in presence bitmap for %s of %d bits (%x..)",
+                  td->name, specs->roms_count, *opres);
+    } else {
+        opres = 0;
+    }
+
+    /*
+     * Get the sequence ROOT elements.
+     */
+    for(edx = 0; edx < td->elements_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        void *memb_ptr;    /* Pointer to the member */
+        void **memb_ptr2;  /* Pointer to that pointer */
+#if 0
+        int padding;
+#endif
+
+        if(IN_EXTENSION_GROUP(specs, edx))
+            continue;
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+        } else {
+            memb_ptr = (char *)st + elm->memb_offset;
+            memb_ptr2 = &memb_ptr;
+        }
+#if 0
+        /* Get Padding */
+        padding = (8 - (pd->moved % 8)) % 8;
+        if(padding > 0)
+            ASN_DEBUG("For element %s,offset= %ld Padding bits = %d", td->name, pd->moved, padding);
+#if 0 /* old way of removing padding */
+        per_get_few_bits(pd, padding);
+#else /* Experimental fix proposed by @mhanna123 */
+        if(edx != (td->elements_count-1))
+            per_get_few_bits(pd, padding);
+        else {
+            if(specs->roms_count && (padding > 0))
+                ASN_DEBUG(">>>>> not skipping padding of %d bits for element:%ld out of %d", padding, edx, td->elements_count);
+            else
+                per_get_few_bits(pd, padding);
+        }
+#endif /* dealing with padding */
+#endif
+        /* Deal with optionality */
+        if(elm->optional) {
+            int present = per_get_few_bits(&opmd, 1);
+            ASN_DEBUG("Member %s->%s is optional, p=%d (%d->%d)",
+                      td->name, elm->name, present,
+                      (int)opmd.nboff, (int)opmd.nbits);
+            if(present == 0) {
+                /* This element is not present */
+                if(elm->default_value_set) {
+                    /* Fill-in DEFAULT */
+                    if(elm->default_value_set(memb_ptr2)) {
+                        FREEMEM(opres);
+                        ASN__DECODE_FAILED;
+                    }
+                    ASN_DEBUG("Filled-in default");
+                }
+                /* The member is just not present */
+                continue;
+            }
+            /* Fall through */
+        }
+
+        /* Fetch the member from the stream */
+        ASN_DEBUG("Decoding member \"%s\" in %s", elm->name, td->name);
+
+        if(elm->flags & ATF_OPEN_TYPE) {
+            if (OPEN_TYPE_aper_is_unknown_type(td, st, elm)) {
+                rv = OPEN_TYPE_aper_unknown_type_discard_bytes(pd);
+                FREEMEM(opres);
+                return rv;
+            }
+            rv = OPEN_TYPE_aper_get(opt_codec_ctx, td, st, elm, pd);
+        } else {
+            rv = elm->type->op->aper_decoder(opt_codec_ctx, elm->type,
+                                             elm->encoding_constraints.per_constraints,
+                                             memb_ptr2, pd);
+        }
+        if(rv.code != RC_OK) {
+            ASN_DEBUG("Failed decode %s in %s",
+                      elm->name, td->name);
+            FREEMEM(opres);
+            return rv;
+        }
+    }
+
+    /* Optionality map is not needed anymore */
+    FREEMEM(opres);
+
+    /*
+     * Deal with extensions.
+     */
+    if(extpresent) {
+        ssize_t bmlength;
+        uint8_t *epres;  /* Presence of extension members */
+        asn_per_data_t epmd;
+
+        bmlength = aper_get_nslength(pd);
+        if(bmlength < 0) ASN__DECODE_STARVED;
+
+        ASN_DEBUG("Extensions %" ASN_PRI_SSIZE " present in %s", bmlength, td->name);
+
+        epres = (uint8_t *)MALLOC((bmlength + 15) >> 3);
+        if(!epres) ASN__DECODE_STARVED;
+
+        /* Get the extensions map */
+        if(per_get_many_bits(pd, epres, 0, bmlength))
+            ASN__DECODE_STARVED;
+
+        memset(&epmd, 0, sizeof(epmd));
+        epmd.buffer = epres;
+        epmd.nbits = bmlength;
+        ASN_DEBUG("Read in extensions bitmap for %s of %zd bits (%x..)",
+                  td->name, bmlength, *epres);
+
+        /* Deal with padding */
+        if (aper_get_align(pd) < 0)
+            ASN__DECODE_STARVED;
+
+        /* Go over extensions and read them in */
+        for(edx = specs->first_extension; edx < td->elements_count; edx++) {
+            asn_TYPE_member_t *elm = &td->elements[edx];
+            void *memb_ptr;    /* Pointer to the member */
+            void **memb_ptr2;  /* Pointer to that pointer */
+            int present;
+
+            if(!IN_EXTENSION_GROUP(specs, edx)) {
+                ASN_DEBUG("%zu is not extension", edx);
+                continue;
+            }
+
+            /* Fetch the pointer to this member */
+            if(elm->flags & ATF_POINTER) {
+                memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+            } else {
+                memb_ptr = (void *)((char *)st + elm->memb_offset);
+                memb_ptr2 = &memb_ptr;
+            }
+
+            present = per_get_few_bits(&epmd, 1);
+            if(present <= 0) {
+                if(present < 0) break;  /* No more extensions */
+                continue;
+            }
+
+            ASN_DEBUG("Decoding member %s in %s %p", elm->name, td->name, *memb_ptr2);
+            rv = aper_open_type_get(opt_codec_ctx, elm->type,
+                                    elm->encoding_constraints.per_constraints,
+                                    memb_ptr2, pd);
+            if(rv.code != RC_OK) {
+                FREEMEM(epres);
+                return rv;
+            }
+        }
+
+        /* Skip over overflow extensions which aren't present
+         * in this system's version of the protocol */
+        for(;;) {
+            ASN_DEBUG("Getting overflow extensions");
+            switch(per_get_few_bits(&epmd, 1)) {
+            case -1:
+                break;
+            case 0:
+                continue;
+            default:
+                if(aper_open_type_skip(opt_codec_ctx, pd)) {
+                    FREEMEM(epres);
+                    ASN__DECODE_STARVED;
+                }
+            }
+            break;
+        }
+
+        FREEMEM(epres);
+    }
+
+    /* Fill DEFAULT members in extensions */
+    for(edx = specs->roms_count; edx < specs->roms_count
+            + specs->aoms_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        void **memb_ptr2;  /* Pointer to member pointer */
+
+        if(!elm->default_value_set) continue;
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+            if(*memb_ptr2) continue;
+        } else {
+            continue;  /* Extensions are all optionals */
+        }
+
+        /* Set default value */
+        if(elm->default_value_set(memb_ptr2)) {
+            ASN__DECODE_FAILED;
+        }
+    }
+
+    rv.consumed = 0;
+    rv.code = RC_OK;
+    return rv;
+}
+
+static int
+SEQUENCE_handle_extensions_aper(const asn_TYPE_descriptor_t *td,
+                                const void *sptr,
+                                asn_per_outp_t *po1, asn_per_outp_t *po2) {
+    const asn_SEQUENCE_specifics_t *specs
+        = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    int exts_present = 0;
+    int exts_count = 0;
+    size_t edx;
+
+    if(specs->first_extension < 0) {
+        return 0;
+    }
+
+    /* Find out which extensions are present */
+    for(edx = specs->first_extension; edx < td->elements_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        const void *memb_ptr;           /* Pointer to the member */
+        const void * const *memb_ptr2;  /* Pointer to that pointer */
+        int present;
+
+        if(!IN_EXTENSION_GROUP(specs, edx)) {
+            ASN_DEBUG("%s (@%zu) is not extension", elm->type->name, edx);
+            continue;
+        }
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 = (const void * const *)((const char *)sptr + elm->memb_offset);
+            present = (*memb_ptr2 != 0);
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+            present = 1;
+        }
+
+        ASN_DEBUG("checking %s (@%zu) present => %d",
+                  elm->type->name, edx, present);
+        exts_count++;
+        exts_present += present;
+
+        /* Encode as presence marker */
+        if(po1 && per_put_few_bits(po1, present, 1))
+            return -1;
+        /* Encode as open type field */
+        if(po2 && present && aper_open_type_put(elm->type,
+                                                elm->encoding_constraints.per_constraints,
+                                                *memb_ptr2, po2))
+            return -1;
+
+    }
+
+    return exts_present ? exts_count : 0;
+}
+
+asn_enc_rval_t
+SEQUENCE_encode_aper(const asn_TYPE_descriptor_t *td,
+                     const asn_per_constraints_t *constraints,
+                     const void *sptr, asn_per_outp_t *po) {
+    const asn_SEQUENCE_specifics_t *specs
+        = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    int n_extensions;
+    size_t edx;
+    size_t i;
+
+    (void)constraints;
+
+    if(!sptr)
+        ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    ASN_DEBUG("Encoding %s as SEQUENCE (APER)", td->name);
+
+    /*
+     * X.691#18.1 Whether structure is extensible
+     * and whether to encode extensions
+     */
+    if(specs->first_extension < 0) {
+        n_extensions = 0; /* There are no extensions to encode */
+    } else {
+        n_extensions = SEQUENCE_handle_extensions_aper(td, sptr, 0, 0);
+        if(n_extensions < 0) ASN__ENCODE_FAILED;
+        if(per_put_few_bits(po, n_extensions ? 1 : 0, 1)) {
+            ASN__ENCODE_FAILED;
+        }
+    }
+
+    /* Encode a presence bitmap */
+    for(i = 0; i < specs->roms_count; i++) {
+        asn_TYPE_member_t *elm;
+        const void *memb_ptr;           /* Pointer to the member */
+        const void * const *memb_ptr2;  /* Pointer to that pointer */
+        int present;
+
+        edx = specs->oms[i];
+        elm = &td->elements[edx];
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 = (const void * const *)((const char *)sptr + elm->memb_offset);
+            present = (*memb_ptr2 != 0);
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+            present = 1;
+        }
+
+        /* Eliminate default values */
+        if(present && elm->default_value_cmp
+                && elm->default_value_cmp(*memb_ptr2) == 0)
+            present = 0;
+
+        ASN_DEBUG("Element %s %s %s->%s is %s",
+                  elm->flags & ATF_POINTER ? "ptr" : "inline",
+                  elm->default_value_cmp ? "def" : "wtv",
+                  td->name, elm->name, present ? "present" : "absent");
+        if(per_put_few_bits(po, present, 1))
+            ASN__ENCODE_FAILED;
+    }
+
+    /*
+     * Encode the sequence ROOT elements.
+     */
+    ASN_DEBUG("first_extension = %d, elements = %d", specs->first_extension,
+              td->elements_count);
+    for(edx = 0;
+        edx < ((specs->first_extension < 0) ? td->elements_count
+                                            : (size_t)specs->first_extension);
+        edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        const void *memb_ptr;           /* Pointer to the member */
+        const void * const *memb_ptr2;  /* Pointer to that pointer */
+
+        if(IN_EXTENSION_GROUP(specs, edx))
+            continue;
+
+        ASN_DEBUG("About to encode %s", elm->type->name);
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 = (const void * const *)((const char *)sptr + elm->memb_offset);
+            if(!*memb_ptr2) {
+                ASN_DEBUG("Element %s %zu not present",
+                          elm->name, edx);
+                if(elm->optional)
+                    continue;
+                /* Mandatory element is missing */
+                ASN__ENCODE_FAILED;
+            }
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+        }
+
+        /* Eliminate default values */
+        if(elm->default_value_cmp && elm->default_value_cmp(*memb_ptr2) == 0)
+            continue;
+
+        ASN_DEBUG("Encoding %s->%s", td->name, elm->name);
+        er = elm->type->op->aper_encoder(elm->type,
+                                         elm->encoding_constraints.per_constraints,
+                                         *memb_ptr2, po);
+        if(er.encoded == -1)
+            return er;
+    }
+
+    /* No extensions to encode */
+    if(!n_extensions) ASN__ENCODED_OK(er);
+
+    ASN_DEBUG("Length of %d bit-map", n_extensions);
+    /* #18.8. Write down the presence bit-map length. */
+    if(aper_put_nslength(po, n_extensions))
+        ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Bit-map of %d elements", n_extensions);
+    /* #18.7. Encoding the extensions presence bit-map. */
+    /* TODO: act upon NOTE in #18.7 for canonical PER */
+    if(SEQUENCE_handle_extensions_aper(td, sptr, po, 0) != n_extensions)
+        ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Writing %d extensions", n_extensions);
+    /* #18.9. Encode extensions as open type fields. */
+    if(SEQUENCE_handle_extensions_aper(td, sptr, 0, po) != n_extensions)
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_ber.c
new file mode 100644
index 000000000..f79b25c29
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_ber.c
@@ -0,0 +1,612 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+#include "OPEN_TYPE.h"
+
+/*
+ * Number of bytes left for this structure.
+ * (ctx->left) indicates the number of bytes _transferred_ for the structure.
+ * (size) contains the number of bytes in the buffer passed.
+ */
+#define LEFT ((size<(size_t)ctx->left)?size:(size_t)ctx->left)
+
+/*
+ * If the subprocessor function returns with an indication that it wants
+ * more data, it may well be a fatal decoding problem, because the
+ * size is constrained by the <TLV>'s L, even if the buffer size allows
+ * reading more data.
+ * For example, consider the buffer containing the following TLVs:
+ * <T:5><L:1><V> <T:6>...
+ * The TLV length clearly indicates that one byte is expected in V, but
+ * if the V processor returns with "want more data" even if the buffer
+ * contains way more data than the V processor have seen.
+ */
+#define SIZE_VIOLATION (ctx->left >= 0 && (size_t)ctx->left <= size)
+
+/*
+ * This macro "eats" the part of the buffer which is definitely "consumed",
+ * i.e. was correctly converted into local representation or rightfully skipped.
+ */
+#undef ADVANCE
+#define ADVANCE(num_bytes)                \
+    do {                                  \
+        size_t num = num_bytes;           \
+        ptr = ((const char *)ptr) + num;  \
+        size -= num;                      \
+        if(ctx->left >= 0)                \
+            ctx->left -= num;             \
+        consumed_myself += num;           \
+    } while(0)
+
+/*
+ * Switch to the next phase of parsing.
+ */
+#undef NEXT_PHASE
+#define NEXT_PHASE(ctx)  \
+    do {                 \
+        ctx->phase++;    \
+        ctx->step = 0;   \
+    } while(0)
+#undef PHASE_OUT
+#define PHASE_OUT(ctx)    \
+    do {                  \
+        ctx->phase = 10;  \
+    } while(0)
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+/*
+ * Check whether we are inside the extensions group.
+ */
+#define IN_EXTENSION_GROUP(specs, memb_idx)                \
+    ((specs)->first_extension >= 0                         \
+     && (unsigned)(specs)->first_extension <= (memb_idx))
+
+/*
+ * Tags are canonically sorted in the tag2element map.
+ */
+static int
+_t2e_cmp(const void *ap, const void *bp) {
+    const asn_TYPE_tag2member_t *a = (const asn_TYPE_tag2member_t *)ap;
+    const asn_TYPE_tag2member_t *b = (const asn_TYPE_tag2member_t *)bp;
+
+    int a_class = BER_TAG_CLASS(a->el_tag);
+    int b_class = BER_TAG_CLASS(b->el_tag);
+
+    if(a_class == b_class) {
+        ber_tlv_tag_t a_value = BER_TAG_VALUE(a->el_tag);
+        ber_tlv_tag_t b_value = BER_TAG_VALUE(b->el_tag);
+
+        if(a_value == b_value) {
+            if(a->el_no > b->el_no)
+                return 1;
+            /*
+             * Important: we do not check
+             * for a->el_no <= b->el_no!
+             */
+            return 0;
+        } else if(a_value < b_value)
+            return -1;
+        else
+            return 1;
+    } else if(a_class < b_class) {
+        return -1;
+    } else {
+        return 1;
+    }
+}
+
+/*
+ * The decoder of the SEQUENCE type.
+ */
+asn_dec_rval_t
+SEQUENCE_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,
+                    const asn_TYPE_descriptor_t *td, void **struct_ptr,
+                    const void *ptr, size_t size, int tag_mode) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_SEQUENCE_specifics_t *specs = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elements = td->elements;
+
+    /*
+     * Parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    ber_tlv_tag_t tlv_tag;  /* T from TLV */
+    asn_dec_rval_t rval;    /* Return code from subparsers */
+
+    ssize_t consumed_myself = 0;  /* Consumed bytes from ptr */
+    size_t edx;  /* SEQUENCE element's index */
+
+    ASN_DEBUG("Decoding %s as SEQUENCE", td->name);
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) {
+            RETURN(RC_FAIL);
+        }
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Start to parse where left previously
+     */
+    switch(ctx->phase) {
+    case 0:
+        /*
+         * PHASE 0.
+         * Check that the set of tags associated with given structure
+         * perfectly fits our expectations.
+         */
+
+        rval = ber_check_tags(opt_codec_ctx, td, ctx, ptr, size,
+                              tag_mode, 1, &ctx->left, 0);
+        if(rval.code != RC_OK) {
+            ASN_DEBUG("%s tagging check failed: %d",
+                      td->name, rval.code);
+            return rval;
+        }
+
+        if(ctx->left >= 0)
+            ctx->left += rval.consumed;  /* ?Subtracted below! */
+        ADVANCE(rval.consumed);
+
+        NEXT_PHASE(ctx);
+
+        ASN_DEBUG("Structure consumes %ld bytes, buffer %ld",
+                  (long)ctx->left, (long)size);
+
+        /* Fall through */
+    case 1:
+        /*
+         * PHASE 1.
+         * From the place where we've left it previously,
+         * try to decode the next member from the list of
+         * this structure's elements.
+         * (ctx->step) stores the member being processed
+         * between invocations and the microphase {0,1} of parsing
+         * that member:
+         *     step = (<member_number> * 2 + <microphase>).
+         */
+        for(edx = ((size_t)ctx->step >> 1); edx < td->elements_count;
+                edx++, ctx->step = (ctx->step & ~1) + 2) {
+            void *memb_ptr;      /* Pointer to the member */
+            void **memb_ptr2;    /* Pointer to that pointer */
+            ssize_t tag_len;     /* Length of TLV's T */
+            size_t opt_edx_end;  /* Next non-optional element */
+            size_t n;
+            int use_bsearch;
+
+            if(ctx->step & 1)
+                goto microphase2;
+
+            /*
+             * MICROPHASE 1: Synchronize decoding.
+             */
+            ASN_DEBUG("In %s SEQUENCE left %d, edx=%" ASN_PRI_SIZE " flags=%d"
+                      " opt=%d ec=%d",
+                      td->name, (int)ctx->left, edx,
+                      elements[edx].flags, elements[edx].optional,
+                      td->elements_count);
+
+            if(ctx->left == 0 /* No more stuff is expected */
+               && (
+                      /* Explicit OPTIONAL specification reaches the end */
+                      (edx + elements[edx].optional == td->elements_count) ||
+                      /* All extensions are optional */
+                      IN_EXTENSION_GROUP(specs, edx))) {
+                ASN_DEBUG("End of SEQUENCE %s", td->name);
+                /*
+                 * Found the legitimate end of the structure.
+                 */
+                PHASE_OUT(ctx);
+                RETURN(RC_OK);
+            }
+
+            /*
+             * Fetch the T from TLV.
+             */
+            tag_len = ber_fetch_tag(ptr, LEFT, &tlv_tag);
+            ASN_DEBUG("Current tag in %s SEQUENCE for element %" ASN_PRI_SIZE " "
+                      "(%s) is %s encoded in %d bytes, of frame %ld",
+                      td->name, edx, elements[edx].name,
+                      ber_tlv_tag_string(tlv_tag), (int)tag_len, (long)LEFT);
+            switch(tag_len) {
+            case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+                /* Fall through */
+            case -1: RETURN(RC_FAIL);
+            }
+
+            if(ctx->left < 0 && ((const uint8_t *)ptr)[0] == 0) {
+                if(LEFT < 2) {
+                    if(SIZE_VIOLATION) {
+                        RETURN(RC_FAIL);
+                    } else {
+                        RETURN(RC_WMORE);
+                    }
+                } else if(((const uint8_t *)ptr)[1] == 0) {
+                    ASN_DEBUG("edx = %" ASN_PRI_SIZE ", opt = %d, ec=%d", edx,
+                              elements[edx].optional, td->elements_count);
+                    if((edx + elements[edx].optional == td->elements_count)
+                       || IN_EXTENSION_GROUP(specs, edx)) {
+                        /*
+                         * Yeah, baby! Found the terminator
+                         * of the indefinite length structure.
+                         */
+                        /*
+                         * Proceed to the canonical
+                         * finalization function.
+                         * No advancing is necessary.
+                         */
+                        goto phase3;
+                    }
+                }
+            }
+
+            /*
+             * Find the next available type with this tag.
+             */
+            use_bsearch = 0;
+            opt_edx_end = edx + elements[edx].optional + 1;
+            if(opt_edx_end > td->elements_count)
+                opt_edx_end = td->elements_count;  /* Cap */
+            else if(opt_edx_end - edx > 8) {
+                /* Limit the scope of linear search... */
+                opt_edx_end = edx + 8;
+                use_bsearch = 1;
+                /* ... and resort to bsearch() */
+            }
+            for(n = edx; n < opt_edx_end; n++) {
+                if(BER_TAGS_EQUAL(tlv_tag, elements[n].tag)) {
+                    /*
+                     * Found element corresponding to the tag
+                     * being looked at.
+                     * Reposition over the right element.
+                     */
+                    edx = n;
+                    ctx->step = 1 + 2 * edx;  /* Remember! */
+                    goto microphase2;
+                } else if(elements[n].flags & ATF_ANY_TYPE) {
+                    /*
+                     * This is the ANY type, which may bear
+                     * any flag whatsoever.
+                     */
+                    edx = n;
+                    ctx->step = 1 + 2 * edx;  /* Remember! */
+                    goto microphase2;
+                } else if(elements[n].tag == (ber_tlv_tag_t)-1) {
+                    use_bsearch = 1;
+                    break;
+                }
+            }
+            if(use_bsearch) {
+                /*
+                 * Resort to a binary search over
+                 * sorted array of tags.
+                 */
+                const asn_TYPE_tag2member_t *t2m;
+                asn_TYPE_tag2member_t key = {0, 0, 0, 0};
+                key.el_tag = tlv_tag;
+                key.el_no = edx;
+                t2m = (const asn_TYPE_tag2member_t *)bsearch(&key,
+                       specs->tag2el, specs->tag2el_count,
+                       sizeof(specs->tag2el[0]), _t2e_cmp);
+                if(t2m) {
+                    const asn_TYPE_tag2member_t *best = 0;
+                    const asn_TYPE_tag2member_t *t2m_f, *t2m_l;
+                    size_t edx_max = edx + elements[edx].optional;
+                    /*
+                     * Rewind to the first element with that tag,
+                     * `cause bsearch() does not guarantee order.
+                     */
+                    t2m_f = t2m + t2m->toff_first;
+                    t2m_l = t2m + t2m->toff_last;
+                    for(t2m = t2m_f; t2m <= t2m_l; t2m++) {
+                        if(t2m->el_no > edx_max) break;
+                        if(t2m->el_no < edx) continue;
+                        best = t2m;
+                    }
+                    if(best) {
+                        edx = best->el_no;
+                        ctx->step = 1 + 2 * edx;
+                        goto microphase2;
+                    }
+                }
+                n = opt_edx_end;
+            }
+            if(n == opt_edx_end) {
+                /*
+                 * If tag is unknown, it may be either
+                 * an unknown (thus, incorrect) tag,
+                 * or an extension (...),
+                 * or an end of the indefinite-length structure.
+                 */
+                if(!IN_EXTENSION_GROUP(specs,
+                    edx + elements[edx].optional)) {
+                    ASN_DEBUG("Unexpected tag %s (at %" ASN_PRI_SIZE ")",
+                              ber_tlv_tag_string(tlv_tag), edx);
+                    ASN_DEBUG("Expected tag %s (%s)%s",
+                              ber_tlv_tag_string(elements[edx].tag),
+                              elements[edx].name,
+                              elements[edx].optional ?" or alternatives":"");
+                    RETURN(RC_FAIL);
+                } else {
+                    /* Skip this tag */
+                    ssize_t skip;
+                    edx += elements[edx].optional;
+
+                    ASN_DEBUG("Skipping unexpected %s (at %" ASN_PRI_SIZE ")",
+                              ber_tlv_tag_string(tlv_tag), edx);
+                    skip = ber_skip_length(opt_codec_ctx,
+                                           BER_TLV_CONSTRUCTED(ptr),
+                                           (const char *)ptr + tag_len,
+                                           LEFT - tag_len);
+                    ASN_DEBUG("Skip length %d in %s",
+                              (int)skip, td->name);
+                    switch(skip) {
+                    case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+                        /* Fall through */
+                    case -1: RETURN(RC_FAIL);
+                    }
+
+                    ADVANCE(skip + tag_len);
+                    ctx->step -= 2;
+                    edx--;
+                    continue;  /* Try again with the next tag */
+                }
+            }
+
+            /*
+             * MICROPHASE 2: Invoke the member-specific decoder.
+             */
+            ctx->step |= 1;  /* Confirm entering next microphase */
+        microphase2:
+            ASN_DEBUG("Inside SEQUENCE %s MF2", td->name);
+
+            /*
+             * Compute the position of the member inside a structure,
+             * and also a type of containment (it may be contained
+             * as pointer or using inline inclusion).
+             */
+            if(elements[edx].flags & ATF_POINTER) {
+                /* Member is a pointer to another structure */
+                memb_ptr2 = (void **)((char *)st + elements[edx].memb_offset);
+            } else {
+                /*
+                 * A pointer to a pointer
+                 * holding the start of the structure
+                 */
+                memb_ptr = (char *)st + elements[edx].memb_offset;
+                memb_ptr2 = &memb_ptr;
+            }
+            /*
+             * Invoke the member fetch routine according to member's type
+             */
+            if(elements[edx].flags & ATF_OPEN_TYPE) {
+                rval = OPEN_TYPE_ber_get(opt_codec_ctx, td, st, &elements[edx], ptr, LEFT);
+            } else {
+                rval = elements[edx].type->op->ber_decoder(opt_codec_ctx,
+                                                           elements[edx].type,
+                                                           memb_ptr2, ptr, LEFT,
+                                                           elements[edx].tag_mode);
+            }
+            ASN_DEBUG("In %s SEQUENCE decoded %" ASN_PRI_SIZE " %s of %d "
+                      "in %d bytes rval.code %d, size=%d",
+                      td->name, edx, elements[edx].type->name,
+                      (int)LEFT, (int)rval.consumed, rval.code, (int)size);
+            switch(rval.code) {
+            case RC_OK:
+                break;
+            case RC_WMORE: /* More data expected */
+                if(!SIZE_VIOLATION) {
+                    ADVANCE(rval.consumed);
+                    RETURN(RC_WMORE);
+                }
+                ASN_DEBUG("Size violation (c->l=%ld <= s=%ld)",
+                          (long)ctx->left, (long)size);
+                /* Fall through */
+            case RC_FAIL: /* Fatal error */
+                RETURN(RC_FAIL);
+        } /* switch(rval) */
+
+        ADVANCE(rval.consumed);
+    }  /* for(all structure members) */
+
+    phase3:
+        ctx->phase = 3;
+        /* Fall through */
+    case 3:  /* 00 and other tags expected */
+    case 4:  /* only 00's expected */
+
+        ASN_DEBUG("SEQUENCE %s Leftover: %ld, size = %ld",
+                  td->name, (long)ctx->left, (long)size);
+
+        /*
+         * Skip everything until the end of the SEQUENCE.
+         */
+        while(ctx->left) {
+            ssize_t tl, ll;
+
+            tl = ber_fetch_tag(ptr, LEFT, &tlv_tag);
+            switch(tl) {
+            case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+                /* Fall through */
+            case -1: RETURN(RC_FAIL);
+            }
+
+            /*
+             * If expected <0><0>...
+             */
+            if(ctx->left < 0 && ((const uint8_t *)ptr)[0] == 0) {
+                if(LEFT < 2) {
+                    if(SIZE_VIOLATION)
+                        RETURN(RC_FAIL);
+                    else
+                        RETURN(RC_WMORE);
+                } else if(((const uint8_t *)ptr)[1] == 0) {
+                    /*
+                     * Correctly finished with <0><0>.
+                     */
+                    ADVANCE(2);
+                    ctx->left++;
+                    ctx->phase = 4;
+                    continue;
+                }
+            }
+
+            if(!IN_EXTENSION_GROUP(specs, td->elements_count)
+            || ctx->phase == 4) {
+                ASN_DEBUG("Unexpected continuation "
+                          "of a non-extensible type "
+                          "%s (SEQUENCE): %s",
+                          td->name,
+                          ber_tlv_tag_string(tlv_tag));
+                RETURN(RC_FAIL);
+            }
+
+            ll = ber_skip_length(opt_codec_ctx,
+                                 BER_TLV_CONSTRUCTED(ptr),
+                                 (const char *)ptr + tl, LEFT - tl);
+            switch(ll) {
+            case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+                /* Fall through */
+            case -1: RETURN(RC_FAIL);
+            }
+
+            ADVANCE(tl + ll);
+        }
+
+        PHASE_OUT(ctx);
+    }
+
+    RETURN(RC_OK);
+}
+
+
+/*
+ * The DER encoder of the SEQUENCE type.
+ */
+asn_enc_rval_t
+SEQUENCE_encode_der(const asn_TYPE_descriptor_t *td, const void *sptr,
+                    int tag_mode, ber_tlv_tag_t tag,
+                    asn_app_consume_bytes_f *cb, void *app_key) {
+    size_t computed_size = 0;
+    asn_enc_rval_t erval = {0,0,0};
+    ssize_t ret;
+    size_t edx;
+
+    ASN_DEBUG("%s %s as SEQUENCE",
+              cb?"Encoding":"Estimating", td->name);
+
+    /*
+     * Gather the length of the underlying members sequence.
+     */
+    for(edx = 0; edx < td->elements_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+
+        const void *memb_ptr;          /* Pointer to the member */
+        const void *const *memb_ptr2;  /* Pointer to that pointer */
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 =
+                (const void *const *)((const char *)sptr + elm->memb_offset);
+            if(!*memb_ptr2) {
+                ASN_DEBUG("Element %s %" ASN_PRI_SIZE " not present",
+                          elm->name, edx);
+                if(elm->optional)
+                    continue;
+                /* Mandatory element is missing */
+                ASN__ENCODE_FAILED;
+            }
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+        }
+
+        /* Eliminate default values */
+        if(elm->default_value_cmp && elm->default_value_cmp(*memb_ptr2) == 0)
+            continue;
+
+        erval = elm->type->op->der_encoder(elm->type, *memb_ptr2,
+                                           elm->tag_mode, elm->tag,
+                                           0, 0);
+        if(erval.encoded == -1)
+            return erval;
+        computed_size += erval.encoded;
+        ASN_DEBUG("Member %" ASN_PRI_SIZE " %s estimated %ld bytes",
+                  edx, elm->name, (long)erval.encoded);
+    }
+
+    /*
+     * Encode the TLV for the sequence itself.
+     */
+    ret = der_write_tags(td, computed_size, tag_mode, 1, tag, cb, app_key);
+    ASN_DEBUG("Wrote tags: %ld (+%ld)", (long)ret, (long)computed_size);
+    if(ret == -1)
+        ASN__ENCODE_FAILED;
+    erval.encoded = computed_size + ret;
+
+    if(!cb) ASN__ENCODED_OK(erval);
+
+    /*
+     * Encode all members.
+     */
+    for(edx = 0; edx < td->elements_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        asn_enc_rval_t tmperval = {0,0,0};
+        const void *memb_ptr;          /* Pointer to the member */
+        const void *const *memb_ptr2;  /* Pointer to that pointer */
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 =
+                (const void *const *)((const char *)sptr + elm->memb_offset);
+            if(!*memb_ptr2) continue;
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+        }
+
+        /* Eliminate default values */
+        if(elm->default_value_cmp && elm->default_value_cmp(*memb_ptr2) == 0)
+            continue;
+
+        tmperval = elm->type->op->der_encoder(elm->type, *memb_ptr2,
+                                              elm->tag_mode, elm->tag, cb, app_key);
+        if(tmperval.encoded == -1)
+            return tmperval;
+        computed_size -= tmperval.encoded;
+        ASN_DEBUG("Member %" ASN_PRI_SIZE " %s of SEQUENCE %s encoded in %ld bytes",
+                  edx, elm->name, td->name, (long)tmperval.encoded);
+    }
+
+    if(computed_size != 0)
+        /*
+         * Encoded size is not equal to the computed size.
+         */
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(erval);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_jer.c
new file mode 100644
index 000000000..d35f06b1e
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_jer.c
@@ -0,0 +1,381 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+#include "OPEN_TYPE.h"
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+/*
+ * Check whether we are inside the extensions group.
+ */
+#define IN_EXTENSION_GROUP(specs, memb_idx)                \
+    ((specs)->first_extension >= 0                         \
+     && (unsigned)(specs)->first_extension <= (memb_idx))
+
+#undef JER_ADVANCE
+#define JER_ADVANCE(num_bytes)            \
+    do {                                  \
+        size_t num = (num_bytes);         \
+        ptr = ((const char *)ptr) + num;  \
+        size -= num;                      \
+        consumed_myself += num;           \
+    } while(0)
+
+/*
+ * Decode the JER (JSON) data.
+ */
+asn_dec_rval_t
+SEQUENCE_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                    const asn_TYPE_descriptor_t *td,
+                    const asn_jer_constraints_t *constraints,
+                    void **struct_ptr, const void *ptr, size_t size) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_SEQUENCE_specifics_t *specs
+        = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    asn_TYPE_member_t *elements = td->elements;
+
+    /*
+     * ... and parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    asn_dec_rval_t rval;          /* Return value from a decoder */
+    ssize_t consumed_myself = 0;  /* Consumed bytes from ptr */
+    ssize_t edx;                   /* Element index */
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) RETURN(RC_FAIL);
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Phases of JER/JSON processing:
+     * Phase 0: Check that the key matches our expectations.
+     * Phase 1: Processing body and reacting on closing token.
+     * Phase 2: Processing inner type.
+     * Phase 3: Skipping unknown extensions.
+     * Phase 4: PHASED OUT
+     */
+    for(edx = ctx->step; ctx->phase <= 3;) {
+        pjer_chunk_type_e ch_type;  /* JER chunk type */
+        ssize_t ch_size;            /* Chunk size */
+        jer_check_sym_e scv;        /* Tag check value */
+        asn_TYPE_member_t *elm;
+
+
+        /*
+         * Go inside the inner member of a sequence.
+         */
+        if(ctx->phase == 2) {
+            asn_dec_rval_t tmprval;
+            void *memb_ptr_dontuse;  /* Pointer to the member */
+            void **memb_ptr2;        /* Pointer to that pointer */
+
+            elm = &td->elements[edx];
+            if(elm->flags & ATF_POINTER) {
+                /* Member is a pointer to another structure */
+                memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+            } else {
+                memb_ptr_dontuse = (char *)st + elm->memb_offset;
+                memb_ptr2 = &memb_ptr_dontuse;  /* Only use of memb_ptr_dontuse */
+            }
+
+            if(elm->flags & ATF_OPEN_TYPE) {
+                tmprval = OPEN_TYPE_jer_get(opt_codec_ctx, td, st, elm, ptr, size);
+            } else {
+                /* Invoke the inner type decoder, m.b. multiple times */
+                tmprval = elm->type->op->jer_decoder(opt_codec_ctx,
+                                                     elm->type,
+                                                     elm->encoding_constraints.jer_constraints,
+                                                     memb_ptr2,
+                                                     ptr, size);
+            }
+            JER_ADVANCE(tmprval.consumed);
+            if(tmprval.code != RC_OK)
+                RETURN(tmprval.code);
+            ctx->phase = 1;  /* Back to body processing */
+            ctx->step = ++edx;
+            ASN_DEBUG("JER/SEQUENCE phase => %d, step => %d",
+                ctx->phase, ctx->step);
+            /* Fall through */
+        }
+
+        /*
+         * Get the next part of the JSON stream.
+         */
+        ch_size = jer_next_token(&ctx->context, ptr, size,
+            &ch_type);
+        if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+            switch(ch_type) {
+            case PJER_WMORE:
+                RETURN(RC_WMORE);
+
+            case PJER_TEXT:  /* Ignore free-standing text */
+                JER_ADVANCE(ch_size);  /* Skip silently */
+                continue;
+
+            case PJER_DLM:
+            case PJER_VALUE:
+            case PJER_KEY:
+                break;  /* Check the rest down there */
+            }
+        }
+
+        scv = jer_check_sym(ptr, ch_size, NULL);
+        ASN_DEBUG("JER/SEQUENCE: scv = %d, ph=%d [%s]",
+                  scv, ctx->phase, td->name);
+
+
+        /* Skip the extensions section */
+        if(ctx->phase == 3) {
+            switch(jer_skip_unknown(scv, &ctx->left)) {
+            case -1:
+                ctx->phase = 4;
+                RETURN(RC_FAIL);
+            case 0:
+                JER_ADVANCE(ch_size);
+                continue;
+            case 1:
+                JER_ADVANCE(ch_size);
+                ctx->phase = 1;
+                continue;
+            case 2:
+                ctx->phase = 1;
+                break;
+            }
+        }
+
+        switch(scv) {
+        case JCK_OEND:
+            if(ctx->phase == 0) break;
+            ctx->phase = 0;
+
+            if(edx >= td->elements_count ||
+               /* Explicit OPTIONAL specs reaches the end */
+               (edx + elements[edx].optional == td->elements_count) ||
+               /* All extensions are optional */
+               IN_EXTENSION_GROUP(specs, edx)) {
+                JER_ADVANCE(ch_size);
+                JER_ADVANCE(jer_whitespace_span(ptr, size));
+                ctx->phase = 4; /* Phase out */
+                RETURN(RC_OK);
+            } else {
+                ASN_DEBUG("Premature end of JER SEQUENCE");
+                RETURN(RC_FAIL);
+            }
+        case JCK_COMMA:
+            ADVANCE(ch_size);
+            continue;
+            /* Fall through */
+        case JCK_OSTART: /* '{' */
+            if(ctx->phase == 0) {
+                JER_ADVANCE(ch_size);
+                ctx->phase = 1;  /* Processing body phase */
+                continue;
+            }
+
+            /* Fall through */
+        case JCK_KEY:
+        case JCK_UNKNOWN:
+            ASN_DEBUG("JER/SEQUENCE: scv=%d, ph=%d, edx=%" ASN_PRI_SIZE "",
+                      scv, ctx->phase, edx);
+            if(ctx->phase != 1) {
+                break;  /* Really unexpected */
+            }
+
+            if (td->elements_count == 0) {
+                JER_ADVANCE(ch_size);
+                continue;
+            }
+
+            if(edx < td->elements_count) {
+                /*
+                 * We have to check which member is next.
+                 */
+                size_t n;
+                size_t edx_end = edx + elements[edx].optional + 1;
+                if(edx_end > td->elements_count) {
+                    edx_end = td->elements_count;
+                }
+
+                for(n = edx; n < edx_end; n++) {
+                    elm = &td->elements[n];
+                    scv = jer_check_sym(ptr, ch_size, elm->name);
+                    switch (scv) {
+                        case JCK_KEY:
+                            ctx->step = edx = n;
+                            ctx->phase = 2;
+
+                            ADVANCE(ch_size); /* skip key */
+                            /* skip colon */
+                            ch_size = jer_next_token(&ctx->context, ptr, size,
+                                    &ch_type);
+                            if(ch_size == -1) {
+                                RETURN(RC_FAIL);
+                            } else {
+                                switch(ch_type) {
+                                case PJER_WMORE:
+                                    RETURN(RC_WMORE);
+                                case PJER_TEXT:
+                                    JER_ADVANCE(ch_size);
+                                    break;
+                                default:
+                                    RETURN(RC_FAIL);
+                                }
+                            }
+                            break;
+                        case JCK_UNKNOWN:
+                            continue;
+                        default:
+                            n = edx_end;
+                            break; /* Phase out */
+                    }
+                    break;
+                }
+                if(n != edx_end)
+                    continue;
+            } else {
+                ASN_DEBUG("Out of defined members: %" ASN_PRI_SIZE "/%u",
+                          edx, td->elements_count);
+            }
+
+            /* It is expected extension */
+            if(IN_EXTENSION_GROUP(specs,
+                edx + (edx < td->elements_count
+                    ? elements[edx].optional : 0))) {
+                ASN_DEBUG("Got anticipated extension at %" ASN_PRI_SIZE "",
+                          edx);
+                ctx->left = 1;
+                ctx->phase = 3;  /* Skip ...'s */
+                JER_ADVANCE(ch_size);
+                continue;
+            }
+
+            /* Fall through */
+        default:
+            break;
+        }
+
+        ASN_DEBUG("Unexpected JSON key in SEQUENCE [%c%c%c%c%c%c]",
+                  size>0?((const char *)ptr)[0]:'.',
+                  size>1?((const char *)ptr)[1]:'.',
+                  size>2?((const char *)ptr)[2]:'.',
+                  size>3?((const char *)ptr)[3]:'.',
+                  size>4?((const char *)ptr)[4]:'.',
+                  size>5?((const char *)ptr)[5]:'.');
+        break;
+    }
+
+    ctx->phase = 4;  /* "Phase out" on hard failure */
+    RETURN(RC_FAIL);
+}
+
+
+asn_enc_rval_t SEQUENCE_encode_jer(const asn_TYPE_descriptor_t *td,
+                    const asn_jer_constraints_t* constraints, const void *sptr,
+                    int ilevel, enum jer_encoder_flags_e flags,
+                    asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0,0,0};
+    int jmin = (flags & JER_F_MINIFIED);
+    asn_TYPE_descriptor_t *tmp_def_val_td = 0;
+    void *tmp_def_val = 0;
+    size_t edx;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    int bAddComma = 0;
+    ASN__CALLBACK("{", 1);
+    for(edx = 0; edx < td->elements_count; edx++) {
+        asn_enc_rval_t tmper = {0,0,0};
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        const void *memb_ptr;
+        const char *mname = elm->name;
+        unsigned int mlen = strlen(mname);
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr =
+                *(const void *const *)((const char *)sptr + elm->memb_offset);
+            if(!memb_ptr) {
+                assert(tmp_def_val == 0);
+                if(elm->default_value_set) {
+                    if(elm->default_value_set(&tmp_def_val)) {
+                        ASN__ENCODE_FAILED;
+                    } else {
+                        memb_ptr = tmp_def_val;
+                        tmp_def_val_td = elm->type;
+                    }
+                } else if(elm->optional) {
+                    continue;
+                } else {
+                    /* Mandatory element is missing */
+                    ASN__ENCODE_FAILED;
+                }
+            }
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+        }
+
+        if (bAddComma == 1) {
+          ASN__CALLBACK(",", 1);
+          bAddComma = 0;
+        }
+
+        if(!jmin) {
+            ASN__TEXT_INDENT(1, ilevel + 1);
+            ASN__CALLBACK3("\"", 1, mname, mlen, "\": ", 3);
+        } else {
+            ASN__CALLBACK3("\"", 1, mname, mlen, "\":", 2);
+        }
+
+        /* Print the member itself */
+        tmper = elm->type->op->jer_encoder(elm->type,
+                                           elm->encoding_constraints.jer_constraints,
+                                           memb_ptr,
+                                           ilevel + 1, flags, cb, app_key);
+        if(tmp_def_val) {
+            ASN_STRUCT_FREE(*tmp_def_val_td, tmp_def_val);
+            tmp_def_val = 0;
+        }
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+        if (edx != td->elements_count - 1) {
+          bAddComma = 1;
+        }
+    }
+    if(!jmin) ASN__TEXT_INDENT(1, ilevel);
+    ASN__CALLBACK("}", 1);
+
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    if(tmp_def_val) ASN_STRUCT_FREE(*tmp_def_val_td, tmp_def_val);
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_oer.c
new file mode 100644
index 000000000..08a2d086b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_oer.c
@@ -0,0 +1,557 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+#include "asn_bit_data.h"
+#include "OPEN_TYPE.h"
+
+/*
+ * This macro "eats" the part of the buffer which is definitely "consumed",
+ * i.e. was correctly converted into local representation or rightfully skipped.
+ */
+#undef  ADVANCE
+#define ADVANCE(num_bytes)                   \
+    do {                                     \
+        size_t num = num_bytes;              \
+        ptr = ((const char *)ptr) + num;     \
+        size -= num;                         \
+        consumed_myself += num;              \
+    } while(0)
+
+/*
+ * Switch to the next phase of parsing.
+ */
+#undef  NEXT_PHASE
+#undef PHASE_OUT
+#define NEXT_PHASE(ctx) \
+    do {                \
+        ctx->phase++;   \
+        ctx->step = 0;  \
+    } while(0)
+
+/*
+ * Check whether we are inside the extensions group.
+ */
+#define IN_EXTENSION_GROUP(specs, memb_idx) \
+    ((specs)->first_extension >= 0          \
+     && (unsigned)(specs)->first_extension <= (memb_idx))
+
+#define IN_ROOT_GROUP_PRED(edx)                            \
+    edx < (specs->first_extension < 0 ? td->elements_count \
+                                      : (size_t)specs->first_extension)
+
+#define FOR_IN_ROOT_GROUP(edx) for(edx = 0; IN_ROOT_GROUP_PRED(edx); edx++)
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef  RETURN
+#define RETURN(_code)   do {                    \
+                rval.code = _code;              \
+                rval.consumed = consumed_myself;\
+                return rval;                    \
+        } while(0)
+
+/*
+ * Return pointer to a member.
+ */
+static void **
+element_ptrptr(void *struct_ptr, asn_TYPE_member_t *elm, void **tmp_save_ptr) {
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        return (void **)((char *)struct_ptr + elm->memb_offset);
+    } else {
+        assert(tmp_save_ptr);
+        *tmp_save_ptr = (void *)((char *)struct_ptr + elm->memb_offset);
+        return tmp_save_ptr;
+    }
+}
+
+static const void *
+element_ptr(const void *struct_ptr, const asn_TYPE_member_t *elm) {
+    if(elm->flags & ATF_POINTER) {
+        /* Member is a pointer to another structure */
+        return *(const void *const *)((const char *)struct_ptr
+                                      + elm->memb_offset);
+    } else {
+        return (const void *)((const char *)struct_ptr + elm->memb_offset);
+    }
+}
+
+asn_dec_rval_t
+SEQUENCE_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                    const asn_TYPE_descriptor_t *td,
+                    const asn_oer_constraints_t *constraints, void **struct_ptr,
+                    const void *ptr, size_t size) {
+    const asn_SEQUENCE_specifics_t *specs =
+        (const asn_SEQUENCE_specifics_t *)td->specifics;
+    asn_dec_rval_t rval = {RC_OK, 0};
+    void *st = *struct_ptr; /* Target structure */
+    asn_struct_ctx_t *ctx; /* Decoder context */
+    size_t consumed_myself = 0; /* Consumed bytes from ptr. */
+
+    (void)constraints;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) {
+            RETURN(RC_FAIL);
+        }
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Start to parse where left previously.
+     */
+    switch(ctx->phase) {
+    case 0: {
+        /*
+         * Fetch preamble.
+         */
+        asn_bit_data_t *preamble;
+        int has_extensions_bit = (specs->first_extension >= 0);
+        size_t preamble_bits = (has_extensions_bit + specs->roms_count);
+        size_t preamble_bytes = ((7 + preamble_bits) >> 3);
+
+        ASN_DEBUG("OER SEQUENCE %s Decoding PHASE 0", td->name);
+
+        ASN_DEBUG(
+            "Expecting preamble bits %" ASN_PRI_SIZE " for %s (including %d extension bits)",
+            preamble_bits, td->name, has_extensions_bit);
+
+        if(preamble_bytes > size) {
+            ASN__DECODE_STARVED;
+        }
+
+        preamble = asn_bit_data_new_contiguous(ptr, preamble_bits);
+        if(!preamble) {
+            RETURN(RC_FAIL);
+        }
+        preamble->nboff = has_extensions_bit;
+        ctx->ptr = preamble;
+        ADVANCE(preamble_bytes);
+    }
+        NEXT_PHASE(ctx);
+        /* FALL THROUGH */
+    case 1: {
+        /* Decode components of the extension root */
+        asn_bit_data_t *preamble = ctx->ptr;
+        size_t edx;
+
+        ASN_DEBUG("OER SEQUENCE %s Decoding PHASE 1 (Root)", td->name);
+
+        assert(preamble);
+
+        for(edx = (ctx->step >> 1); IN_ROOT_GROUP_PRED(edx);
+            edx++, ctx->step = (ctx->step & ~1) + 2) {
+            asn_TYPE_member_t *elm = &td->elements[edx];
+
+            ASN_DEBUG("Decoding %s->%s", td->name, elm->name);
+
+            assert(!IN_EXTENSION_GROUP(specs, edx));
+
+            if(ctx->step & 1) {
+                goto microphase2_decode_continues;
+            }
+
+
+            if(elm->optional) {
+                int32_t present = asn_get_few_bits(preamble, 1);
+                if(present < 0) {
+                    ASN_DEBUG("Presence map ended prematurely: %d", present);
+                    RETURN(RC_FAIL);
+                } else if(present == 0) {
+                    if(elm->default_value_set) {
+                        /* Fill-in DEFAULT */
+                        void *tmp;
+                        if(elm->default_value_set(
+                               element_ptrptr(st, elm, &tmp))) {
+                            RETURN(RC_FAIL);
+                        }
+                    }
+                    /* The member is not present. */
+                    continue;
+                }
+                /* Present OPTIONAL or DEFAULT component. */
+            }
+
+            /*
+             * MICROPHASE 2: Invoke the member-specific decoder.
+             */
+            ctx->step |= 1; /* Confirm entering next microphase */
+        microphase2_decode_continues:
+            if(elm->flags & ATF_OPEN_TYPE) {
+                rval = OPEN_TYPE_oer_get(opt_codec_ctx, td, st, elm, ptr, size);
+            } else {
+                void *save_memb_ptr; /* Temporary reference. */
+                void **memb_ptr2;  /* Pointer to a pointer to a memmber */
+
+                memb_ptr2 = element_ptrptr(st, elm, &save_memb_ptr);
+
+                rval = elm->type->op->oer_decoder(
+                    opt_codec_ctx, elm->type,
+                    elm->encoding_constraints.oer_constraints, memb_ptr2, ptr,
+                    size);
+            }
+            switch(rval.code) {
+            case RC_OK:
+                ADVANCE(rval.consumed);
+                break;
+            case RC_WMORE:
+                ASN_DEBUG("More bytes needed at element %s \"%s\"", td->name,
+                          elm->name);
+                ADVANCE(rval.consumed);
+                RETURN(RC_WMORE);
+            case RC_FAIL:
+                ASN_DEBUG("Decoding failed at element %s \"%s\"", td->name,
+                          elm->name);
+                RETURN(RC_FAIL);
+            }
+        } /* for(all root members) */
+
+    }
+        NEXT_PHASE(ctx);
+        /* FALL THROUGH */
+    case 2:
+        assert(ctx->ptr);
+        {
+        /* Cleanup preamble. */
+        asn_bit_data_t *preamble = ctx->ptr;
+        asn_bit_data_t *extadds;
+        int has_extensions_bit = (specs->first_extension >= 0);
+        int extensions_present =
+            has_extensions_bit
+            && (preamble->buffer == NULL
+                || (((const uint8_t *)preamble->buffer)[0] & 0x80));
+        uint8_t unused_bits;
+        size_t len = 0;
+        ssize_t len_len;
+
+        ASN_DEBUG("OER SEQUENCE %s Decoding PHASE 2", td->name);
+
+        preamble->buffer = 0; /* Will do extensions_present==1 next time. */
+
+        if(!extensions_present) {
+            ctx->phase = 10;
+            RETURN(RC_OK);
+        }
+
+        /*
+         * X.696 (08/2015) #16.1 (c), #16.4
+         * Read in the extension addition presence bitmap.
+         */
+
+        len_len = oer_fetch_length(ptr, size, &len);
+        if(len_len > 0) {
+            ADVANCE(len_len);
+        } else if(len_len < 0) {
+            RETURN(RC_FAIL);
+        } else {
+            RETURN(RC_WMORE);
+        }
+
+        if(len == 0) {
+            /* 16.4.1-2 */
+            RETURN(RC_FAIL);
+        } else if(len > size) {
+            RETURN(RC_WMORE);
+        }
+
+        /* Account for unused bits */
+        unused_bits = 0x7 & *(const uint8_t *)ptr;
+        ADVANCE(1);
+        len--;
+        if(unused_bits && len == 0) {
+            RETURN(RC_FAIL);
+        }
+
+        /* Get the extensions map */
+        extadds = asn_bit_data_new_contiguous(ptr, len * 8 - unused_bits);
+        if(!extadds) {
+            RETURN(RC_FAIL);
+        }
+        FREEMEM(preamble);
+        ctx->ptr = extadds;
+        ADVANCE(len);
+    }
+        NEXT_PHASE(ctx);
+        ctx->step =
+            (specs->first_extension < 0 ? td->elements_count
+                                        : (size_t)specs->first_extension);
+        /* Fall through */
+    case 3:
+        ASN_DEBUG("OER SEQUENCE %s Decoding PHASE 3 (Extensions)", td->name);
+        for(; ctx->step < (signed)td->elements_count; ctx->step++) {
+            asn_bit_data_t *extadds = ctx->ptr;
+            size_t edx = ctx->step;
+            asn_TYPE_member_t *elm = &td->elements[edx];
+            void *tmp_memb_ptr;
+            void **memb_ptr2 = element_ptrptr(st, elm, &tmp_memb_ptr);
+
+            switch(asn_get_few_bits(extadds, 1)) {
+            case -1:
+                /*
+                 * Not every one of our extensions is known to the remote side.
+                 * Continue filling in their defaults though.
+                 */
+                /* Fall through */
+            case 0:
+                /* Fill-in DEFAULT */
+                if(elm->default_value_set
+                   && elm->default_value_set(memb_ptr2)) {
+                    RETURN(RC_FAIL);
+                }
+                continue;
+            case 1: {
+                /* Read OER open type */
+                ssize_t ot_size =
+                    oer_open_type_get(opt_codec_ctx, elm->type,
+                                      elm->encoding_constraints.oer_constraints,
+                                      memb_ptr2, ptr, size);
+                assert(ot_size <= (ssize_t)size);
+                if(ot_size > 0) {
+                    ADVANCE(ot_size);
+                } else if(ot_size < 0) {
+                    RETURN(RC_FAIL);
+                } else {
+                    /* Roll back open type parsing */
+                    asn_get_undo(extadds, 1);
+                    RETURN(RC_WMORE);
+                }
+                break;
+            }
+            default:
+                RETURN(RC_FAIL);
+            }
+        }
+
+        NEXT_PHASE(ctx);
+        /* Fall through */
+    case 4:
+        ASN_DEBUG("OER SEQUENCE %s Decoding PHASE 4", td->name);
+        /* Read in the rest of Open Types while ignoring them */
+        for(;;) {
+            asn_bit_data_t *extadds = ctx->ptr;
+            switch(asn_get_few_bits(extadds, 1)) {
+            case 0:
+                continue;
+            case 1: {
+                ssize_t skipped = oer_open_type_skip(ptr, size);
+                if(skipped > 0) {
+                    ADVANCE(skipped);
+                } else if(skipped < 0) {
+                    RETURN(RC_FAIL);
+                } else {
+                    asn_get_undo(extadds, 1);
+                    RETURN(RC_WMORE);
+                }
+                continue;
+            }
+            case -1:
+                /* No more Open Type encoded components */
+                break;
+            default:
+                RETURN(RC_FAIL);
+            }
+            break;
+        }
+    }
+
+    RETURN(RC_OK);
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+SEQUENCE_encode_oer(const asn_TYPE_descriptor_t *td,
+                    const asn_oer_constraints_t *constraints, const void *sptr,
+                    asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_SEQUENCE_specifics_t *specs = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    size_t computed_size = 0;
+    int has_extensions_bit = (specs->first_extension >= 0);
+    size_t preamble_bits = (has_extensions_bit + specs->roms_count);
+    uint32_t has_extensions = 0;
+    size_t edx;
+    int ret;
+
+    (void)constraints;
+
+    if(preamble_bits) {
+        asn_bit_outp_t preamble;
+
+        memset(&preamble, 0, sizeof(preamble));
+        preamble.output = cb;
+        preamble.op_key = app_key;
+
+        if(has_extensions_bit) {
+            for(edx = specs->first_extension; edx < td->elements_count; edx++) {
+                asn_TYPE_member_t *elm = &td->elements[edx];
+                const void *memb_ptr = element_ptr(sptr, elm);
+                if(memb_ptr) {
+                    if(elm->default_value_cmp
+                       && elm->default_value_cmp(memb_ptr) == 0) {
+                        /* Do not encode default values in extensions */
+                    } else {
+                        has_extensions = 1;
+                        break;
+                    }
+                }
+            }
+            ret = asn_put_few_bits(&preamble, has_extensions, 1);
+            assert(ret == 0);
+            if(ret < 0) {
+                ASN__ENCODE_FAILED;
+            }
+        }
+
+        /*
+         * Encode optional components bitmap.
+         */
+        if(specs->roms_count) {
+            FOR_IN_ROOT_GROUP(edx) {
+                asn_TYPE_member_t *elm = &td->elements[edx];
+
+                if(IN_EXTENSION_GROUP(specs, edx)) break;
+
+                if(elm->optional) {
+                    const void *memb_ptr = element_ptr(sptr, elm);
+                    uint32_t has_component = memb_ptr != NULL;
+                    if(has_component && elm->default_value_cmp
+                       && elm->default_value_cmp(memb_ptr) == 0) {
+                        has_component = 0;
+                    }
+                    ret = asn_put_few_bits(&preamble, has_component, 1);
+                    if(ret < 0) {
+                        ASN__ENCODE_FAILED;
+                    }
+                }
+            }
+        }
+
+        asn_put_aligned_flush(&preamble);
+        computed_size += preamble.flushed_bytes;
+    }   /* if(preamble_bits) */
+
+    /*
+     * Put root components and extensions root.
+     */
+    for(edx = 0; edx < td->elements_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        asn_enc_rval_t er = {0,0,0};
+        const void *memb_ptr;
+
+        if(IN_EXTENSION_GROUP(specs, edx)) break;
+
+        memb_ptr = element_ptr(sptr, elm);
+        if(memb_ptr) {
+            if(elm->default_value_cmp
+               && elm->default_value_cmp(memb_ptr) == 0) {
+                /* Skip default values in encoding */
+                continue;
+            }
+        } else {
+            if(elm->optional) continue;
+            /* Mandatory element is missing */
+            ASN__ENCODE_FAILED;
+        }
+        if(!elm->type->op->oer_encoder) {
+            ASN_DEBUG("OER encoder is not defined for type %s", elm->type->name);
+            ASN__ENCODE_FAILED;
+        }
+        er = elm->type->op->oer_encoder(
+            elm->type, elm->encoding_constraints.oer_constraints, memb_ptr, cb,
+            app_key);
+        if(er.encoded == -1) {
+            ASN_DEBUG("... while encoding %s member \"%s\"\n", td->name,
+                      elm->name);
+            return er;
+        }
+        computed_size += er.encoded;
+    }
+
+    /*
+     * Before encode extensions, encode extensions additions presence bitmap
+     # X.696 (08/2015) #16.4.
+     */
+    if(has_extensions) {
+        asn_bit_outp_t extadds;
+
+        /* Special case allowing us to use exactly one byte for #8.6 */
+        size_t aoms_length_bits = specs->aoms_count;
+        size_t aoms_length_bytes = (7 + aoms_length_bits) >> 3;
+        uint8_t unused_bits = 0x07 & (8 - (aoms_length_bits & 0x07));
+
+        assert(1 + aoms_length_bytes <= 127);
+
+        memset(&extadds, 0, sizeof(extadds));
+        extadds.output = cb;
+        extadds.op_key = app_key;
+
+        /* #8.6 length determinant */
+        ret = asn_put_few_bits(&extadds, (1 + aoms_length_bytes), 8);
+        if(ret < 0) ASN__ENCODE_FAILED;
+
+        /* Number of unused bytes, #16.4.2 */
+        ret = asn_put_few_bits(&extadds, unused_bits, 8);
+        if(ret < 0) ASN__ENCODE_FAILED;
+
+        /* Encode presence bitmap #16.4.3 */
+        for(edx = specs->first_extension; edx < td->elements_count; edx++) {
+            asn_TYPE_member_t *elm = &td->elements[edx];
+            const void *memb_ptr = element_ptr(sptr, elm);
+            if(memb_ptr && elm->default_value_cmp
+               && elm->default_value_cmp(memb_ptr) == 0) {
+                memb_ptr = 0;   /* Do not encode default value. */
+            }
+            ret |= asn_put_few_bits(&extadds, memb_ptr ? 1 : 0, 1);
+        }
+        if(ret < 0) ASN__ENCODE_FAILED;
+
+        asn_put_aligned_flush(&extadds);
+        computed_size += extadds.flushed_bytes;
+
+        /* Now, encode extensions */
+        for(edx = specs->first_extension; edx < td->elements_count; edx++) {
+            asn_TYPE_member_t *elm = &td->elements[edx];
+            const void *memb_ptr = element_ptr(sptr, elm);
+
+            if(memb_ptr) {
+                if(elm->default_value_cmp
+                   && elm->default_value_cmp(memb_ptr) == 0) {
+                    /* Do not encode default value. */
+                } else {
+                    ssize_t wrote = oer_open_type_put(
+                        elm->type, elm->encoding_constraints.oer_constraints,
+                        memb_ptr, cb, app_key);
+                    if(wrote == -1) {
+                        ASN__ENCODE_FAILED;
+                    }
+                    computed_size += wrote;
+                }
+            } else if(!elm->optional) {
+                ASN__ENCODE_FAILED;
+            }
+        }
+    }   /* if(has_extensions) */
+
+
+    {
+        asn_enc_rval_t er = {0, 0, 0};
+        er.encoded = computed_size;
+        ASN__ENCODED_OK(er);
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_print.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_print.c
new file mode 100644
index 000000000..f6f74354f
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_print.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+
+int
+SEQUENCE_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+               asn_app_consume_bytes_f *cb, void *app_key) {
+    size_t edx;
+    int ret;
+
+    if(!sptr) return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+
+    /* Dump preamble */
+    if(cb(td->name, strlen(td->name), app_key) < 0
+    || cb(" ::= {", 6, app_key) < 0)
+        return -1;
+
+    for(edx = 0; edx < td->elements_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        const void *memb_ptr;
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr = *(const void * const *)((const char *)sptr + elm->memb_offset);
+            if(!memb_ptr) {
+                if(elm->optional) continue;
+                /* Print <absent> line */
+                /* Fall through */
+            }
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+        }
+
+        /* Indentation */
+        _i_INDENT(1);
+
+        /* Print the member's name and stuff */
+        if(cb(elm->name, strlen(elm->name), app_key) < 0
+        || cb(": ", 2, app_key) < 0)
+            return -1;
+
+        /* Print the member itself */
+        ret = elm->type->op->print_struct(elm->type, memb_ptr, ilevel + 1,
+                                          cb, app_key);
+        if(ret) return ret;
+    }
+
+    ilevel--;
+    _i_INDENT(1);
+
+    return (cb("}", 1, app_key) < 0) ? -1 : 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_rfill.c
new file mode 100644
index 000000000..a79d19c15
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_rfill.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+
+asn_random_fill_result_t
+SEQUENCE_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                   const asn_encoding_constraints_t *constr,
+                   size_t max_length) {
+    const asn_SEQUENCE_specifics_t *specs =
+        (const asn_SEQUENCE_specifics_t *)td->specifics;
+    asn_random_fill_result_t result_ok = {ARFILL_OK, 0};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    void *st = *sptr;
+    size_t edx;
+
+    if(max_length == 0) return result_skipped;
+
+    (void)constr;
+
+    if(st == NULL) {
+        st = CALLOC(1, specs->struct_size);
+        if(st == NULL) {
+            return result_failed;
+        }
+    }
+
+    for(edx = 0; edx < td->elements_count; edx++) {
+        const asn_TYPE_member_t *elm = &td->elements[edx];
+        void *memb_ptr;    /* Pointer to the member */
+        void **memb_ptr2;  /* Pointer to that pointer */
+        asn_random_fill_result_t tmpres;
+
+        if(elm->optional && asn_random_between(0, 4) == 2) {
+            /* Sometimes decide not to fill the optional value */
+            continue;
+        }
+
+        if(elm->flags & ATF_POINTER) {
+            /* Member is a pointer to another structure */
+            memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+        } else {
+            memb_ptr = (char *)st + elm->memb_offset;
+            memb_ptr2 = &memb_ptr;
+        }
+
+        tmpres = elm->type->op->random_fill(
+            elm->type, memb_ptr2, &elm->encoding_constraints,
+            max_length > result_ok.length ? max_length - result_ok.length : 0);
+        switch(tmpres.code) {
+        case ARFILL_OK:
+            result_ok.length += tmpres.length;
+            continue;
+        case ARFILL_SKIPPED:
+            assert(!(elm->flags & ATF_POINTER) || *memb_ptr2 == NULL);
+            continue;
+        case ARFILL_FAILED:
+            if(st == *sptr) {
+                ASN_STRUCT_RESET(*td, st);
+            } else {
+                ASN_STRUCT_FREE(*td, st);
+            }
+            return tmpres;
+        }
+    }
+
+    *sptr = st;
+
+    return result_ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_uper.c
new file mode 100644
index 000000000..f0a8dcf1d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_uper.c
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+#include "OPEN_TYPE.h"
+#include "uper_opentype.h"
+
+/*
+ * Check whether we are inside the extensions group.
+ */
+#define IN_EXTENSION_GROUP(specs, memb_idx)                \
+    ((specs)->first_extension >= 0                         \
+     && (unsigned)(specs)->first_extension <= (memb_idx))
+
+asn_dec_rval_t
+SEQUENCE_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td,
+                     const asn_per_constraints_t *constraints, void **sptr,
+                     asn_per_data_t *pd) {
+    const asn_SEQUENCE_specifics_t *specs = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    void *st = *sptr;  /* Target structure. */
+    int extpresent;    /* Extension additions are present */
+    uint8_t *opres;    /* Presence of optional root members */
+    asn_per_data_t opmd;
+    asn_dec_rval_t rv;
+    size_t edx;
+
+    (void)constraints;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    if(!st) {
+        st = *sptr = CALLOC(1, specs->struct_size);
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+    ASN_DEBUG("Decoding %s as SEQUENCE (UPER)", td->name);
+
+    /* Handle extensions */
+    if(specs->first_extension < 0) {
+        extpresent = 0;
+    } else {
+        extpresent = per_get_few_bits(pd, 1);
+        if(extpresent < 0) ASN__DECODE_STARVED;
+    }
+
+    /* Prepare a place and read-in the presence bitmap */
+    memset(&opmd, 0, sizeof(opmd));
+    if(specs->roms_count) {
+        opres = (uint8_t *)MALLOC(((specs->roms_count + 7) >> 3) + 1);
+        if(!opres) ASN__DECODE_FAILED;
+        /* Get the presence map */
+        if(per_get_many_bits(pd, opres, 0, specs->roms_count)) {
+            FREEMEM(opres);
+            ASN__DECODE_STARVED;
+        }
+        opmd.buffer = opres;
+        opmd.nbits = specs->roms_count;
+        ASN_DEBUG("Read in presence bitmap for %s of %d bits (%x..)",
+                  td->name, specs->roms_count, *opres);
+    } else {
+        opres = 0;
+    }
+
+    /*
+     * Get the sequence ROOT elements.
+     */
+    for(edx = 0;
+        edx < (specs->first_extension < 0 ? td->elements_count
+                                          : (size_t)specs->first_extension);
+        edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        void *memb_ptr;    /* Pointer to the member */
+        void **memb_ptr2;  /* Pointer to that pointer */
+
+        assert(!IN_EXTENSION_GROUP(specs, edx));
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+        } else {
+            memb_ptr = (char *)st + elm->memb_offset;
+            memb_ptr2 = &memb_ptr;
+        }
+
+        /* Deal with optionality */
+        if(elm->optional) {
+            int present = per_get_few_bits(&opmd, 1);
+            ASN_DEBUG("Member %s->%s is optional, p=%d (%d->%d)",
+                      td->name, elm->name, present,
+                      (int)opmd.nboff, (int)opmd.nbits);
+            if(present == 0) {
+                /* This element is not present */
+                if(elm->default_value_set) {
+                    /* Fill-in DEFAULT */
+                    if(elm->default_value_set(memb_ptr2)) {
+                        FREEMEM(opres);
+                        ASN__DECODE_FAILED;
+                    }
+                    ASN_DEBUG("Filled-in default");
+                }
+                /* The member is just not present */
+                continue;
+            }
+            /* Fall through */
+        }
+
+        /* Fetch the member from the stream */
+        ASN_DEBUG("Decoding member \"%s\" in %s", elm->name, td->name);
+
+        if(elm->flags & ATF_OPEN_TYPE) {
+            rv = OPEN_TYPE_uper_get(opt_codec_ctx, td, st, elm, pd);
+        } else {
+            rv = elm->type->op->uper_decoder(opt_codec_ctx, elm->type,
+                                             elm->encoding_constraints.per_constraints,
+                                             memb_ptr2, pd);
+        }
+        if(rv.code != RC_OK) {
+            ASN_DEBUG("Failed decode %s in %s",
+                      elm->name, td->name);
+            FREEMEM(opres);
+            return rv;
+        }
+    }
+
+    /* Optionality map is not needed anymore */
+    FREEMEM(opres);
+
+    /*
+     * Deal with extensions.
+     */
+    if(extpresent) {
+        ssize_t bmlength;
+        uint8_t *epres;  /* Presence of extension members */
+        asn_per_data_t epmd;
+
+        bmlength = uper_get_nslength(pd);
+        if(bmlength < 0) ASN__DECODE_STARVED;
+
+        ASN_DEBUG("Extensions %" ASN_PRI_SSIZE " present in %s", bmlength, td->name);
+
+        epres = (uint8_t *)MALLOC((bmlength + 15) >> 3);
+        if(!epres) ASN__DECODE_STARVED;
+
+        /* Get the extensions map */
+        if(per_get_many_bits(pd, epres, 0, bmlength)) {
+            FREEMEM(epres);
+            ASN__DECODE_STARVED;
+        }
+
+        memset(&epmd, 0, sizeof(epmd));
+        epmd.buffer = epres;
+        epmd.nbits = bmlength;
+        ASN_DEBUG("Read in extensions bitmap for %s of %ld bits (%x..)",
+                  td->name, (long)bmlength, *epres);
+
+        /* Go over extensions and read them in */
+        for(edx = specs->first_extension; edx < td->elements_count; edx++) {
+            asn_TYPE_member_t *elm = &td->elements[edx];
+            void *memb_ptr;    /* Pointer to the member */
+            void **memb_ptr2;  /* Pointer to that pointer */
+            int present;
+
+            /* Fetch the pointer to this member */
+            if(elm->flags & ATF_POINTER) {
+                memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+            } else {
+                memb_ptr = (void *)((char *)st + elm->memb_offset);
+                memb_ptr2 = &memb_ptr;
+            }
+
+            present = per_get_few_bits(&epmd, 1);
+            if(present <= 0) {
+                if(present < 0) break;  /* No more extensions */
+                continue;
+            }
+
+            ASN_DEBUG("Decoding member %s in %s %p", elm->name, td->name,
+                      *memb_ptr2);
+            rv = uper_open_type_get(opt_codec_ctx, elm->type,
+                                    elm->encoding_constraints.per_constraints,
+                                    memb_ptr2, pd);
+            if(rv.code != RC_OK) {
+                FREEMEM(epres);
+                return rv;
+            }
+        }
+
+        /* Skip over overflow extensions which aren't present
+         * in this system's version of the protocol */
+        for(;;) {
+            ASN_DEBUG("Getting overflow extensions");
+            switch(per_get_few_bits(&epmd, 1)) {
+            case -1: break;
+            case 0: continue;
+            default:
+                if(uper_open_type_skip(opt_codec_ctx, pd)) {
+                    FREEMEM(epres);
+                    ASN__DECODE_STARVED;
+                }
+                ASN_DEBUG("Skipped overflow extension");
+                continue;
+            }
+            break;
+        }
+
+        FREEMEM(epres);
+    }
+
+    if(specs->first_extension >= 0) {
+        unsigned i;
+        /* Fill DEFAULT members in extensions */
+        for(i = specs->roms_count; i < specs->roms_count + specs->aoms_count;
+            i++) {
+            asn_TYPE_member_t *elm;
+            void **memb_ptr2;  /* Pointer to member pointer */
+
+            edx = specs->oms[i];
+            elm = &td->elements[edx];
+
+            if(!elm->default_value_set) continue;
+
+            /* Fetch the pointer to this member */
+            if(elm->flags & ATF_POINTER) {
+                memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+                if(*memb_ptr2) continue;
+            } else {
+                continue;  /* Extensions are all optionals */
+            }
+
+            /* Set default value */
+            if(elm->default_value_set(memb_ptr2)) {
+                ASN__DECODE_FAILED;
+            }
+        }
+    }
+
+    rv.consumed = 0;
+    rv.code = RC_OK;
+    return rv;
+}
+
+static int
+SEQUENCE__handle_extensions(const asn_TYPE_descriptor_t *td, const void *sptr,
+                            asn_per_outp_t *po1, asn_per_outp_t *po2) {
+    const asn_SEQUENCE_specifics_t *specs =
+        (const asn_SEQUENCE_specifics_t *)td->specifics;
+    int exts_present = 0;
+    int exts_count = 0;
+    size_t edx;
+
+    if(specs->first_extension < 0) {
+        return 0;
+    }
+
+    /* Find out which extensions are present */
+    for(edx = specs->first_extension; edx < td->elements_count; edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        const void *memb_ptr;          /* Pointer to the member */
+        const void *const *memb_ptr2;  /* Pointer to that pointer */
+        int present;
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 =
+                (const void *const *)((const char *)sptr + elm->memb_offset);
+            present = (*memb_ptr2 != 0);
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+            present = 1;
+        }
+
+        ASN_DEBUG("checking %s:%s (@%" ASN_PRI_SIZE ") present => %d", elm->name,
+                  elm->type->name, edx, present);
+        exts_count++;
+        exts_present += present;
+
+        /* Encode as presence marker */
+        if(po1 && per_put_few_bits(po1, present, 1)) {
+            return -1;
+        }
+        /* Encode as open type field */
+        if(po2 && present
+           && uper_open_type_put(elm->type,
+                                 elm->encoding_constraints.per_constraints,
+                                 *memb_ptr2, po2))
+            return -1;
+    }
+
+    return exts_present ? exts_count : 0;
+}
+
+asn_enc_rval_t
+SEQUENCE_encode_uper(const asn_TYPE_descriptor_t *td,
+                     const asn_per_constraints_t *constraints, const void *sptr,
+                     asn_per_outp_t *po) {
+    const asn_SEQUENCE_specifics_t *specs
+        = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    asn_enc_rval_t er = {0,0,0};
+    int n_extensions;
+    size_t edx;
+    size_t i;
+
+    (void)constraints;
+
+    if(!sptr)
+        ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    ASN_DEBUG("Encoding %s as SEQUENCE (UPER)", td->name);
+
+    /*
+     * X.691#18.1 Whether structure is extensible
+     * and whether to encode extensions
+     */
+    if(specs->first_extension < 0) {
+        n_extensions = 0; /* There are no extensions to encode */
+    } else {
+        n_extensions = SEQUENCE__handle_extensions(td, sptr, 0, 0);
+        if(n_extensions < 0) ASN__ENCODE_FAILED;
+        if(per_put_few_bits(po, n_extensions ? 1 : 0, 1)) {
+            ASN__ENCODE_FAILED;
+        }
+    }
+
+    /* Encode a presence bitmap */
+    for(i = 0; i < specs->roms_count; i++) {
+        asn_TYPE_member_t *elm;
+        const void *memb_ptr;          /* Pointer to the member */
+        const void *const *memb_ptr2;  /* Pointer to that pointer */
+        int present;
+
+        edx = specs->oms[i];
+        elm = &td->elements[edx];
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 =
+                (const void *const *)((const char *)sptr + elm->memb_offset);
+            present = (*memb_ptr2 != 0);
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+            present = 1;
+        }
+
+        /* Eliminate default values */
+        if(present && elm->default_value_cmp
+           && elm->default_value_cmp(*memb_ptr2) == 0)
+            present = 0;
+
+        ASN_DEBUG("Element %s %s %s->%s is %s",
+                  elm->flags & ATF_POINTER ? "ptr" : "inline",
+                  elm->default_value_cmp ? "def" : "wtv",
+                  td->name, elm->name, present ? "present" : "absent");
+        if(per_put_few_bits(po, present, 1))
+            ASN__ENCODE_FAILED;
+    }
+
+    /*
+     * Encode the sequence ROOT elements.
+     */
+    ASN_DEBUG("first_extension = %d, elements = %d", specs->first_extension,
+              td->elements_count);
+    for(edx = 0;
+        edx < ((specs->first_extension < 0) ? td->elements_count
+                                            : (size_t)specs->first_extension);
+        edx++) {
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        const void *memb_ptr;          /* Pointer to the member */
+        const void *const *memb_ptr2;  /* Pointer to that pointer */
+
+        ASN_DEBUG("About to encode %s", elm->type->name);
+
+        /* Fetch the pointer to this member */
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr2 =
+                (const void *const *)((const char *)sptr + elm->memb_offset);
+            if(!*memb_ptr2) {
+                ASN_DEBUG("Element %s %" ASN_PRI_SIZE " not present",
+                    elm->name, edx);
+                if(elm->optional)
+                    continue;
+                /* Mandatory element is missing */
+                ASN__ENCODE_FAILED;
+            }
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+            memb_ptr2 = &memb_ptr;
+        }
+
+        /* Eliminate default values */
+        if(elm->default_value_cmp && elm->default_value_cmp(*memb_ptr2) == 0)
+            continue;
+
+        ASN_DEBUG("Encoding %s->%s:%s", td->name, elm->name, elm->type->name);
+        er = elm->type->op->uper_encoder(
+            elm->type, elm->encoding_constraints.per_constraints, *memb_ptr2,
+            po);
+        if(er.encoded == -1) return er;
+    }
+
+    /* No extensions to encode */
+    if(!n_extensions) ASN__ENCODED_OK(er);
+
+    ASN_DEBUG("Length of extensions %d bit-map", n_extensions);
+    /* #18.8. Write down the presence bit-map length. */
+    if(uper_put_nslength(po, n_extensions))
+        ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Bit-map of %d elements", n_extensions);
+    /* #18.7. Encoding the extensions presence bit-map. */
+    /* TODO: act upon NOTE in #18.7 for canonical PER */
+    if(SEQUENCE__handle_extensions(td, sptr, po, 0) != n_extensions)
+        ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Writing %d extensions", n_extensions);
+    /* #18.9. Encode extensions as open type fields. */
+    if(SEQUENCE__handle_extensions(td, sptr, 0, po) != n_extensions)
+        ASN__ENCODE_FAILED;
+
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_xer.c
new file mode 100644
index 000000000..ea91a7ed7
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SEQUENCE_xer.c
@@ -0,0 +1,348 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SEQUENCE.h"
+#include "OPEN_TYPE.h"
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+/*
+ * Check whether we are inside the extensions group.
+ */
+#define IN_EXTENSION_GROUP(specs, memb_idx)                \
+    ((specs)->first_extension >= 0                         \
+     && (unsigned)(specs)->first_extension <= (memb_idx))
+
+#undef XER_ADVANCE
+#define XER_ADVANCE(num_bytes)            \
+    do {                                  \
+        size_t num = (num_bytes);         \
+        ptr = ((const char *)ptr) + num;  \
+        size -= num;                      \
+        consumed_myself += num;           \
+    } while(0)
+
+/*
+ * Decode the XER (XML) data.
+ */
+asn_dec_rval_t
+SEQUENCE_decode_xer(const asn_codec_ctx_t *opt_codec_ctx,
+                    const asn_TYPE_descriptor_t *td, void **struct_ptr,
+                    const char *opt_mname, const void *ptr, size_t size) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_SEQUENCE_specifics_t *specs
+        = (const asn_SEQUENCE_specifics_t *)td->specifics;
+    asn_TYPE_member_t *elements = td->elements;
+    const char *xml_tag = opt_mname ? opt_mname : td->xml_tag;
+
+    /*
+     * ... and parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    asn_dec_rval_t rval;          /* Return value from a decoder */
+    ssize_t consumed_myself = 0;  /* Consumed bytes from ptr */
+    size_t edx;                   /* Element index */
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) RETURN(RC_FAIL);
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+
+    /*
+     * Phases of XER/XML processing:
+     * Phase 0: Check that the opening tag matches our expectations.
+     * Phase 1: Processing body and reacting on closing tag.
+     * Phase 2: Processing inner type.
+     * Phase 3: Skipping unknown extensions.
+     * Phase 4: PHASED OUT
+     */
+    for(edx = ctx->step; ctx->phase <= 3;) {
+        pxer_chunk_type_e ch_type;  /* XER chunk type */
+        ssize_t ch_size;            /* Chunk size */
+        xer_check_tag_e tcv;        /* Tag check value */
+        asn_TYPE_member_t *elm;
+
+        /*
+         * Go inside the inner member of a sequence.
+         */
+        if(ctx->phase == 2) {
+            asn_dec_rval_t tmprval;
+            void *memb_ptr_dontuse;  /* Pointer to the member */
+            void **memb_ptr2;        /* Pointer to that pointer */
+
+            elm = &td->elements[edx];
+
+            if(elm->flags & ATF_POINTER) {
+                /* Member is a pointer to another structure */
+                memb_ptr2 = (void **)((char *)st + elm->memb_offset);
+            } else {
+                memb_ptr_dontuse = (char *)st + elm->memb_offset;
+                memb_ptr2 = &memb_ptr_dontuse;  /* Only use of memb_ptr_dontuse */
+            }
+
+            if(elm->flags & ATF_OPEN_TYPE) {
+                tmprval = OPEN_TYPE_xer_get(opt_codec_ctx, td, st, elm, ptr, size);
+            } else {
+                /* Invoke the inner type decoder, m.b. multiple times */
+                tmprval = elm->type->op->xer_decoder(opt_codec_ctx,
+                                                     elm->type, memb_ptr2, elm->name,
+                                                     ptr, size);
+            }
+            XER_ADVANCE(tmprval.consumed);
+            if(tmprval.code != RC_OK)
+                RETURN(tmprval.code);
+            ctx->phase = 1;  /* Back to body processing */
+            ctx->step = ++edx;
+            ASN_DEBUG("XER/SEQUENCE phase => %d, step => %d",
+                ctx->phase, ctx->step);
+            /* Fall through */
+        }
+
+        /*
+         * Get the next part of the XML stream.
+         */
+        ch_size = xer_next_token(&ctx->context, ptr, size,
+            &ch_type);
+        if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+            switch(ch_type) {
+            case PXER_WMORE:
+                RETURN(RC_WMORE);
+            case PXER_COMMENT:  /* Got XML comment */
+            case PXER_TEXT:  /* Ignore free-standing text */
+                XER_ADVANCE(ch_size);  /* Skip silently */
+                continue;
+            case PXER_TAG:
+                break;  /* Check the rest down there */
+            }
+        }
+
+        tcv = xer_check_tag(ptr, ch_size, xml_tag);
+        ASN_DEBUG("XER/SEQUENCE: tcv = %d, ph=%d [%s]",
+                  tcv, ctx->phase, xml_tag);
+
+        /* Skip the extensions section */
+        if(ctx->phase == 3) {
+            switch(xer_skip_unknown(tcv, &ctx->left)) {
+            case -1:
+                ctx->phase = 4;
+                RETURN(RC_FAIL);
+            case 0:
+                XER_ADVANCE(ch_size);
+                continue;
+            case 1:
+                XER_ADVANCE(ch_size);
+                ctx->phase = 1;
+                continue;
+            case 2:
+                ctx->phase = 1;
+                break;
+            }
+        }
+
+        switch(tcv) {
+        case XCT_CLOSING:
+            if(ctx->phase == 0) break;
+            ctx->phase = 0;
+            /* Fall through */
+        case XCT_BOTH:
+            if(ctx->phase == 0) {
+                if(edx >= td->elements_count ||
+                   /* Explicit OPTIONAL specs reaches the end */
+                   (edx + elements[edx].optional == td->elements_count) ||
+                   /* All extensions are optional */
+                   IN_EXTENSION_GROUP(specs, edx)) {
+                    XER_ADVANCE(ch_size);
+                    ctx->phase = 4;  /* Phase out */
+                    RETURN(RC_OK);
+                } else {
+                    ASN_DEBUG("Premature end of XER SEQUENCE");
+                    RETURN(RC_FAIL);
+                }
+            }
+            /* Fall through */
+        case XCT_OPENING:
+            if(ctx->phase == 0) {
+                XER_ADVANCE(ch_size);
+                ctx->phase = 1;  /* Processing body phase */
+                continue;
+            }
+            /* Fall through */
+        case XCT_UNKNOWN_OP:
+        case XCT_UNKNOWN_BO:
+
+            ASN_DEBUG("XER/SEQUENCE: tcv=%d, ph=%d, edx=%" ASN_PRI_SIZE "",
+                      tcv, ctx->phase, edx);
+            if(ctx->phase != 1) {
+                break;  /* Really unexpected */
+            }
+
+            if(edx < td->elements_count) {
+                /*
+                 * Search which member corresponds to this tag.
+                 */
+                size_t n;
+                size_t edx_end = edx + elements[edx].optional + 1;
+                if(edx_end > td->elements_count)
+                    edx_end = td->elements_count;
+                for(n = edx; n < edx_end; n++) {
+                    elm = &td->elements[n];
+                    tcv = xer_check_tag(ptr, ch_size, elm->name);
+                    switch(tcv) {
+                    case XCT_BOTH:
+                    case XCT_OPENING:
+                        /*
+                         * Process this member.
+                         */
+                        ctx->step = edx = n;
+                        ctx->phase = 2;
+                        break;
+                    case XCT_UNKNOWN_OP:
+                    case XCT_UNKNOWN_BO:
+                        continue;
+                    default:
+                        n = edx_end;
+                        break;  /* Phase out */
+                    }
+                    break;
+                }
+                if(n != edx_end)
+                    continue;
+            } else {
+                ASN_DEBUG("Out of defined members: %" ASN_PRI_SIZE "/%u",
+                          edx, td->elements_count);
+            }
+
+            /* It is expected extension */
+            if(IN_EXTENSION_GROUP(specs,
+                edx + (edx < td->elements_count
+                    ? elements[edx].optional : 0))) {
+                ASN_DEBUG("Got anticipated extension at %" ASN_PRI_SIZE "",
+                          edx);
+                /*
+                 * Check for (XCT_BOTH or XCT_UNKNOWN_BO)
+                 * By using a mask. Only record a pure
+                 * <opening> tags.
+                 */
+                if(tcv & XCT_CLOSING) {
+                    /* Found </extension> without body */
+                } else {
+                    ctx->left = 1;
+                    ctx->phase = 3;  /* Skip ...'s */
+                }
+                XER_ADVANCE(ch_size);
+                continue;
+            }
+
+            /* Fall through */
+        default:
+            break;
+        }
+
+        ASN_DEBUG("Unexpected XML tag in SEQUENCE [%c%c%c%c%c%c]",
+                  size>0?((const char *)ptr)[0]:'.',
+                  size>1?((const char *)ptr)[1]:'.',
+                  size>2?((const char *)ptr)[2]:'.',
+                  size>3?((const char *)ptr)[3]:'.',
+                  size>4?((const char *)ptr)[4]:'.',
+                  size>5?((const char *)ptr)[5]:'.');
+        break;
+    }
+
+    ctx->phase = 4;  /* "Phase out" on hard failure */
+    RETURN(RC_FAIL);
+}
+
+asn_enc_rval_t
+SEQUENCE_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,
+                    int ilevel, enum xer_encoder_flags_e flags,
+                    asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0,0,0};
+    int xcan = (flags & XER_F_CANONICAL);
+    asn_TYPE_descriptor_t *tmp_def_val_td = 0;
+    void *tmp_def_val = 0;
+    size_t edx;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+
+    for(edx = 0; edx < td->elements_count; edx++) {
+        asn_enc_rval_t tmper = {0,0,0};
+        asn_TYPE_member_t *elm = &td->elements[edx];
+        const void *memb_ptr;
+        const char *mname = elm->name;
+        unsigned int mlen = strlen(mname);
+
+        if(elm->flags & ATF_POINTER) {
+            memb_ptr =
+                *(const void *const *)((const char *)sptr + elm->memb_offset);
+            if(!memb_ptr) {
+                assert(tmp_def_val == 0);
+                if(elm->default_value_set) {
+                    if(elm->default_value_set(&tmp_def_val)) {
+                        ASN__ENCODE_FAILED;
+                    } else {
+                        memb_ptr = tmp_def_val;
+                        tmp_def_val_td = elm->type;
+                    }
+                } else if(elm->optional) {
+                    continue;
+                } else {
+                    /* Mandatory element is missing */
+                    ASN__ENCODE_FAILED;
+                }
+            }
+        } else {
+            memb_ptr = (const void *)((const char *)sptr + elm->memb_offset);
+        }
+
+        if(!xcan) ASN__TEXT_INDENT(1, ilevel);
+        ASN__CALLBACK3("<", 1, mname, mlen, ">", 1);
+
+        /* Print the member itself */
+        tmper = elm->type->op->xer_encoder(elm->type, memb_ptr, ilevel + 1,
+                                           flags, cb, app_key);
+        if(tmp_def_val) {
+            ASN_STRUCT_FREE(*tmp_def_val_td, tmp_def_val);
+            tmp_def_val = 0;
+        }
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+
+        ASN__CALLBACK3("</", 2, mname, mlen, ">", 1);
+    }
+
+    if(!xcan) ASN__TEXT_INDENT(1, ilevel - 1);
+
+    ASN__ENCODED_OK(er);
+cb_failed:
+    if(tmp_def_val) ASN_STRUCT_FREE(*tmp_def_val_td, tmp_def_val);
+    ASN__ENCODE_FAILED;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF.c
new file mode 100644
index 000000000..eef20f41d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF.c
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+
+asn_TYPE_operation_t asn_OP_SET_OF = {
+    SET_OF_free,
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+    SET_OF_print,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+    SET_OF_compare,
+    SET_OF_copy,
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+    SET_OF_decode_ber,
+    SET_OF_encode_der,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+    SET_OF_decode_xer,
+    SET_OF_encode_xer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    SET_OF_decode_jer,
+    SET_OF_encode_jer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    SET_OF_decode_oer,
+    SET_OF_encode_oer,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+    SET_OF_decode_uper,
+    SET_OF_encode_uper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+    SET_OF_decode_aper,
+    SET_OF_encode_aper,
+#else
+    0,
+    0,
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+    SET_OF_random_fill,
+#else
+    0,
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+    0  /* Use generic outmost tag fetcher */
+};
+
+/* Append bytes to the above structure */
+static int _el_addbytes(const void *buffer, size_t size, void *el_buf_ptr) {
+    struct _el_buffer *el_buf = (struct _el_buffer *)el_buf_ptr;
+
+    if(el_buf->length + size > el_buf->allocated_size) {
+        size_t new_size = el_buf->allocated_size ? el_buf->allocated_size : 8;
+        void *p;
+
+        do {
+            new_size <<= 2;
+        } while(el_buf->length + size > new_size);
+
+        p = REALLOC(el_buf->buf, new_size);
+        if(p) {
+            el_buf->buf = p;
+            el_buf->allocated_size = new_size;
+        } else {
+            return -1;
+        }
+    }
+
+    memcpy(el_buf->buf + el_buf->length, buffer, size);
+
+    el_buf->length += size;
+    return 0;
+}
+
+static void assert_unused_bits(const struct _el_buffer* p) {
+    if(p->length) {
+        assert((p->buf[p->length-1] & ~(0xff << p->bits_unused)) == 0);
+    } else {
+        assert(p->bits_unused == 0);
+    }
+}
+
+static int _el_buf_cmp(const void *ap, const void *bp) {
+    const struct _el_buffer *a = (const struct _el_buffer *)ap;
+    const struct _el_buffer *b = (const struct _el_buffer *)bp;
+    size_t common_len;
+    int ret = 0;
+
+    if(a->length < b->length)
+        common_len = a->length;
+    else
+        common_len = b->length;
+
+    if (a->buf && b->buf) {
+        ret = memcmp(a->buf, b->buf, common_len);
+    }
+    if(ret == 0) {
+        if(a->length < b->length)
+            ret = -1;
+        else if(a->length > b->length)
+            ret = 1;
+        /* Ignore unused bits. */
+        assert_unused_bits(a);
+        assert_unused_bits(b);
+    }
+
+    return ret;
+}
+
+void
+SET_OF__encode_sorted_free(struct _el_buffer *el_buf, size_t count) {
+    size_t i;
+
+    for(i = 0; i < count; i++) {
+        FREEMEM(el_buf[i].buf);
+    }
+
+    FREEMEM(el_buf);
+}
+
+struct _el_buffer *
+SET_OF__encode_sorted(const asn_TYPE_member_t *elm,
+                      const asn_anonymous_set_ *list,
+                      enum SET_OF__encode_method method) {
+    struct _el_buffer *encoded_els;
+    int edx;
+
+    encoded_els =
+        (struct _el_buffer *)CALLOC(list->count, sizeof(encoded_els[0]));
+    if(encoded_els == NULL) {
+        return NULL;
+    }
+
+	/*
+	 * Encode all members.
+	 */
+    for(edx = 0; edx < list->count; edx++) {
+        const void *memb_ptr = list->array[edx];
+        struct _el_buffer *encoding_el = &encoded_els[edx];
+        asn_enc_rval_t erval = {0,0,0};
+
+        if(!memb_ptr) break;
+
+        /*
+		 * Encode the member into the prepared space.
+		 */
+        switch(method) {
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+        case SOES_DER:
+            erval = elm->type->op->der_encoder(elm->type, memb_ptr, 0, elm->tag,
+                                               _el_addbytes, encoding_el);
+            break;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+        case SOES_CUPER:
+            erval = uper_encode(elm->type,
+                                elm->encoding_constraints.per_constraints,
+                                memb_ptr, _el_addbytes, encoding_el);
+            if(erval.encoded != -1) {
+                size_t extra_bits = erval.encoded % 8;
+                assert(encoding_el->length == (size_t)(erval.encoded + 7) / 8);
+                encoding_el->bits_unused = (8 - extra_bits) & 0x7;
+            }
+            break;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+        case SOES_CAPER:
+            erval = aper_encode(elm->type,
+                                elm->encoding_constraints.per_constraints,
+                                memb_ptr, _el_addbytes, encoding_el);
+            if(erval.encoded != -1) {
+                size_t extra_bits = erval.encoded % 8;
+                assert(encoding_el->length == (size_t)(erval.encoded + 7) / 8);
+                encoding_el->bits_unused = (8 - extra_bits) & 0x7;
+            }
+            break;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+        default:
+            assert(!"Unreachable");
+            break;
+        }
+        if(erval.encoded < 0) break;
+	}
+
+    if(edx == list->count) {
+        /*
+         * Sort the encoded elements according to their encoding.
+         */
+        qsort(encoded_els, list->count, sizeof(encoded_els[0]), _el_buf_cmp);
+
+        return encoded_els;
+    } else {
+        SET_OF__encode_sorted_free(encoded_els, edx);
+        return NULL;
+    }
+}
+
+void
+SET_OF_free(const asn_TYPE_descriptor_t *td, void *ptr,
+            enum asn_struct_free_method method) {
+    if(td && ptr) {
+		const asn_SET_OF_specifics_t *specs;
+		asn_TYPE_member_t *elm = td->elements;
+		asn_anonymous_set_ *list = _A_SET_FROM_VOID(ptr);
+		asn_struct_ctx_t *ctx;	/* Decoder context */
+		int i;
+
+		/*
+		 * Could not use set_of_empty() because of (*free)
+		 * incompatibility.
+		 */
+		for(i = 0; i < list->count; i++) {
+			void *memb_ptr = list->array[i];
+			if(memb_ptr)
+			ASN_STRUCT_FREE(*elm->type, memb_ptr);
+		}
+		list->count = 0;	/* No meaningful elements left */
+
+		asn_set_empty(list);	/* Remove (list->array) */
+
+		specs = (const asn_SET_OF_specifics_t *)td->specifics;
+		ctx = (asn_struct_ctx_t *)((char *)ptr + specs->ctx_offset);
+		if(ctx->ptr) {
+			ASN_STRUCT_FREE(*elm->type, ctx->ptr);
+			ctx->ptr = 0;
+		}
+
+        switch(method) {
+        case ASFM_FREE_EVERYTHING:
+            FREEMEM(ptr);
+            break;
+        case ASFM_FREE_UNDERLYING:
+            break;
+        case ASFM_FREE_UNDERLYING_AND_RESET:
+            memset(ptr, 0, specs->struct_size);
+            break;
+        }
+    }
+}
+
+int
+SET_OF_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
+                  asn_app_constraint_failed_f *ctfailcb, void *app_key) {
+    const asn_TYPE_member_t *elm = td->elements;
+	asn_constr_check_f *constr;
+	const asn_anonymous_set_ *list = _A_CSET_FROM_VOID(sptr);
+	int i;
+
+	if(!sptr) {
+		ASN__CTFAIL(app_key, td, sptr,
+			"%s: value not given (%s:%d)",
+			td->name, __FILE__, __LINE__);
+		return -1;
+	}
+
+	constr = elm->encoding_constraints.general_constraints;
+	if(!constr) constr = elm->type->encoding_constraints.general_constraints;
+
+	/*
+	 * Iterate over the members of an array.
+	 * Validate each in turn, until one fails.
+	 */
+	for(i = 0; i < list->count; i++) {
+		const void *memb_ptr = list->array[i];
+		int ret;
+
+		if(!memb_ptr) continue;
+
+		ret = constr(elm->type, memb_ptr, ctfailcb, app_key);
+		if(ret) return ret;
+	}
+
+	return 0;
+}
+
+struct comparable_ptr {
+    const asn_TYPE_descriptor_t *td;
+    const void *sptr;
+};
+
+static int
+SET_OF__compare_cb(const void *aptr, const void *bptr) {
+    const struct comparable_ptr *a = aptr;
+    const struct comparable_ptr *b = bptr;
+    assert(a->td == b->td);
+    return a->td->op->compare_struct(a->td, a->sptr, b->sptr);
+}
+
+int
+SET_OF_compare(const asn_TYPE_descriptor_t *td, const void *aptr,
+               const void *bptr) {
+    const asn_anonymous_set_ *a = _A_CSET_FROM_VOID(aptr);
+    const asn_anonymous_set_ *b = _A_CSET_FROM_VOID(bptr);
+
+    if(a && b) {
+        struct comparable_ptr *asorted;
+        struct comparable_ptr *bsorted;
+        ssize_t common_length;
+        ssize_t idx;
+
+        if(a->count == 0) {
+            if(b->count) return -1;
+            return 0;
+        } else if(b->count == 0) {
+            return 1;
+        }
+
+        asorted = MALLOC(a->count * sizeof(asorted[0]));
+        bsorted = MALLOC(b->count * sizeof(bsorted[0]));
+        if(!asorted || !bsorted) {
+            FREEMEM(asorted);
+            FREEMEM(bsorted);
+            return -1;
+        }
+
+        for(idx = 0; idx < a->count; idx++) {
+            asorted[idx].td = td->elements->type;
+            asorted[idx].sptr = a->array[idx];
+        }
+
+        for(idx = 0; idx < b->count; idx++) {
+            bsorted[idx].td = td->elements->type;
+            bsorted[idx].sptr = b->array[idx];
+        }
+
+        qsort(asorted, a->count, sizeof(asorted[0]), SET_OF__compare_cb);
+        qsort(bsorted, b->count, sizeof(bsorted[0]), SET_OF__compare_cb);
+
+        common_length = (a->count < b->count ? a->count : b->count);
+        for(idx = 0; idx < common_length; idx++) {
+            int ret = td->elements->type->op->compare_struct(
+                td->elements->type, asorted[idx].sptr, bsorted[idx].sptr);
+            if(ret) {
+                FREEMEM(asorted);
+                FREEMEM(bsorted);
+                return ret;
+            }
+        }
+
+        FREEMEM(asorted);
+        FREEMEM(bsorted);
+
+        if(idx < b->count) /* more elements in b */
+            return -1;     /* a is shorter, so put it first */
+        if(idx < a->count) return 1;
+    } else if(!a) {
+        return -1;
+    } else if(!b) {
+        return 1;
+    }
+
+	return 0;
+}
+
+int
+SET_OF_copy(const asn_TYPE_descriptor_t *td, void **aptr,
+            const void *bptr) {
+    if(!td) return -1;
+
+    const asn_SET_OF_specifics_t *specs = 
+        (const asn_SET_OF_specifics_t *)td->specifics;
+    void *st = *aptr;
+
+    if(!bptr) {
+        if(*aptr) {
+            asn_set_empty(_A_SET_FROM_VOID(*aptr));
+            *aptr = 0;
+        }
+        return 0;
+    }
+
+    if(st == 0) {
+        st = *aptr = CALLOC(1, specs->struct_size);
+        if(st == 0) return -1;
+    }
+
+    asn_anonymous_set_ *a = _A_SET_FROM_VOID(*aptr);
+    const asn_anonymous_set_ *b = _A_CSET_FROM_VOID(bptr);
+
+    if(b->size) {
+		void *_new_arr;
+		_new_arr = REALLOC(a->array, b->size * sizeof(b->array[0]));
+		if(_new_arr) {
+			a->array = (void **)_new_arr;
+			a->size = b->size;
+		} else {
+            return -1;
+        }
+        a->count = b->count;
+
+        for(int i = 0; i < b->count; i++) {
+            void *bmemb = b->array[i];
+            if(bmemb) {
+                void *amemb = 0;
+                int ret;
+                ret = td->elements->type->op->copy_struct(
+                                                    td->elements->type,
+                                                    &amemb, bmemb);
+                if(ret != 0) return ret;
+                a->array[i] = amemb;
+            } else {
+                a->array[i] = 0;
+            }
+        }
+    }
+
+	return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF.h /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF.h
new file mode 100644
index 000000000..8b9454b17
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF.h
@@ -0,0 +1,104 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	CONSTR_SET_OF_H
+#define	CONSTR_SET_OF_H
+
+#include "asn_application.h"
+#include "asn_SET_OF.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct asn_SET_OF_specifics_s {
+    /*
+     * Target structure description.
+     */
+    unsigned struct_size;       /* Size of the target structure. */
+    unsigned ctx_offset;        /* Offset of the asn_struct_ctx_t member */
+
+    /* XER-specific stuff */
+    int as_XMLValueList; /* The member type must be encoded like this */
+} asn_SET_OF_specifics_t;
+
+/*
+ * A set specialized functions dealing with the SET OF type.
+ */
+asn_struct_free_f SET_OF_free;
+
+#if !defined(ASN_DISABLE_PRINT_SUPPORT)
+asn_struct_print_f SET_OF_print;
+#endif  /* !defined(ASN_DISABLE_PRINT_SUPPORT) */
+
+asn_struct_compare_f SET_OF_compare;
+asn_struct_copy_f    SET_OF_copy;
+
+asn_constr_check_f SET_OF_constraint;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+ber_type_decoder_f SET_OF_decode_ber;
+der_type_encoder_f SET_OF_encode_der;
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+xer_type_decoder_f SET_OF_decode_xer;
+xer_type_encoder_f SET_OF_encode_xer;
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+jer_type_decoder_f SET_OF_decode_jer;
+jer_type_encoder_f SET_OF_encode_jer;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+oer_type_decoder_f SET_OF_decode_oer;
+oer_type_encoder_f SET_OF_encode_oer;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT)
+per_type_decoder_f SET_OF_decode_uper;
+per_type_encoder_f SET_OF_encode_uper;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) */
+#if !defined(ASN_DISABLE_APER_SUPPORT)
+per_type_decoder_f SET_OF_decode_aper;
+per_type_encoder_f SET_OF_encode_aper;
+#endif  /* !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+asn_random_fill_f SET_OF_random_fill;
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+extern asn_TYPE_operation_t asn_OP_SET_OF;
+
+/*
+ * Internally visible buffer holding a single encoded element.
+ */
+struct _el_buffer {
+    uint8_t *buf;
+    size_t length;
+    size_t allocated_size;
+    unsigned bits_unused;
+};
+
+enum SET_OF__encode_method {
+    SOES_DER,   /* Distinguished Encoding Rules */
+    SOES_CUPER,  /* Canonical Unaligned Packed Encoding Rules */
+    SOES_CAPER  /* Canonical Aligned Packed Encoding Rules */
+};
+
+struct _el_buffer * SET_OF__encode_sorted(
+        const asn_TYPE_member_t *elm,
+        const asn_anonymous_set_ *list,
+        enum SET_OF__encode_method method);
+
+void SET_OF__encode_sorted_free(
+        struct _el_buffer *el_buf,
+        size_t count);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* CONSTR_SET_OF_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_aper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_aper.c
new file mode 100644
index 000000000..45288c73b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_aper.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+
+asn_enc_rval_t
+SET_OF_encode_aper(const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, const void *sptr,
+                   asn_per_outp_t *po) {
+    const asn_anonymous_set_ *list;
+    const asn_per_constraint_t *ct;
+    const asn_TYPE_member_t *elm = td->elements;
+    struct _el_buffer *encoded_els;
+    asn_enc_rval_t er = {0,0,0};
+    int seq;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    list = _A_CSET_FROM_VOID(sptr);
+
+    er.encoded = 0;
+
+    ASN_DEBUG("Encoding %s as SET OF (%d)", td->name, list->count);
+
+    if(constraints) ct = &constraints->size;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->size;
+    else ct = 0;
+
+    /* If extensible constraint, check if size is in root */
+    if(ct) {
+        int not_in_root =
+            (list->count < ct->lower_bound || list->count > ct->upper_bound);
+        ASN_DEBUG("lb %lld ub %lld %s",
+                  (long long int)ct->lower_bound,
+                  (long long int)ct->upper_bound,
+                  ct->flags & APC_EXTENSIBLE ? "ext" : "fix");
+        if(ct->flags & APC_EXTENSIBLE) {
+            /* Declare whether size is in extension root */
+            if(per_put_few_bits(po, not_in_root, 1)) ASN__ENCODE_FAILED;
+            if(not_in_root) ct = 0;
+        } else if(not_in_root && ct->effective_bits >= 0) {
+            ASN__ENCODE_FAILED;
+        }
+
+    }
+
+    if(ct && ct->effective_bits >= 0) {
+        /* X.691, #19.5: No length determinant */
+        /*if(per_put_few_bits(po, list->count - ct->lower_bound,
+                            ct->effective_bits))
+            ASN__ENCODE_FAILED;*/
+
+        if (aper_put_length(po, ct->lower_bound, ct->upper_bound, list->count - ct->lower_bound, 0) < 0) {
+            ASN__ENCODE_FAILED;
+        }
+    }
+
+    /*
+     * Canonical PER #22.1 mandates dynamic sorting of the SET OF elements
+     * according to their encodings. Build an array of the encoded elements.
+     */
+    encoded_els = SET_OF__encode_sorted(elm, list, SOES_CAPER);
+
+    for(seq = 0; seq < list->count;) {
+        ssize_t may_encode;
+        int need_eom = 0;
+        if(ct && ct->effective_bits >= 0) {
+            may_encode = list->count;
+        } else {
+            may_encode =
+                aper_put_length(po, -1, -1, list->count - seq, &need_eom);
+            if(may_encode < 0) ASN__ENCODE_FAILED;
+        }
+
+        while(may_encode--) {
+            const struct _el_buffer *el = &encoded_els[seq++];
+            if(asn_put_many_bits(po, el->buf,
+                                 (8 * el->length) - el->bits_unused) < 0) {
+                break;
+            }
+        }
+        if(need_eom && (aper_put_length(po, -1, -1, 0, NULL) < 0))
+            ASN__ENCODE_FAILED;  /* End of Message length */
+    }
+
+    SET_OF__encode_sorted_free(encoded_els, list->count);
+
+    ASN__ENCODED_OK(er);
+}
+
+asn_dec_rval_t
+SET_OF_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, void **sptr, asn_per_data_t *pd) {
+    asn_dec_rval_t rv = {RC_OK, 0};
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm = td->elements;  /* Single one */
+    void *st = *sptr;
+    asn_anonymous_set_ *list;
+    const asn_per_constraint_t *ct;
+    int repeat = 0;
+    ssize_t nelems;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(!st) {
+        st = *sptr = CALLOC(1, specs->struct_size);
+        if(!st) ASN__DECODE_FAILED;
+    }
+    list = _A_SET_FROM_VOID(st);
+
+    /* Figure out which constraints to use */
+    if(constraints) ct = &constraints->size;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->size;
+    else ct = 0;
+
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        int value = per_get_few_bits(pd, 1);
+        if(value < 0) ASN__DECODE_STARVED;
+        if(value) ct = 0;  /* Not restricted! */
+    }
+
+    if(ct && ct->upper_bound >= 1 && ct->upper_bound <= 65535
+       && ct->upper_bound == ct->lower_bound) {
+        /* X.691, #19.5: No length determinant */
+        nelems = ct->upper_bound;
+        ASN_DEBUG("Preparing to fetch %ld elements from %s",
+                  (long)nelems, td->name);
+    } else {
+        nelems = -1;
+    }
+
+    do {
+        int i;
+        if(nelems < 0) {
+            if (ct)
+                nelems = aper_get_length(pd, ct->lower_bound, ct->upper_bound,
+                                         ct->effective_bits, &repeat);
+            else
+                nelems = aper_get_length(pd, -1, -1, -1, &repeat);
+            ASN_DEBUG("Got to decode %d elements (eff %d)",
+                      (int)nelems, (int)(ct ? ct->effective_bits : -1));
+            if(nelems < 0) ASN__DECODE_STARVED;
+        }
+
+        for(i = 0; i < nelems; i++) {
+            void *ptr = 0;
+            ASN_DEBUG("SET OF %s decoding", elm->type->name);
+            rv = elm->type->op->aper_decoder(opt_codec_ctx, elm->type,
+                                             elm->encoding_constraints.per_constraints, &ptr, pd);
+            ASN_DEBUG("%s SET OF %s decoded %d, %p",
+                      td->name, elm->type->name, rv.code, ptr);
+            if(rv.code == RC_OK) {
+                if(ASN_SET_ADD(list, ptr) == 0)
+                    continue;
+                ASN_DEBUG("Failed to add element into %s",
+                          td->name);
+                /* Fall through */
+                rv.code = RC_FAIL;
+            } else {
+                ASN_DEBUG("Failed decoding %s of %s (SET OF)",
+                          elm->type->name, td->name);
+            }
+            if(ptr) ASN_STRUCT_FREE(*elm->type, ptr);
+            return rv;
+        }
+
+        nelems = -1;  /* Allow uper_get_length() */
+    } while(repeat);
+
+    ASN_DEBUG("Decoded %s as SET OF", td->name);
+
+    rv.code = RC_OK;
+    rv.consumed = 0;
+    return rv;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_ber.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_ber.c
new file mode 100644
index 000000000..3e4ab88ca
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_ber.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+#include "asn_SET_OF.h"
+
+/*
+ * Number of bytes left for this structure.
+ * (ctx->left) indicates the number of bytes _transferred_ for the structure.
+ * (size) contains the number of bytes in the buffer passed.
+ */
+#define LEFT ((size<(size_t)ctx->left)?size:(size_t)ctx->left)
+
+/*
+ * If the subprocessor function returns with an indication that it wants
+ * more data, it may well be a fatal decoding problem, because the
+ * size is constrained by the <TLV>'s L, even if the buffer size allows
+ * reading more data.
+ * For example, consider the buffer containing the following TLVs:
+ * <T:5><L:1><V> <T:6>...
+ * The TLV length clearly indicates that one byte is expected in V, but
+ * if the V processor returns with "want more data" even if the buffer
+ * contains way more data than the V processor have seen.
+ */
+#define SIZE_VIOLATION (ctx->left >= 0 && (size_t)ctx->left <= size)
+
+/*
+ * This macro "eats" the part of the buffer which is definitely "consumed",
+ * i.e. was correctly converted into local representation or rightfully skipped.
+ */
+#undef ADVANCE
+#define ADVANCE(num_bytes)                \
+    do {                                  \
+        size_t num = num_bytes;           \
+        ptr = ((const char *)ptr) + num;  \
+        size -= num;                      \
+        if(ctx->left >= 0)                \
+            ctx->left -= num;             \
+        consumed_myself += num;           \
+    } while(0)
+
+/*
+ * Switch to the next phase of parsing.
+ */
+#undef NEXT_PHASE
+#define NEXT_PHASE(ctx)  \
+    do {                 \
+        ctx->phase++;    \
+        ctx->step = 0;   \
+    } while(0)
+#undef PHASE_OUT
+#define PHASE_OUT(ctx)    \
+    do {                  \
+        ctx->phase = 10;  \
+    } while(0)
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+/*
+ * The decoder of the SET OF type.
+ */
+asn_dec_rval_t
+SET_OF_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td, void **struct_ptr,
+                  const void *ptr, size_t size, int tag_mode) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm = td->elements; /* Single one */
+
+    /*
+     * Parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    ber_tlv_tag_t tlv_tag;  /* T from TLV */
+    asn_dec_rval_t rval;    /* Return code from subparsers */
+
+    ssize_t consumed_myself = 0;  /* Consumed bytes from ptr */
+
+    ASN_DEBUG("Decoding %s as SET OF", td->name);
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) {
+            RETURN(RC_FAIL);
+        }
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Start to parse where left previously
+     */
+    switch(ctx->phase) {
+    case 0:
+        /*
+         * PHASE 0.
+         * Check that the set of tags associated with given structure
+         * perfectly fits our expectations.
+         */
+
+        rval = ber_check_tags(opt_codec_ctx, td, ctx, ptr, size,
+                              tag_mode, 1, &ctx->left, 0);
+        if(rval.code != RC_OK) {
+            ASN_DEBUG("%s tagging check failed: %d",
+                      td->name, rval.code);
+            return rval;
+        }
+
+        if(ctx->left >= 0)
+            ctx->left += rval.consumed;  /* ?Subtracted below! */
+        ADVANCE(rval.consumed);
+
+        ASN_DEBUG("Structure consumes %ld bytes, "
+                  "buffer %ld", (long)ctx->left, (long)size);
+
+        NEXT_PHASE(ctx);
+        /* Fall through */
+    case 1:
+        /*
+         * PHASE 1.
+         * From the place where we've left it previously,
+         * try to decode the next item.
+         */
+        for(;; ctx->step = 0) {
+            ssize_t tag_len;  /* Length of TLV's T */
+
+            if(ctx->step & 1)
+                goto microphase2;
+
+            /*
+             * MICROPHASE 1: Synchronize decoding.
+             */
+
+            if(ctx->left == 0) {
+                ASN_DEBUG("End of SET OF %s", td->name);
+                /*
+                 * No more things to decode.
+                 * Exit out of here.
+                 */
+                PHASE_OUT(ctx);
+                RETURN(RC_OK);
+            }
+
+            /*
+             * Fetch the T from TLV.
+             */
+            tag_len = ber_fetch_tag(ptr, LEFT, &tlv_tag);
+            switch(tag_len) {
+            case 0: if(!SIZE_VIOLATION) RETURN(RC_WMORE);
+                /* Fall through */
+            case -1: RETURN(RC_FAIL);
+            }
+
+            if(ctx->left < 0 && ((const uint8_t *)ptr)[0] == 0) {
+                if(LEFT < 2) {
+                    if(SIZE_VIOLATION)
+                        RETURN(RC_FAIL);
+                    else
+                        RETURN(RC_WMORE);
+                } else if(((const uint8_t *)ptr)[1] == 0) {
+                    /*
+                     * Found the terminator of the
+                     * indefinite length structure.
+                     */
+                    break;
+                }
+            }
+
+            /* Outmost tag may be unknown and cannot be fetched/compared */
+            if(elm->tag != (ber_tlv_tag_t)-1) {
+                if(BER_TAGS_EQUAL(tlv_tag, elm->tag)) {
+                /*
+                 * The new list member of expected type has arrived.
+                 */
+                } else {
+                    ASN_DEBUG("Unexpected tag %s fixed SET OF %s",
+                              ber_tlv_tag_string(tlv_tag), td->name);
+                    ASN_DEBUG("%s SET OF has tag %s",
+                              td->name, ber_tlv_tag_string(elm->tag));
+                    RETURN(RC_FAIL);
+                }
+            }
+
+            /*
+             * MICROPHASE 2: Invoke the member-specific decoder.
+             */
+            ctx->step |= 1;  /* Confirm entering next microphase */
+        microphase2:
+
+            /*
+             * Invoke the member fetch routine according to member's type
+             */
+            rval = elm->type->op->ber_decoder(opt_codec_ctx,
+                                              elm->type, &ctx->ptr,
+                                              ptr, LEFT, 0);
+            ASN_DEBUG("In %s SET OF %s code %d consumed %d",
+                      td->name, elm->type->name,
+                      rval.code, (int)rval.consumed);
+            switch(rval.code) {
+            case RC_OK:
+                {
+                    asn_anonymous_set_ *list = _A_SET_FROM_VOID(st);
+                    if(ASN_SET_ADD(list, ctx->ptr) != 0)
+                        RETURN(RC_FAIL);
+                    else
+                        ctx->ptr = 0;
+                }
+                break;
+            case RC_WMORE:  /* More data expected */
+                if(!SIZE_VIOLATION) {
+                    ADVANCE(rval.consumed);
+                    RETURN(RC_WMORE);
+                }
+                /* Fall through */
+            case RC_FAIL:  /* Fatal error */
+                ASN_STRUCT_FREE(*elm->type, ctx->ptr);
+                ctx->ptr = 0;
+                RETURN(RC_FAIL);
+            }  /* switch(rval) */
+
+            ADVANCE(rval.consumed);
+        }  /* for(all list members) */
+
+        NEXT_PHASE(ctx);
+    case 2:
+        /*
+         * Read in all "end of content" TLVs.
+         */
+        while(ctx->left < 0) {
+            if(LEFT < 2) {
+                if(LEFT > 0 && ((const char *)ptr)[0] != 0) {
+                    /* Unexpected tag */
+                    RETURN(RC_FAIL);
+                } else {
+                    RETURN(RC_WMORE);
+                }
+            }
+            if(((const char *)ptr)[0] == 0
+            && ((const char *)ptr)[1] == 0) {
+                ADVANCE(2);
+                ctx->left++;
+            } else {
+                RETURN(RC_FAIL);
+            }
+        }
+
+        PHASE_OUT(ctx);
+    }
+
+    RETURN(RC_OK);
+}
+
+/*
+ * The DER encoder of the SET OF type.
+ */
+asn_enc_rval_t
+SET_OF_encode_der(const asn_TYPE_descriptor_t *td, const void *sptr,
+                  int tag_mode, ber_tlv_tag_t tag, asn_app_consume_bytes_f *cb,
+                  void *app_key) {
+    const asn_TYPE_member_t *elm = td->elements;
+    const asn_anonymous_set_ *list = _A_CSET_FROM_VOID(sptr);
+    size_t computed_size = 0;
+    ssize_t encoding_size = 0;
+    struct _el_buffer *encoded_els;
+    int edx;
+
+    ASN_DEBUG("Estimating size for SET OF %s", td->name);
+
+    /*
+     * Gather the length of the underlying members sequence.
+     */
+    for(edx = 0; edx < list->count; edx++) {
+        void *memb_ptr = list->array[edx];
+        asn_enc_rval_t erval = {0,0,0};
+
+        if(!memb_ptr) ASN__ENCODE_FAILED;
+
+        erval =
+            elm->type->op->der_encoder(elm->type, memb_ptr, 0, elm->tag, 0, 0);
+        if(erval.encoded == -1) return erval;
+        computed_size += erval.encoded;
+    }
+
+    /*
+     * Encode the TLV for the sequence itself.
+     */
+    encoding_size =
+        der_write_tags(td, computed_size, tag_mode, 1, tag, cb, app_key);
+    if(encoding_size < 0) {
+        ASN__ENCODE_FAILED;
+    }
+    computed_size += encoding_size;
+
+    if(!cb || list->count == 0) {
+        asn_enc_rval_t erval = {0,0,0};
+        erval.encoded = computed_size;
+        ASN__ENCODED_OK(erval);
+    }
+
+    ASN_DEBUG("Encoding members of %s SET OF", td->name);
+
+    /*
+     * DER mandates dynamic sorting of the SET OF elements
+     * according to their encodings. Build an array of the
+     * encoded elements.
+     */
+    encoded_els = SET_OF__encode_sorted(elm, list, SOES_DER);
+
+    /*
+     * Report encoded elements to the application.
+     * Dispose of temporary sorted members table.
+     */
+    for(edx = 0; edx < list->count; edx++) {
+        struct _el_buffer *encoded_el = &encoded_els[edx];
+        /* Report encoded chunks to the application */
+        if(cb(encoded_el->buf, encoded_el->length, app_key) < 0) {
+            break;
+        } else {
+            encoding_size += encoded_el->length;
+        }
+    }
+
+    SET_OF__encode_sorted_free(encoded_els, list->count);
+
+    if(edx == list->count) {
+        asn_enc_rval_t erval = {0,0,0};
+        assert(computed_size == (size_t)encoding_size);
+        erval.encoded = computed_size;
+        ASN__ENCODED_OK(erval);
+    } else {
+        ASN__ENCODE_FAILED;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_jer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_jer.c
new file mode 100644
index 000000000..44a0d27da
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_jer.c
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+#undef JER_ADVANCE
+#define JER_ADVANCE(num_bytes)                    \
+    do {                                          \
+        size_t num = num_bytes;                   \
+        buf_ptr = ((const char *)buf_ptr) + num;  \
+        size -= num;                              \
+        consumed_myself += num;                   \
+    } while(0)
+
+/*
+ * Decode the JER (JSON) data.
+ */
+asn_dec_rval_t
+SET_OF_decode_jer(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td,
+                  const asn_jer_constraints_t *constraints,
+                  void **struct_ptr, const void *buf_ptr, size_t size) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *element = td->elements;
+
+    /*
+     * ... and parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    asn_dec_rval_t rval = {RC_OK, 0};  /* Return value from a decoder */
+    ssize_t consumed_myself = 0;       /* Consumed bytes from ptr */
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) RETURN(RC_FAIL);
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Phases of JER/JSON processing:
+     * Phase 0: Check that the opening tag matches our expectations.
+     * Phase 1: Processing body and reacting on closing token.
+     * Phase 2: Processing inner type.
+     */
+    for(; ctx->phase <= 2;) {
+        pjer_chunk_type_e ch_type;  /* JER chunk type */
+        ssize_t ch_size;            /* Chunk size */
+        jer_check_sym_e scv;        /* Tag check value */
+
+        /*
+         * Go inside the inner member of a set.
+         */
+        if(ctx->phase == 2) {
+            asn_dec_rval_t tmprval = {RC_OK, 0};
+
+            /* Invoke the inner type decoder, m.b. multiple times */
+            ASN_DEBUG("JER/SET OF element [%s]", 
+                    (*element->name) ? element->name : element->type->xml_tag);
+            tmprval = element->type->op->jer_decoder(opt_codec_ctx,
+                                                     element->type,
+                                                     element->encoding_constraints.jer_constraints,
+                                                     &ctx->ptr,
+                                                     buf_ptr, size);
+            if(tmprval.code == RC_OK) {
+                asn_anonymous_set_ *list = _A_SET_FROM_VOID(st);
+                if(ASN_SET_ADD(list, ctx->ptr) != 0)
+                    RETURN(RC_FAIL);
+                ctx->ptr = 0;
+                JER_ADVANCE(tmprval.consumed);
+            } else {
+                JER_ADVANCE(tmprval.consumed);
+                RETURN(tmprval.code);
+            }
+
+            ctx->phase = 1;  /* Back to body processing */
+            ASN_DEBUG("JER/SET OF phase => %d", ctx->phase);
+            /* Fall through */
+        }
+
+        /*
+         * Get the next part of the JSON stream.
+         */
+        ch_size = jer_next_token(&ctx->context,
+                                 buf_ptr, size, &ch_type);
+        if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+            switch(ch_type) {
+            case PJER_WMORE:
+                RETURN(RC_WMORE);
+            case PJER_TEXT:  
+                JER_ADVANCE(ch_size);
+                continue;
+
+            case PJER_DLM:
+            case PJER_VALUE:
+            case PJER_KEY:
+                break;  /* Check the rest down there */
+            }
+        }
+
+        scv = jer_check_sym(buf_ptr, ch_size, NULL);
+        ASN_DEBUG("JER/SET OF: scv = %d, ph=%d t=%s",
+                  scv, ctx->phase, td->name);
+        switch(scv) {
+        case JCK_AEND:
+            if(ctx->phase == 0) break;
+            ctx->phase = 0;
+
+            if(ctx->phase == 0) {
+                /* No more things to decode */
+                JER_ADVANCE(ch_size);
+                ctx->phase = 3;  /* Phase out */
+                RETURN(RC_OK);
+            }
+            /* Fall through */
+        case JCK_OEND:
+        case JCK_KEY:
+        case JCK_COMMA:
+        case JCK_ASTART:
+            if(ctx->phase == 0) {
+                JER_ADVANCE(ch_size);
+                ctx->phase = 1;  /* Processing body phase */
+                continue;
+            }
+            /* Fall through */
+        case JCK_UNKNOWN:
+        case JCK_OSTART:
+            ASN_DEBUG("JER/SET OF: scv=%d, ph=%d", scv, ctx->phase);
+            if(ctx->phase == 1) {
+                /*
+                 * Process a single possible member.
+                 */
+                ctx->phase = 2;
+                continue;
+            }
+            /* Fall through */
+        default:
+            break;
+        }
+
+        ASN_DEBUG("Unexpected JSON key in SET OF");
+        break;
+    }
+
+    ctx->phase = 3;  /* "Phase out" on hard failure */
+    RETURN(RC_FAIL);
+}
+
+asn_enc_rval_t
+SET_OF_encode_jer(const asn_TYPE_descriptor_t *td, 
+                  const asn_jer_constraints_t* constraints, const void *sptr, 
+                  int ilevel, enum jer_encoder_flags_e flags, 
+                  asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0,0,0};
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm = td->elements;
+    const asn_anonymous_set_ *list = _A_CSET_FROM_VOID(sptr);
+    int jmin = (flags & JER_F_MINIFIED);
+    int i;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    er.encoded = 0;
+    ASN__CALLBACK("[", 1);
+
+    for(i = 0; i < list->count; i++) {
+        asn_enc_rval_t tmper = {0,0,0};
+
+        void *memb_ptr = list->array[i];
+        if(!memb_ptr) continue;
+
+        if(!jmin) ASN__TEXT_INDENT(1, ilevel + 1);
+        tmper = elm->type->op->jer_encoder(elm->type, 
+                                           elm->encoding_constraints.jer_constraints, 
+                                           memb_ptr,
+                                           ilevel + (specs->as_XMLValueList != 2),
+                                           flags, cb, app_key);
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+        if(tmper.encoded == 0 && specs->as_XMLValueList) {
+            const char *name = elm->type->xml_tag;
+            size_t len = strlen(name);
+            ASN__CALLBACK3("\"", 1, name, len, "\"", 1);
+        }
+        if (i != list->count - 1) {
+          ASN__CALLBACK(",", 1);
+        }
+    }
+
+    if(!jmin) ASN__TEXT_INDENT(1, ilevel);
+    ASN__CALLBACK("]", 1);
+
+    goto cleanup;
+cb_failed:
+    ASN__ENCODE_FAILED;
+cleanup:
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_oer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_oer.c
new file mode 100644
index 000000000..c34b7ad1a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_oer.c
@@ -0,0 +1,281 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+#include "asn_SET_OF.h"
+#include <errno.h>
+
+/*
+ * This macro "eats" the part of the buffer which is definitely "consumed",
+ * i.e. was correctly converted into local representation or rightfully skipped.
+ */
+#undef  ADVANCE
+#define ADVANCE(num_bytes)                   \
+    do {                                     \
+        size_t num = num_bytes;              \
+        ptr = ((const char *)ptr) + num;     \
+        size -= num;                         \
+        consumed_myself += num;              \
+    } while(0)
+
+/*
+ * Switch to the next phase of parsing.
+ */
+#undef  NEXT_PHASE
+#define NEXT_PHASE(ctx) \
+    do {                \
+        ctx->phase++;   \
+        ctx->step = 0;  \
+    } while(0)
+#undef  SET_PHASE
+#define SET_PHASE(ctx, value) \
+    do {                      \
+        ctx->phase = value;   \
+        ctx->step = 0;        \
+    } while(0)
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef  RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        asn_dec_rval_t _rval;             \
+        _rval.code = _code;               \
+        _rval.consumed = consumed_myself; \
+        return _rval;                     \
+    } while(0)
+
+/*
+ * The SEQUENCE OF and SET OF values utilize a "quantity field".
+ * It is is a pointless combination of #8.6 (length determinant, capable
+ * of encoding tiny and huge numbers in the shortest possible number of octets)
+ * and the variable sized integer. What could have been encoded by #8.6 alone
+ * is required to be encoded by #8.6 followed by that number of unsigned octets.
+ * This doesn't make too much sense. It seems that the original version of OER
+ * standard have been using the unconstrained unsigned integer as a quantity
+ * field, and this legacy have gone through ISO/ITU-T standardization process.
+ */
+static ssize_t
+oer_fetch_quantity(const void *ptr, size_t size, size_t *qty_r) {
+    const uint8_t *b;
+    const uint8_t *bend;
+    size_t len = 0;
+    size_t qty;
+
+    ssize_t len_len = oer_fetch_length(ptr, size, &len);
+    if(len_len <= 0) {
+        *qty_r = 0;
+        return len_len;
+    }
+
+    if((len_len + len) > size) {
+        *qty_r = 0;
+        return 0;
+    }
+
+    b = (const uint8_t *)ptr + len_len;
+    bend = b + len;
+
+    /* Skip the leading 0-bytes */
+    for(; b < bend && *b == 0; b++) {
+    }
+
+    if((bend - b) > (ssize_t)sizeof(size_t)) {
+        /* Length is not representable by the native size_t type */
+        *qty_r = 0;
+        return -1;
+    }
+
+    for(qty = 0; b < bend; b++) {
+        qty = (qty << 8) + *b;
+    }
+
+    if(qty > RSIZE_MAX) { /* A bit of C11 validation */
+        *qty_r = 0;
+        return -1;
+    }
+
+    *qty_r = qty;
+    assert((size_t)len_len + len == (size_t)(bend - (const uint8_t *)ptr));
+    return len_len + len;
+}
+
+asn_dec_rval_t
+SET_OF_decode_oer(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td,
+                  const asn_oer_constraints_t *constraints, void **struct_ptr,
+                  const void *ptr, size_t size) {
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    asn_dec_rval_t rval = {RC_OK, 0};
+    void *st = *struct_ptr; /* Target structure */
+    asn_struct_ctx_t *ctx; /* Decoder context */
+    size_t consumed_myself = 0; /* Consumed bytes from ptr. */
+
+    (void)constraints;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) {
+            RETURN(RC_FAIL);
+        }
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Start to parse where left previously.
+     */
+    switch(ctx->phase) {
+    case 0: {
+        /*
+         * Fetch number of elements to decode.
+         */
+        size_t length = 0;
+        size_t len_size = oer_fetch_quantity(ptr, size, &length);
+        switch(len_size) {
+        case 0:
+            RETURN(RC_WMORE);
+        case -1:
+            RETURN(RC_FAIL);
+        default:
+            ADVANCE(len_size);
+            ctx->left = length;
+        }
+    }
+        NEXT_PHASE(ctx);
+        /* FALL THROUGH */
+    case 1: {
+        /* Decode components of the extension root */
+        asn_TYPE_member_t *elm = td->elements;
+        asn_anonymous_set_ *list = _A_SET_FROM_VOID(st);
+        const void *base_ptr = ptr;
+        ber_tlv_len_t base_ctx_left = ctx->left;
+
+        assert(td->elements_count == 1);
+
+        ASN_DEBUG("OER SET OF %s Decoding PHASE 1", td->name);
+
+        for(; ctx->left > 0; ctx->left--) {
+            asn_dec_rval_t rv = elm->type->op->oer_decoder(
+                opt_codec_ctx, elm->type,
+                elm->encoding_constraints.oer_constraints, &ctx->ptr, ptr,
+                size);
+            ADVANCE(rv.consumed);
+            switch(rv.code) {
+            case RC_OK:
+                if(ASN_SET_ADD(list, ctx->ptr) != 0) {
+                    RETURN(RC_FAIL);
+                } else {
+                    ctx->ptr = 0;
+                    /*
+                     * This check is to avoid compression bomb with
+                     * specs like SEQUENCE/SET OF NULL which don't
+                     * consume data at all.
+                     */
+                    if(rv.consumed == 0 && base_ptr == ptr
+                       && (base_ctx_left - ctx->left) > 200) {
+                        ASN__DECODE_FAILED;
+                    }
+                    break;
+                }
+            case RC_WMORE:
+                RETURN(RC_WMORE);
+            case RC_FAIL:
+                ASN_STRUCT_FREE(*elm->type, ctx->ptr);
+                ctx->ptr = 0;
+                SET_PHASE(ctx, 3);
+                RETURN(RC_FAIL);
+            }
+        }
+        /* Decoded decently. */
+        NEXT_PHASE(ctx);
+    }
+        /* Fall through */
+    case 2:
+        /* Ignore fully decoded */
+        assert(ctx->left == 0);
+        RETURN(RC_OK);
+    case 3:
+        /* Failed to decode. */
+        RETURN(RC_FAIL);
+    }
+
+    return rval;
+}
+
+static ssize_t
+oer_put_quantity(size_t qty, asn_app_consume_bytes_f *cb, void *app_key) {
+    uint8_t buf[1 + sizeof(size_t)];
+    uint8_t *b = &buf[sizeof(size_t)]; /* Last addressable */
+    size_t encoded;
+
+    do {
+        *b-- = qty;
+        qty >>= 8;
+    } while(qty);
+
+    *b = sizeof(buf) - (b-buf) - 1;
+    encoded = sizeof(buf) - (b-buf);
+    if(cb(b, encoded, app_key) < 0)
+        return -1;
+    return encoded;
+}
+
+/*
+ * Encode as Canonical OER.
+ */
+asn_enc_rval_t
+SET_OF_encode_oer(const asn_TYPE_descriptor_t *td,
+                  const asn_oer_constraints_t *constraints, const void *sptr,
+                  asn_app_consume_bytes_f *cb, void *app_key) {
+    const asn_TYPE_member_t *elm;
+    const asn_anonymous_set_ *list;
+    size_t computed_size = 0;
+    ssize_t qty_len;
+    int n;
+
+    (void)constraints;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    elm = td->elements;
+    list = _A_CSET_FROM_VOID(sptr);
+
+    qty_len = oer_put_quantity(list->count, cb, app_key);
+    if(qty_len < 0) {
+        ASN__ENCODE_FAILED;
+    }
+    computed_size += qty_len;
+
+    for(n = 0; n < list->count; n++) {
+        void *memb_ptr = list->array[n];
+        asn_enc_rval_t er = {0,0,0};
+        er = elm->type->op->oer_encoder(
+            elm->type, elm->encoding_constraints.oer_constraints, memb_ptr, cb,
+            app_key);
+        if(er.encoded < 0) {
+            return er;
+        } else {
+            computed_size += er.encoded;
+        }
+    }
+
+    {
+        asn_enc_rval_t erval = {0,0,0};
+        erval.encoded = computed_size;
+        ASN__ENCODED_OK(erval);
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_print.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_print.c
new file mode 100644
index 000000000..c0661b901
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_print.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+
+int
+SET_OF_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+             asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_TYPE_member_t *elm = td->elements;
+    const asn_anonymous_set_ *list = _A_CSET_FROM_VOID(sptr);
+    int ret;
+    int i;
+
+    if(!sptr) return (cb("<absent>", 8, app_key) < 0) ? -1 : 0;
+
+    /* Dump preamble */
+    if(cb(td->name, strlen(td->name), app_key) < 0
+    || cb(" ::= {", 6, app_key) < 0)
+        return -1;
+
+    for(i = 0; i < list->count; i++) {
+        const void *memb_ptr = list->array[i];
+        if(!memb_ptr) continue;
+
+        _i_INDENT(1);
+
+        ret = elm->type->op->print_struct(elm->type, memb_ptr,
+                                          ilevel + 1, cb, app_key);
+        if(ret) return ret;
+    }
+
+    ilevel--;
+    _i_INDENT(1);
+
+    return (cb("}", 1, app_key) < 0) ? -1 : 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_rfill.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_rfill.c
new file mode 100644
index 000000000..06963a533
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_rfill.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+
+asn_random_fill_result_t
+SET_OF_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,
+                   const asn_encoding_constraints_t *constraints,
+                   size_t max_length) {
+    const asn_SET_OF_specifics_t *specs =
+        (const asn_SET_OF_specifics_t *)td->specifics;
+    asn_random_fill_result_t res_ok = {ARFILL_OK, 0};
+    asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};
+    asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};
+    const asn_TYPE_member_t *elm = td->elements;
+    void *st = *sptr;
+    long max_elements = 5;
+    long slb = 0;  /* Lower size bound */
+    long sub = 0;  /* Upper size bound */
+    size_t rnd_len;
+
+    if(max_length == 0) return result_skipped;
+
+    if(st == NULL) {
+        st = (*sptr = CALLOC(1, specs->struct_size));
+        if(st == NULL) {
+            return result_failed;
+        }
+    }
+
+    switch(asn_random_between(0, 6)) {
+    case 0: max_elements = 0; break;
+    case 1: max_elements = 1; break;
+    case 2: max_elements = 5; break;
+    case 3: max_elements = max_length; break;
+    case 4: max_elements = max_length / 2; break;
+    case 5: max_elements = max_length / 4; break;
+    default: break;
+    }
+    sub = slb + max_elements;
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+    if(!constraints || !constraints->per_constraints)
+        constraints = &td->encoding_constraints;
+    if(constraints->per_constraints) {
+        const asn_per_constraint_t *pc = &constraints->per_constraints->size;
+        if(pc->flags & APC_SEMI_CONSTRAINED) {
+            slb = pc->lower_bound;
+            sub = pc->lower_bound + max_elements;
+        } else if(pc->flags & APC_CONSTRAINED) {
+            slb = pc->lower_bound;
+            sub = pc->upper_bound;
+            if(sub - slb > max_elements) sub = slb + max_elements;
+        }
+    }
+#else
+    if(!constraints) constraints = &td->encoding_constraints;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+
+    /* Bias towards edges of allowed space */
+    switch(asn_random_between(-1, 4)) {
+    default:
+    case -1:
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+        /* Prepare lengths somewhat outside of constrained range. */
+        if(constraints->per_constraints
+           && (constraints->per_constraints->size.flags & APC_EXTENSIBLE)) {
+            switch(asn_random_between(0, 5)) {
+            default:
+            case 0:
+                rnd_len = 0;
+                break;
+            case 1:
+                if(slb > 0) {
+                    rnd_len = slb - 1;
+                } else {
+                    rnd_len = 0;
+                }
+                break;
+            case 2:
+                rnd_len = asn_random_between(0, slb);
+                break;
+            case 3:
+                if(sub < (ssize_t)max_length) {
+                    rnd_len = sub + 1;
+                } else {
+                    rnd_len = max_length;
+                }
+                break;
+            case 4:
+                if(sub < (ssize_t)max_length) {
+                    rnd_len = asn_random_between(sub + 1, max_length);
+                } else {
+                    rnd_len = max_length;
+                }
+                break;
+            case 5:
+                rnd_len = max_length;
+                break;
+            }
+            break;
+        }
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+        /* Fall through */
+    case 0:
+        rnd_len = asn_random_between(slb, sub);
+        break;
+    case 1:
+        if(slb < sub) {
+            rnd_len = asn_random_between(slb + 1, sub);
+            break;
+        }
+        /* Fall through */
+    case 2:
+        rnd_len = asn_random_between(slb, slb);
+        break;
+    case 3:
+        if(slb < sub) {
+            rnd_len = asn_random_between(slb, sub - 1);
+            break;
+        }
+        /* Fall through */
+    case 4:
+        rnd_len = asn_random_between(sub, sub);
+        break;
+    }
+
+    for(; rnd_len > 0; rnd_len--) {
+        asn_anonymous_set_ *list = _A_SET_FROM_VOID(st);
+        void *ptr = 0;
+        asn_random_fill_result_t tmpres = elm->type->op->random_fill(
+            elm->type, &ptr, &elm->encoding_constraints,
+            (max_length > res_ok.length ? max_length - res_ok.length : 0)
+                / rnd_len);
+        switch(tmpres.code) {
+        case ARFILL_OK:
+            ASN_SET_ADD(list, ptr);
+            res_ok.length += tmpres.length;
+            break;
+        case ARFILL_SKIPPED:
+            break;
+        case ARFILL_FAILED:
+            assert(ptr == 0);
+            return tmpres;
+        }
+    }
+
+    return res_ok;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_uper.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_uper.c
new file mode 100644
index 000000000..9dbd88708
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_uper.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+
+asn_dec_rval_t
+SET_OF_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,
+                   const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, void **sptr,
+                   asn_per_data_t *pd) {
+    asn_dec_rval_t rv = {RC_OK, 0};
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm = td->elements;  /* Single one */
+    void *st = *sptr;
+    asn_anonymous_set_ *list;
+    const asn_per_constraint_t *ct;
+    int repeat = 0;
+    ssize_t nelems;
+
+    if(ASN__STACK_OVERFLOW_CHECK(opt_codec_ctx))
+        ASN__DECODE_FAILED;
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(!st) {
+        st = *sptr = CALLOC(1, specs->struct_size);
+        if(!st) ASN__DECODE_FAILED;
+    }
+    list = _A_SET_FROM_VOID(st);
+
+    /* Figure out which constraints to use */
+    if(constraints) ct = &constraints->size;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->size;
+    else ct = 0;
+
+    if(ct && ct->flags & APC_EXTENSIBLE) {
+        int value = per_get_few_bits(pd, 1);
+        if(value < 0) ASN__DECODE_STARVED;
+        if(value) ct = 0;  /* Not restricted! */
+    }
+
+    if(ct && ct->effective_bits >= 0) {
+        /* X.691, #19.5: No length determinant */
+        nelems = per_get_few_bits(pd, ct->effective_bits);
+        ASN_DEBUG("Preparing to fetch %ld+%"ASN_PRIdMAX" elements from %s",
+                  (long)nelems, ct->lower_bound, td->name);
+        if(nelems < 0)  ASN__DECODE_STARVED;
+        nelems += ct->lower_bound;
+    } else {
+        nelems = -1;
+    }
+
+    do {
+        int i;
+        if(nelems < 0) {
+            nelems = uper_get_length(pd, -1, 0, &repeat);
+            ASN_DEBUG("Got to decode %" ASN_PRI_SSIZE " elements (eff %d)",
+                      nelems, (int)(ct ? ct->effective_bits : -1));
+            if(nelems < 0) ASN__DECODE_STARVED;
+        }
+
+        for(i = 0; i < nelems; i++) {
+            void *ptr = 0;
+            ASN_DEBUG("SET OF %s decoding", elm->type->name);
+            rv = elm->type->op->uper_decoder(opt_codec_ctx, elm->type,
+                                             elm->encoding_constraints.per_constraints,
+                                             &ptr, pd);
+            ASN_DEBUG("%s SET OF %s decoded %d, %p",
+                      td->name, elm->type->name, rv.code, ptr);
+            if(rv.code == RC_OK) {
+                if(ASN_SET_ADD(list, ptr) == 0) {
+                    if(rv.consumed == 0 && nelems > 200) {
+                        /* Protect from SET OF NULL compression bombs. */
+                        ASN__DECODE_FAILED;
+                    }
+                    continue;
+                }
+                ASN_DEBUG("Failed to add element into %s",
+                          td->name);
+                /* Fall through */
+                rv.code = RC_FAIL;
+            } else {
+                ASN_DEBUG("Failed decoding %s of %s (SET OF)",
+                          elm->type->name, td->name);
+            }
+            if(ptr) ASN_STRUCT_FREE(*elm->type, ptr);
+            return rv;
+        }
+
+        nelems = -1;  /* Allow uper_get_length() */
+    } while(repeat);
+
+    ASN_DEBUG("Decoded %s as SET OF", td->name);
+
+    rv.code = RC_OK;
+    rv.consumed = 0;
+    return rv;
+}
+
+asn_enc_rval_t
+SET_OF_encode_uper(const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, const void *sptr,
+                   asn_per_outp_t *po) {
+    const asn_anonymous_set_ *list;
+    const asn_per_constraint_t *ct;
+    const asn_TYPE_member_t *elm = td->elements;
+    struct _el_buffer *encoded_els;
+    asn_enc_rval_t er = {0,0,0};
+    size_t encoded_edx;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    list = _A_CSET_FROM_VOID(sptr);
+
+    er.encoded = 0;
+
+    ASN_DEBUG("Encoding %s as SEQUENCE OF (%d)", td->name, list->count);
+
+    if(constraints) ct = &constraints->size;
+    else if(td->encoding_constraints.per_constraints)
+        ct = &td->encoding_constraints.per_constraints->size;
+    else ct = 0;
+
+    /* If extensible constraint, check if size is in root */
+    if(ct) {
+        int not_in_root =
+            (list->count < ct->lower_bound || list->count > ct->upper_bound);
+        ASN_DEBUG("lb %"ASN_PRIdMAX" ub %"ASN_PRIdMAX" %s", ct->lower_bound, ct->upper_bound,
+                  ct->flags & APC_EXTENSIBLE ? "ext" : "fix");
+        if(ct->flags & APC_EXTENSIBLE) {
+            /* Declare whether size is in extension root */
+            if(per_put_few_bits(po, not_in_root, 1)) ASN__ENCODE_FAILED;
+            if(not_in_root) ct = 0;
+        } else if(not_in_root && ct->effective_bits >= 0) {
+            ASN__ENCODE_FAILED;
+        }
+
+    }
+
+    if(ct && ct->effective_bits >= 0) {
+        /* X.691, #19.5: No length determinant */
+        if(per_put_few_bits(po, list->count - ct->lower_bound,
+                            ct->effective_bits))
+            ASN__ENCODE_FAILED;
+    } else if(list->count == 0) {
+        /* When the list is empty add only the length determinant
+         * X.691, #20.6 and #11.9.4.1
+         */
+        if (uper_put_length(po, 0, 0)) {
+            ASN__ENCODE_FAILED;
+        }
+        ASN__ENCODED_OK(er);
+    }
+
+
+    /*
+     * Canonical UPER #22.1 mandates dynamic sorting of the SET OF elements
+     * according to their encodings. Build an array of the encoded elements.
+     */
+    encoded_els = SET_OF__encode_sorted(elm, list, SOES_CUPER);
+
+    for(encoded_edx = 0; (ssize_t)encoded_edx < list->count;) {
+        ssize_t may_encode;
+        size_t edx;
+        int need_eom = 0;
+
+        if(ct && ct->effective_bits >= 0) {
+            may_encode = list->count;
+        } else {
+            may_encode =
+                uper_put_length(po, list->count - encoded_edx, &need_eom);
+            if(may_encode < 0) ASN__ENCODE_FAILED;
+        }
+
+        for(edx = encoded_edx; edx < encoded_edx + may_encode; edx++) {
+            const struct _el_buffer *el = &encoded_els[edx];
+            if(asn_put_many_bits(po, el->buf,
+                                 (8 * el->length) - el->bits_unused) < 0) {
+                break;
+            }
+        }
+
+        if(need_eom && uper_put_length(po, 0, 0))
+            ASN__ENCODE_FAILED;  /* End of Message length */
+
+        encoded_edx += may_encode;
+    }
+
+    SET_OF__encode_sorted_free(encoded_els, list->count);
+
+    if((ssize_t)encoded_edx == list->count) {
+        ASN__ENCODED_OK(er);
+    } else {
+        ASN__ENCODE_FAILED;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_xer.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_xer.c
new file mode 100644
index 000000000..8781dacb3
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_SET_OF_xer.c
@@ -0,0 +1,314 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_SET_OF.h"
+
+/*
+ * Return a standardized complex structure.
+ */
+#undef RETURN
+#define RETURN(_code)                     \
+    do {                                  \
+        rval.code = _code;                \
+        rval.consumed = consumed_myself;  \
+        return rval;                      \
+    } while(0)
+
+#undef XER_ADVANCE
+#define XER_ADVANCE(num_bytes)                    \
+    do {                                          \
+        size_t num = num_bytes;                   \
+        buf_ptr = ((const char *)buf_ptr) + num;  \
+        size -= num;                              \
+        consumed_myself += num;                   \
+    } while(0)
+
+/*
+ * Decode the XER (XML) data.
+ */
+asn_dec_rval_t
+SET_OF_decode_xer(const asn_codec_ctx_t *opt_codec_ctx,
+                  const asn_TYPE_descriptor_t *td, void **struct_ptr,
+                  const char *opt_mname, const void *buf_ptr, size_t size) {
+    /*
+     * Bring closer parts of structure description.
+     */
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *element = td->elements;
+    const char *elm_tag;
+    const char *xml_tag = opt_mname ? opt_mname : td->xml_tag;
+
+    /*
+     * ... and parts of the structure being constructed.
+     */
+    void *st = *struct_ptr;  /* Target structure. */
+    asn_struct_ctx_t *ctx;   /* Decoder context */
+
+    asn_dec_rval_t rval = {RC_OK, 0};  /* Return value from a decoder */
+    ssize_t consumed_myself = 0;       /* Consumed bytes from ptr */
+
+    /*
+     * Create the target structure if it is not present already.
+     */
+    if(st == 0) {
+        st = *struct_ptr = CALLOC(1, specs->struct_size);
+        if(st == 0) RETURN(RC_FAIL);
+    }
+
+    /* Which tag is expected for the downstream */
+    if(specs->as_XMLValueList) {
+        elm_tag = (specs->as_XMLValueList == 1) ? 0 : "";
+    } else {
+        elm_tag = (*element->name)
+                ? element->name : element->type->xml_tag;
+    }
+
+    /*
+     * Restore parsing context.
+     */
+    ctx = (asn_struct_ctx_t *)((char *)st + specs->ctx_offset);
+
+    /*
+     * Phases of XER/XML processing:
+     * Phase 0: Check that the opening tag matches our expectations.
+     * Phase 1: Processing body and reacting on closing tag.
+     * Phase 2: Processing inner type.
+     */
+    for(; ctx->phase <= 2;) {
+        pxer_chunk_type_e ch_type;  /* XER chunk type */
+        ssize_t ch_size;            /* Chunk size */
+        xer_check_tag_e tcv;        /* Tag check value */
+
+        /*
+         * Go inside the inner member of a set.
+         */
+        if(ctx->phase == 2) {
+            asn_dec_rval_t tmprval = {RC_OK, 0};
+
+            /* Invoke the inner type decoder, m.b. multiple times */
+            ASN_DEBUG("XER/SET OF element [%s]", elm_tag);
+            tmprval = element->type->op->xer_decoder(opt_codec_ctx,
+                                                     element->type,
+                                                     &ctx->ptr, elm_tag,
+                                                     buf_ptr, size);
+            if(tmprval.code == RC_OK) {
+                asn_anonymous_set_ *list = _A_SET_FROM_VOID(st);
+                if(ASN_SET_ADD(list, ctx->ptr) != 0)
+                    RETURN(RC_FAIL);
+                ctx->ptr = 0;
+                XER_ADVANCE(tmprval.consumed);
+            } else {
+                XER_ADVANCE(tmprval.consumed);
+                RETURN(tmprval.code);
+            }
+            ctx->phase = 1;  /* Back to body processing */
+            ASN_DEBUG("XER/SET OF phase => %d", ctx->phase);
+            /* Fall through */
+        }
+
+        /*
+         * Get the next part of the XML stream.
+         */
+        ch_size = xer_next_token(&ctx->context,
+                                 buf_ptr, size, &ch_type);
+        if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+            switch(ch_type) {
+            case PXER_WMORE:
+                RETURN(RC_WMORE);
+            case PXER_COMMENT:  /* Got XML comment */
+            case PXER_TEXT:  /* Ignore free-standing text */
+                XER_ADVANCE(ch_size);  /* Skip silently */
+                continue;
+            case PXER_TAG:
+                break;  /* Check the rest down there */
+            }
+        }
+
+        tcv = xer_check_tag(buf_ptr, ch_size, xml_tag);
+        ASN_DEBUG("XER/SET OF: tcv = %d, ph=%d t=%s",
+                  tcv, ctx->phase, xml_tag);
+        switch(tcv) {
+        case XCT_CLOSING:
+            if(ctx->phase == 0) break;
+            ctx->phase = 0;
+            /* Fall through */
+        case XCT_BOTH:
+            if(ctx->phase == 0) {
+                /* No more things to decode */
+                XER_ADVANCE(ch_size);
+                ctx->phase = 3;  /* Phase out */
+                RETURN(RC_OK);
+            }
+            /* Fall through */
+        case XCT_OPENING:
+            if(ctx->phase == 0) {
+                XER_ADVANCE(ch_size);
+                ctx->phase = 1;  /* Processing body phase */
+                continue;
+            }
+            /* Fall through */
+        case XCT_UNKNOWN_OP:
+        case XCT_UNKNOWN_BO:
+
+            ASN_DEBUG("XER/SET OF: tcv=%d, ph=%d", tcv, ctx->phase);
+            if(ctx->phase == 1) {
+                /*
+                 * Process a single possible member.
+                 */
+                ctx->phase = 2;
+                continue;
+            }
+            /* Fall through */
+        default:
+            break;
+        }
+
+        ASN_DEBUG("Unexpected XML tag in SET OF");
+        break;
+    }
+
+    ctx->phase = 3;  /* "Phase out" on hard failure */
+    RETURN(RC_FAIL);
+}
+
+typedef struct xer_tmp_enc_s {
+    void *buffer;
+    size_t offset;
+    size_t size;
+} xer_tmp_enc_t;
+
+static int
+SET_OF_encode_xer_callback(const void *buffer, size_t size, void *key) {
+    xer_tmp_enc_t *t = (xer_tmp_enc_t *)key;
+    if(t->offset + size >= t->size) {
+        size_t newsize = (t->size << 2) + size;
+        void *p = REALLOC(t->buffer, newsize);
+        if(!p) return -1;
+        t->buffer = p;
+        t->size = newsize;
+    }
+    memcpy((char *)t->buffer + t->offset, buffer, size);
+    t->offset += size;
+    return 0;
+}
+
+static int
+SET_OF_xer_order(const void *aptr, const void *bptr) {
+    const xer_tmp_enc_t *a = (const xer_tmp_enc_t *)aptr;
+    const xer_tmp_enc_t *b = (const xer_tmp_enc_t *)bptr;
+    size_t minlen = a->offset;
+    int ret;
+    if(b->offset < minlen) minlen = b->offset;
+    /* Well-formed UTF-8 has this nice lexicographical property... */
+    ret = memcmp(a->buffer, b->buffer, minlen);
+    if(ret != 0) return ret;
+    if(a->offset == b->offset)
+        return 0;
+    if(a->offset == minlen)
+        return -1;
+    return 1;
+}
+
+asn_enc_rval_t
+SET_OF_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,
+                  enum xer_encoder_flags_e flags, asn_app_consume_bytes_f *cb,
+                  void *app_key) {
+    asn_enc_rval_t er = {0,0,0};
+    const asn_SET_OF_specifics_t *specs = (const asn_SET_OF_specifics_t *)td->specifics;
+    const asn_TYPE_member_t *elm = td->elements;
+    const asn_anonymous_set_ *list = _A_CSET_FROM_VOID(sptr);
+    const char *mname = specs->as_XMLValueList
+        ? 0 : ((*elm->name) ? elm->name : elm->type->xml_tag);
+    size_t mlen = mname ? strlen(mname) : 0;
+    int xcan = (flags & XER_F_CANONICAL);
+    xer_tmp_enc_t *encs = 0;
+    size_t encs_count = 0;
+    void *original_app_key = app_key;
+    asn_app_consume_bytes_f *original_cb = cb;
+    int i;
+
+    if(!sptr) ASN__ENCODE_FAILED;
+
+    if(xcan) {
+        encs = (xer_tmp_enc_t *)MALLOC(list->count * sizeof(encs[0]));
+        if(!encs) ASN__ENCODE_FAILED;
+        cb = SET_OF_encode_xer_callback;
+    }
+
+    er.encoded = 0;
+
+    for(i = 0; i < list->count; i++) {
+        asn_enc_rval_t tmper = {0,0,0};
+
+        void *memb_ptr = list->array[i];
+        if(!memb_ptr) continue;
+
+        if(encs) {
+            memset(&encs[encs_count], 0, sizeof(encs[0]));
+            app_key = &encs[encs_count];
+            encs_count++;
+        }
+
+        if(mname) {
+            if(!xcan) ASN__TEXT_INDENT(1, ilevel);
+            ASN__CALLBACK3("<", 1, mname, mlen, ">", 1);
+        }
+
+        if(!xcan && specs->as_XMLValueList == 1)
+            ASN__TEXT_INDENT(1, ilevel + 1);
+        tmper = elm->type->op->xer_encoder(elm->type, memb_ptr,
+                                           ilevel + (specs->as_XMLValueList != 2),
+                                           flags, cb, app_key);
+        if(tmper.encoded == -1) return tmper;
+        er.encoded += tmper.encoded;
+        if(tmper.encoded == 0 && specs->as_XMLValueList) {
+            const char *name = elm->type->xml_tag;
+            size_t len = strlen(name);
+            ASN__CALLBACK3("<", 1, name, len, "/>", 2);
+        }
+
+        if(mname) {
+            ASN__CALLBACK3("</", 2, mname, mlen, ">", 1);
+        }
+
+    }
+
+    if(!xcan) ASN__TEXT_INDENT(1, ilevel - 1);
+
+    if(encs) {
+        xer_tmp_enc_t *enc = encs;
+        xer_tmp_enc_t *end = encs + encs_count;
+        ssize_t control_size = 0;
+
+        er.encoded = 0;
+        cb = original_cb;
+        app_key = original_app_key;
+        qsort(encs, encs_count, sizeof(encs[0]), SET_OF_xer_order);
+
+        for(; enc < end; enc++) {
+            ASN__CALLBACK(enc->buffer, enc->offset);
+            FREEMEM(enc->buffer);
+            enc->buffer = 0;
+            control_size += enc->offset;
+        }
+        assert(control_size == er.encoded);
+    }
+
+    goto cleanup;
+cb_failed:
+    ASN__ENCODE_FAILED;
+cleanup:
+    if(encs) {
+        size_t n;
+        for(n = 0; n < encs_count; n++) {
+            FREEMEM(encs[n].buffer);
+        }
+        FREEMEM(encs);
+    }
+    ASN__ENCODED_OK(er);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_TYPE.c /ext/source/modules/EVSE/EvseV2G/asn1/constr_TYPE.c
new file mode 100644
index 000000000..fb316cc35
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_TYPE.c
@@ -0,0 +1,100 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "constr_TYPE.h"
+#include <errno.h>
+
+/*
+ * Version of the ASN.1 infrastructure shipped with compiler.
+ */
+int get_asn1c_environment_version(void) { return ASN1C_ENVIRONMENT_VERSION; }
+
+static asn_app_consume_bytes_f _print2fp;
+
+/*
+ * Return the outmost tag of the type.
+ */
+ber_tlv_tag_t
+asn_TYPE_outmost_tag(const asn_TYPE_descriptor_t *type_descriptor,
+		const void *struct_ptr, int tag_mode, ber_tlv_tag_t tag) {
+
+	if(tag_mode)
+		return tag;
+
+	if(type_descriptor->tags_count)
+		return type_descriptor->tags[0];
+
+	return type_descriptor->op->outmost_tag(type_descriptor, struct_ptr, 0, 0);
+}
+
+/*
+ * Print the target language's structure in human readable form.
+ */
+int
+asn_fprint(FILE *stream, const asn_TYPE_descriptor_t *td,
+           const void *struct_ptr) {
+    if(!stream) stream = stdout;
+    if(!td || !struct_ptr) {
+        errno = EINVAL;
+        return -1;
+	}
+
+	/* Invoke type-specific printer */
+    if(td->op->print_struct(td, struct_ptr, 1, _print2fp, stream)) {
+        return -1;
+    }
+
+    /* Terminate the output */
+    if(_print2fp("\n", 1, stream)) {
+        return -1;
+    }
+
+    return fflush(stream);
+}
+
+/*
+ * Copy a structuture.
+ */
+int
+asn_copy(const asn_TYPE_descriptor_t *td,
+         void **struct_dst, const void *struct_src) {
+
+    if(!td || !struct_dst || !struct_src) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if(!td->op) {
+        errno = ENOSYS;
+        return -1;
+    }
+    
+    return td->op->copy_struct(td, struct_dst, struct_src);
+}
+
+/* Dump the data into the specified stdio stream */
+static int
+_print2fp(const void *buffer, size_t size, void *app_key) {
+	FILE *stream = (FILE *)app_key;
+
+	if(fwrite(buffer, 1, size, stream) != size)
+		return -1;
+
+	return 0;
+}
+
+
+/*
+ * Some compilers do not support variable args macros.
+ * This function is a replacement of ASN_DEBUG() macro.
+ */
+void CC_PRINTFLIKE(1, 2) ASN_DEBUG_f(const char *fmt, ...);
+void ASN_DEBUG_f(const char *fmt, ...) {
+	va_list ap;
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	fprintf(stderr, "\n");
+	va_end(ap);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constr_TYPE.h /ext/source/modules/EVSE/EvseV2G/asn1/constr_TYPE.h
new file mode 100644
index 000000000..e0d28fdd4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constr_TYPE.h
@@ -0,0 +1,323 @@
+/*
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+/*
+ * This file contains the declaration structure called "ASN.1 Type Definition",
+ * which holds all information necessary for encoding and decoding routines.
+ * This structure even contains pointer to these encoding and decoding routines
+ * for each defined ASN.1 type.
+ */
+#ifndef	_CONSTR_TYPE_H_
+#define	_CONSTR_TYPE_H_
+
+#include "ber_tlv_length.h"
+#include "ber_tlv_tag.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+struct asn_TYPE_member_s;	/* Forward declaration */
+
+/*
+ * This type provides the context information for various ASN.1 routines,
+ * primarily ones doing decoding. A member _asn_ctx of this type must be
+ * included into certain target language's structures, such as compound types.
+ */
+typedef struct asn_struct_ctx_s {
+	short phase;		/* Decoding phase */
+	short step;		/* Elementary step of a phase */
+	int context;		/* Other context information */
+	void *ptr;		/* Decoder-specific stuff (stack elements) */
+	ber_tlv_len_t left;	/* Number of bytes left, -1 for indefinite */
+} asn_struct_ctx_t;
+
+#if !defined(ASN_DISABLE_BER_SUPPORT)
+#include "ber_decoder.h"  /* Basic Encoding Rules decoder */
+#include "der_encoder.h"  /* Distinguished Encoding Rules encoder */
+#else
+typedef void (ber_type_decoder_f)(void);
+typedef void (der_type_encoder_f)(void);
+#endif  /* !defined(ASN_DISABLE_BER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_XER_SUPPORT)
+#include "xer_decoder.h"  /* Decoder of XER (XML, text) */
+#include "xer_encoder.h"  /* Encoder into XER (XML, text) */
+#else
+typedef void (xer_type_decoder_f)(void);
+typedef void (xer_type_encoder_f)(void);
+#endif  /* !defined(ASN_DISABLE_XER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+#include "jer_decoder.h"  /* Decoder of JER (JSON, text) */
+#include "jer_encoder.h"  /* Encoder into JER (JSON, text) */
+#else
+typedef void (jer_type_decoder_f)(void);
+typedef void (jer_type_encoder_f)(void);
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+#include "per_decoder.h"  /* Packet Encoding Rules decoder */
+#include "per_encoder.h"  /* Packet Encoding Rules encoder */
+#else
+typedef void (per_type_decoder_f)(void);
+typedef void (per_type_encoder_f)(void);
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+
+#include "constraints.h"  /* Subtype constraints support */
+
+#if !defined(ASN_DISABLE_RFILL_SUPPORT)
+#include "asn_random_fill.h"  /* Random structures support */
+#else
+typedef void (asn_random_fill_f)(void);
+#endif  /* !defined(ASN_DISABLE_RFILL_SUPPORT) */
+
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+#include "oer_decoder.h"  /* Octet Encoding Rules encoder */
+#include "oer_encoder.h"  /* Octet Encoding Rules encoder */
+#else
+typedef void (oer_type_decoder_f)(void);
+typedef void (oer_type_encoder_f)(void);
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+
+/*
+ * Free the structure according to its specification.
+ * Use one of ASN_STRUCT_{FREE,RESET,CONTENTS_ONLY} macros instead.
+ * Do not use directly.
+ */
+enum asn_struct_free_method {
+    ASFM_FREE_EVERYTHING,   /* free(struct_ptr) and underlying members */
+    ASFM_FREE_UNDERLYING,   /* free underlying members */
+    ASFM_FREE_UNDERLYING_AND_RESET   /* FREE_UNDERLYING + memset(0) */
+};
+typedef void (asn_struct_free_f)(
+		const struct asn_TYPE_descriptor_s *type_descriptor,
+		void *struct_ptr, enum asn_struct_free_method);
+
+/*
+ * Free the structure including freeing the memory pointed to by ptr itself.
+ */
+#define ASN_STRUCT_FREE(asn_DEF, ptr) \
+    (asn_DEF).op->free_struct(&(asn_DEF), (ptr), ASFM_FREE_EVERYTHING)
+
+/*
+ * Free the memory used by the members of the structure without freeing the
+ * the structure pointer itself.
+ * ZERO-OUT the structure to the safe clean state.
+ * (Retaining the pointer may be useful in case the structure is allocated
+ *  statically or arranged on the stack, yet its elements are dynamic.)
+ */
+#define ASN_STRUCT_RESET(asn_DEF, ptr) \
+    (asn_DEF).op->free_struct(&(asn_DEF), (ptr), ASFM_FREE_UNDERLYING_AND_RESET)
+
+/*
+ * Free memory used by the members of the structure without freeing
+ * the structure pointer itself.
+ * (Retaining the pointer may be useful in case the structure is allocated
+ *  statically or arranged on the stack, yet its elements are dynamic.)
+ * AVOID using it in the application code;
+ * Use a safer ASN_STRUCT_RESET() instead.
+ */
+#define ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF, ptr) \
+    (asn_DEF).op->free_struct(&(asn_DEF), (ptr), ASFM_FREE_UNDERLYING)
+
+/*
+ * Print the structure according to its specification.
+ */
+typedef int(asn_struct_print_f)(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const void *struct_ptr,
+    int level, /* Indentation level */
+    asn_app_consume_bytes_f *callback, void *app_key);
+
+/*
+ * Compare two structs between each other.
+ * Returns <0 if struct_A is "smaller" than struct_B, >0 if "greater",
+ * and =0 if "equal to", for some type-specific, stable definition of
+ * "smaller", "greater" and "equal to".
+ */
+typedef int (asn_struct_compare_f)(
+		const struct asn_TYPE_descriptor_s *type_descriptor,
+		const void *struct_A,
+		const void *struct_B);
+
+/*
+ * Copies struct B into struct A.
+ * Allocates memory for struct A, if necessary.
+ */
+typedef int (asn_struct_copy_f)(
+		const struct asn_TYPE_descriptor_s *type_descriptor,
+		void **struct_A,
+		const void *struct_B
+        );
+
+/*
+ * Return the outmost tag of the type.
+ * If the type is untagged CHOICE, the dynamic operation is performed.
+ * NOTE: This function pointer type is only useful internally.
+ * Do not use it in your application.
+ */
+typedef ber_tlv_tag_t (asn_outmost_tag_f)(
+		const struct asn_TYPE_descriptor_s *type_descriptor,
+		const void *struct_ptr, int tag_mode, ber_tlv_tag_t tag);
+/* The instance of the above function type; used internally. */
+asn_outmost_tag_f asn_TYPE_outmost_tag;
+
+/*
+ * Fetch the desired type of the Open Type based on the
+ * Information Object Set driven constraints.
+ */
+typedef struct asn_type_selector_result_s {
+    const struct asn_TYPE_descriptor_s *type_descriptor; /* Type encoded. */
+    unsigned presence_index; /* Associated choice variant. */
+} asn_type_selector_result_t;
+typedef asn_type_selector_result_t(asn_type_selector_f)(
+    const struct asn_TYPE_descriptor_s *parent_type_descriptor,
+    const void *parent_structure_ptr);
+
+/*
+ * Generalized functions for dealing with the speciic type.
+ * May be directly invoked by applications.
+ */
+typedef struct asn_TYPE_operation_s {
+    asn_struct_free_f *free_struct;     /* Free the structure */
+    asn_struct_print_f *print_struct;   /* Human readable output */
+    asn_struct_compare_f *compare_struct; /* Compare two structures */
+    asn_struct_copy_f *copy_struct;       /* Copy method */
+    ber_type_decoder_f *ber_decoder;      /* Generic BER decoder */
+    der_type_encoder_f *der_encoder;      /* Canonical DER encoder */
+    xer_type_decoder_f *xer_decoder;      /* Generic XER decoder */
+    xer_type_encoder_f *xer_encoder;      /* [Canonical] XER encoder */
+    jer_type_decoder_f *jer_decoder;      /* Generic JER encoder */
+    jer_type_encoder_f *jer_encoder;      /* Generic JER encoder */
+    oer_type_decoder_f *oer_decoder;      /* Generic OER decoder */
+    oer_type_encoder_f *oer_encoder;      /* Canonical OER encoder */
+    per_type_decoder_f *uper_decoder;     /* Unaligned PER decoder */
+    per_type_encoder_f *uper_encoder;     /* Unaligned PER encoder */
+    per_type_decoder_f *aper_decoder;     /* Aligned PER decoder */
+    per_type_encoder_f *aper_encoder;     /* Aligned PER encoder */
+    asn_random_fill_f *random_fill;       /* Initialize with a random value */
+    asn_outmost_tag_f *outmost_tag;       /* <optional, internal> */
+} asn_TYPE_operation_t;
+
+/*
+ * A constraints tuple specifying both the OER and PER constraints.
+ */
+typedef struct asn_encoding_constraints_s {
+#if !defined(ASN_DISABLE_OER_SUPPORT)
+    const struct asn_oer_constraints_s *oer_constraints;
+#endif  /* !defined(ASN_DISABLE_OER_SUPPORT) */
+#if !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT)
+    const struct asn_per_constraints_s *per_constraints;
+#endif  /* !defined(ASN_DISABLE_UPER_SUPPORT) || !defined(ASN_DISABLE_APER_SUPPORT) */
+#if !defined(ASN_DISABLE_JER_SUPPORT)
+    const struct asn_jer_constraints_s *jer_constraints;
+#endif  /* !defined(ASN_DISABLE_JER_SUPPORT) */
+    asn_constr_check_f *general_constraints;
+} asn_encoding_constraints_t;
+
+/*
+ * The definitive description of the destination language's structure.
+ */
+typedef struct asn_TYPE_descriptor_s {
+    const char *name;       /* A name of the ASN.1 type. "" in some cases. */
+    const char *xml_tag;    /* Name used in XML tag */
+
+    /*
+     * Generalized functions for dealing with the specific type.
+     * May be directly invoked by applications.
+     */
+    asn_TYPE_operation_t *op;
+
+    /***********************************************************************
+     * Internally useful members. Not to be used by applications directly. *
+     **********************************************************************/
+
+    /*
+     * Tags that are expected to occur.
+     */
+    const ber_tlv_tag_t *tags;      /* Effective tags sequence for this type */
+    unsigned tags_count;            /* Number of tags which are expected */
+    const ber_tlv_tag_t *all_tags;  /* Every tag for BER/containment */
+    unsigned all_tags_count;        /* Number of tags */
+
+    /* OER, PER, and general constraints */
+    asn_encoding_constraints_t encoding_constraints;
+
+    /*
+     * An ASN.1 production type members (members of SEQUENCE, SET, CHOICE).
+     */
+    struct asn_TYPE_member_s *elements;
+    unsigned elements_count;
+
+    /*
+     * Additional information describing the type, used by appropriate
+     * functions above.
+     */
+    const void *specifics;
+} asn_TYPE_descriptor_t;
+
+/*
+ * This type describes an element of the constructed type,
+ * i.e. SEQUENCE, SET, CHOICE, etc.
+ */
+  enum asn_TYPE_flags_e {
+    ATF_NOFLAGS,
+    ATF_POINTER = 0x01,   /* Represented by the pointer */
+    ATF_OPEN_TYPE = 0x02, /* Open Type */
+    ATF_ANY_TYPE = 0x04   /* ANY type (deprecated!) */
+  };
+typedef struct asn_TYPE_member_s {
+    enum asn_TYPE_flags_e flags; /* Element's presentation flags */
+    unsigned optional;      /* Following optional members, including current */
+    unsigned memb_offset;   /* Offset of the element */
+    ber_tlv_tag_t tag;      /* Outmost (most immediate) tag */
+    int tag_mode;           /* IMPLICIT/no/EXPLICIT tag at current level */
+    asn_TYPE_descriptor_t *type;            /* Member type descriptor */
+    asn_type_selector_f *type_selector;     /* IoS runtime type selector */
+    asn_encoding_constraints_t encoding_constraints;
+    int (*default_value_cmp)(const void *sptr); /* Compare DEFAULT <value> */
+    int (*default_value_set)(void **sptr);      /* Set DEFAULT <value> */
+    const char *name; /* ASN.1 identifier of the element */
+} asn_TYPE_member_t;
+
+/*
+ * BER tag to element number mapping.
+ */
+typedef struct asn_TYPE_tag2member_s {
+    ber_tlv_tag_t el_tag;   /* Outmost tag of the member */
+    unsigned el_no;         /* Index of the associated member, base 0 */
+    int toff_first;         /* First occurrence of the el_tag, relative */
+    int toff_last;          /* Last occurrence of the el_tag, relative */
+} asn_TYPE_tag2member_t;
+
+/*
+ * This function prints out the contents of the target language's structure
+ * (struct_ptr) into the file pointer (stream) in human readable form.
+ * RETURN VALUES:
+ * 	 0: The structure is printed.
+ * 	-1: Problem dumping the structure.
+ * (See also xer_fprint() in xer_encoder.h)
+ */
+int asn_fprint(FILE *stream, /* Destination stream descriptor */
+               const asn_TYPE_descriptor_t *td, /* ASN.1 type descriptor */
+               const void *struct_ptr);         /* Structure to be printed */
+
+/*
+ * Copies a source structure (struct_src) into destination structure 
+ * (struct_dst). Allocates memory for the destination structure, if necessary.
+ * RETURN VALUES:
+ *   0: Copy OK.
+ * 	-1: Problem copying the structure.
+ */
+int asn_copy(const asn_TYPE_descriptor_t *td, /* ASN.1 type descriptor */
+             void **struct_dst,               /* Structure to be populated */
+             const void *struct_src);         /* Structure to be copied */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _CONSTR_TYPE_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constraints.c /ext/source/modules/EVSE/EvseV2G/asn1/constraints.c
new file mode 100644
index 000000000..2914ae0ea
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constraints.c
@@ -0,0 +1,94 @@
+#include "asn_internal.h"
+#include "constraints.h"
+
+int
+asn_generic_no_constraint(const asn_TYPE_descriptor_t *type_descriptor,
+                          const void *struct_ptr,
+                          asn_app_constraint_failed_f *cb, void *key) {
+    (void)type_descriptor;	/* Unused argument */
+	(void)struct_ptr;	/* Unused argument */
+	(void)cb;	/* Unused argument */
+	(void)key;	/* Unused argument */
+
+	/* Nothing to check */
+	return 0;
+}
+
+int
+asn_generic_unknown_constraint(const asn_TYPE_descriptor_t *type_descriptor,
+                               const void *struct_ptr,
+                               asn_app_constraint_failed_f *cb, void *key) {
+    (void)type_descriptor;	/* Unused argument */
+	(void)struct_ptr;	/* Unused argument */
+	(void)cb;	/* Unused argument */
+	(void)key;	/* Unused argument */
+
+	/* Unknown how to check */
+	return 0;
+}
+
+struct errbufDesc {
+    const asn_TYPE_descriptor_t *failed_type;
+    const void *failed_struct_ptr;
+	char *errbuf;
+	size_t errlen;
+};
+
+static void
+CC_PRINTFLIKE(4, 5)
+_asn_i_ctfailcb(void *key, const asn_TYPE_descriptor_t *td, const void *sptr,
+                const char *fmt, ...) {
+    struct errbufDesc *arg = key;
+	va_list ap;
+	ssize_t vlen;
+	ssize_t maxlen;
+
+	arg->failed_type = td;
+	arg->failed_struct_ptr = sptr;
+
+	maxlen = arg->errlen;
+	if(maxlen <= 0)
+		return;
+
+	va_start(ap, fmt);
+	vlen = vsnprintf(arg->errbuf, maxlen, fmt, ap);
+	va_end(ap);
+	if(vlen >= maxlen) {
+		arg->errbuf[maxlen-1] = '\0';	/* Ensuring libc correctness */
+		arg->errlen = maxlen - 1;	/* Not counting termination */
+		return;
+	} else if(vlen >= 0) {
+		arg->errbuf[vlen] = '\0';	/* Ensuring libc correctness */
+		arg->errlen = vlen;		/* Not counting termination */
+	} else {
+		/*
+		 * The libc on this system is broken.
+		 */
+		vlen = sizeof("<broken vsnprintf>") - 1;
+		maxlen--;
+		arg->errlen = vlen < maxlen ? vlen : maxlen;
+		memcpy(arg->errbuf, "<broken vsnprintf>", arg->errlen);
+		arg->errbuf[arg->errlen] = 0;
+	}
+
+	return;
+}
+
+int
+asn_check_constraints(const asn_TYPE_descriptor_t *type_descriptor,
+                      const void *struct_ptr, char *errbuf, size_t *errlen) {
+    struct errbufDesc arg;
+    int ret;
+
+    arg.failed_type = 0;
+    arg.failed_struct_ptr = 0;
+    arg.errbuf = errbuf;
+    arg.errlen = errlen ? *errlen : 0;
+
+    ret = type_descriptor->encoding_constraints.general_constraints(
+        type_descriptor, struct_ptr, _asn_i_ctfailcb, &arg);
+    if(ret == -1 && errlen) *errlen = arg.errlen;
+
+    return ret;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/constraints.h /ext/source/modules/EVSE/EvseV2G/asn1/constraints.h
new file mode 100644
index 000000000..5e81418e4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/constraints.h
@@ -0,0 +1,63 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	ASN1_CONSTRAINTS_VALIDATOR_H
+#define	ASN1_CONSTRAINTS_VALIDATOR_H
+
+#include "asn_system.h"		/* Platform-dependent types */
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;		/* Forward declaration */
+
+/*
+ * Validate the structure according to the ASN.1 constraints.
+ * If errbuf and errlen are given, they shall be pointing to the appropriate
+ * buffer space and its length before calling this function. Alternatively,
+ * they could be passed as NULL's. If constraints validation fails,
+ * errlen will contain the actual number of bytes taken from the errbuf
+ * to encode an error message (properly 0-terminated).
+ * 
+ * RETURN VALUES:
+ * This function returns 0 in case all ASN.1 constraints are met
+ * and -1 if one or more constraints were failed.
+ */
+int asn_check_constraints(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const void *struct_ptr, /* Target language's structure */
+    char *errbuf,           /* Returned error description */
+    size_t *errlen          /* Length of the error description */
+);
+
+
+/*
+ * Generic type for constraint checking callback,
+ * associated with every type descriptor.
+ */
+typedef int(asn_constr_check_f)(
+    const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr,
+    asn_app_constraint_failed_f *optional_callback, /* Log the error */
+    void *optional_app_key /* Opaque key passed to a callback */
+);
+
+/*******************************
+ * INTERNALLY USEFUL FUNCTIONS *
+ *******************************/
+
+asn_constr_check_f asn_generic_no_constraint;	/* No constraint whatsoever */
+asn_constr_check_f asn_generic_unknown_constraint; /* Not fully supported */
+
+/*
+ * Invoke the callback with a complete error message.
+ */
+#define	ASN__CTFAIL	if(ctfailcb) ctfailcb
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* ASN1_CONSTRAINTS_VALIDATOR_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/decode.c /ext/source/modules/EVSE/EvseV2G/asn1/decode.c
new file mode 100644
index 000000000..3d7e03e11
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/decode.c
@@ -0,0 +1,403 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "all_asn1c_headers.h" // This contains all header files in the repo
+
+// Function to print an OCTET STRING as a hex string
+void print_octet_string(const OCTET_STRING_t *os) {
+    if (!os) {
+        printf("No octet string object parsed to print\n");
+        return;
+    }
+
+    for (size_t j = 0; j< os -> size; j++) {
+        printf("%02X ", os -> buf[j]);
+    }
+    printf("\n");
+}
+
+// Function to print ChargingInterface enum
+void print_charging_interface(ChargingInterface_t ci) {
+    if (!ci) {
+        printf("No charging interface object parsed to print\n");
+        return;
+    }
+
+    switch(ci) {
+        case ChargingInterface_nacs:
+            printf("    Decoded Charging Interface: NACS\n");
+            break;
+        case ChargingInterface_ccs1:
+            printf("    Decoded Charging Interface: CCS1\n");
+            break;
+        case ChargingInterface_ccs2:
+            printf("    Decoded Charging Interface: CCS2\n");
+            break;
+        case ChargingInterface_chademo:
+            printf("    Decoded Charging Interface: CHAdeMO\n");
+            break;
+        case ChargingInterface_chaoji:
+            printf("    Decoded Charging Interface: Chaoji\n");
+            break;
+        case ChargingInterface_type_1:
+            printf("    Decoded Charging Interface: Type-1\n");
+            break;
+        case ChargingInterface_type_2:
+            printf("    Decoded Charging Interface: Type-2\n");
+            break;
+        case ChargingInterface_mcs:
+            printf("    Decoded Charging Interface: MCS\n");
+            break;
+        default:
+            printf("    Unknown Charging Interface\n");
+            break;
+    }
+}
+
+// Function to print BasicSignalingProtocol enum
+void print_basic_signaling_protocol(int m, BasicSignalingProtocol_t bsp) {
+    if (!bsp) {
+        printf("    No Basic Signaling protocol object parsed to print\n");
+        return;
+    }
+
+    switch(bsp) {
+        case BasicSignalingProtocol_iec61851_1_ED2:
+            printf("    Decoded Basic Signaling Protocol[%d]: IEC 61851-01 Ed - 02\n", m);
+            break;
+        case BasicSignalingProtocol_iec61851_1_ED3:
+            printf("    Decoded Basic Signaling Protocol[%d]: IEC 61851-01 Ed - 03\n", m);
+            break;
+        case BasicSignalingProtocol_iec61851_23_ED1:
+            printf("    Decoded Basic Signaling Protocol[%d]: IEC 61851-23 Ed - 01\n", m);
+            break;
+        case BasicSignalingProtocol_iec61851_23_ED2:
+            printf("    Decoded Basic Signaling Protocol[%d]: IEC 61851-23 Ed - 02\n", m);
+            break;
+        default:
+            printf("    Unknown Charging Interface\n");
+            break;
+    }
+}
+
+// Function to decode and print the standardized extensions
+void print_standardized_extensions (const StandardizedExtensions_t *extensions) {
+    if (!extensions) {
+        printf("No standardized extensions to print\n");
+        return;
+    }
+
+    for (int i = 0; i < extensions -> list.count; i++) {
+        StandardizedExtension_t *ext = extensions -> list.array[i];
+        if (ext) {
+            printf("Extension ID: %ld\n", ext -> extensionID);
+
+            //printf("Extension Value (Raw): ");
+            //print_octet_string(&ext -> extensionValue);
+
+            uint8_t *extensionVal_buf = ext -> extensionValue.buf;
+            size_t extensionVal_size = ext -> extensionValue.size;
+
+            switch (ext -> extensionID) {
+                case 1:
+                    //printf("Charging Interface Extension\n");
+                    ChargingInterface_t *chrg_int = NULL;
+                    asn_dec_rval_t rval_chrg_int = ber_decode(NULL, &asn_DEF_ChargingInterface, (void **)&chrg_int, extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_chrg_int.code == RC_OK) {
+                        print_charging_interface(*chrg_int);
+                        ASN_STRUCT_FREE(asn_DEF_ChargingInterface, chrg_int);
+                    } else {
+                        fprintf(stderr, "Failed to decode ChargingInterface: rval.code = %d, bytes consumed = %zu\n",
+                                rval_chrg_int.code, rval_chrg_int.consumed);
+                    }
+                    break;
+                case 2:
+                    //printf("Basic Signaling Extension\n");
+                    BasicSignaling_t *bsc_sgnlng = NULL;
+                    asn_dec_rval_t rval_bsc_sgnlng = ber_decode(NULL, &asn_DEF_BasicSignaling, (void **)&bsc_sgnlng,
+                                    extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_bsc_sgnlng.code == RC_OK) {
+                        printf("Decoded BasicSignaling extensions:\n");
+                        for (int k = 0; k < bsc_sgnlng -> list.count; k++) {
+                            print_basic_signaling_protocol(k, *bsc_sgnlng -> list.array[i]);
+                            //printf("BasicSignalingProtocol[%zd]: %d\n", k+1, bsc_sgnlng -> list.array[i]);
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_BasicSignaling, bsc_sgnlng);
+                    } else {
+                        fprintf(stderr, "Failed to decode Basic Signaling\n");
+                    }
+                    break;
+                case 3:
+                    //printf("IPv6 Socket Extension\n");
+                    IPv6Socket_t *ip_socket = NULL;
+                    asn_dec_rval_t rval_ip_socket = ber_decode(NULL, &asn_DEF_IPv6Socket, (void **)&ip_socket,
+                                    extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_ip_socket.code == RC_OK) {
+                        printf("Decoded IPv6 Socket successfully:\n");
+                        printf("    IPv6 Address: ");
+                        for (size_t k = 0; k < 15; k++) {
+                            printf("%02X:", ip_socket -> ipv6Address.buf[k]);
+                        }
+                        printf("%02X\n    TCP Port: ", ip_socket -> ipv6Address.buf[15]);
+                        for (size_t k = 0; k < 3; k++) {
+                            printf("%02X:", ip_socket -> tcpPort.buf[k]);
+                        }
+                        printf("%02X\n", ip_socket -> tcpPort.buf[3]);
+                        ASN_STRUCT_FREE(asn_DEF_IPv6Socket, ip_socket);
+                    } else {
+                        fprintf(stderr, "   Failed to decode IPv6 Socket\n");
+                    }
+                    break;
+                case 4:
+                    //printf("High-Level Communication Extension\n");
+                    HighLevelCommunication_t *hlc = NULL;
+                    asn_dec_rval_t rval_hlc = ber_decode(NULL, &asn_DEF_HighLevelCommunication, (void **)&hlc,
+                                    extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_hlc.code == RC_OK) {
+                        printf("Decoded HighLevelCommunication:\n");
+                        for (int ii = 0; ii < hlc -> list.count; ii++) {
+                            HighLevelCommunicationTuple_t *tuple = hlc -> list.array[ii];
+                            printf("High Level Communication Tuple [%d]:\n", ii + 1);
+
+                            printf("  HLC Protocol: ");
+                            switch (tuple -> hlcProtocol) {
+                                case HLCProtocol_din_spec_70121_2014:
+                                    printf("DIN SPEC 70121:2014\n");
+                                    break;
+                                case HLCProtocol_iso_15118_2_2014:
+                                    printf("ISO 15118-02:2014\n");
+                                    break;
+                                case HLCProtocol_iso_15118_20_2022:
+                                    printf("ISO 15118-20:2022\n");
+                                    break;
+                                default:
+                                    printf("Unknown (%ld)\n", tuple -> hlcProtocol);
+                            }
+
+                            for (int jj = 0; jj < tuple -> securityProfileTuple.list.count; jj++) {
+                                SecurityProfileTuple_t *sp_tuple = tuple -> securityProfileTuple.list.array[jj];
+                                switch (sp_tuple -> securityProfile) {
+                                    case SecurityProfile_tcpOnly:
+                                        printf("    Security Profiles: TCP\n");
+                                        break;
+                                    case SecurityProfile_tls12_server:
+                                        printf("    Security Profiles: TLS 1.2 Server\n");
+                                        break;
+                                    case SecurityProfile_tls13_mutual:
+                                        printf("    Security Profiles: TLS 1.3 Mutual\n");
+                                        break;
+                                    default:
+                                        printf("    Security Profiles: Unknown Security profile\n");
+                                }
+                                
+                                printf("        Authorization Methods:");
+                                for (int kk = 0; kk < sp_tuple -> authorizationMethod.list.count; kk++) {
+                                    AuthorizationMethod_t *auth_method = sp_tuple -> authorizationMethod.list.array[kk];
+                                    switch (*auth_method) {
+                                        case AuthorizationMethod_eim:
+                                            printf(" EIM ");
+                                            break;
+                                        case AuthorizationMethod_pnc_2:
+                                            printf(" PNC_ISO_15118-02 ");
+                                            break;
+                                        case AuthorizationMethod_pnc_20:
+                                            printf(" PNC_ISO_15118-20 ");
+                                            break;
+                                        default:
+                                            printf(" Unknown Authorization methods");
+                                    }
+                                }
+                                printf("\n");
+
+                                printf("        Energy Transfer Modes:");
+                                for (int kk = 0; kk < sp_tuple -> energyTransferMode.list.count; kk++) {
+                                    AuthorizationMethod_t *mode = sp_tuple -> energyTransferMode.list.array[kk];
+                                    switch (*mode) {
+                                        case EnergyTransferMode_dc:
+                                            printf(" DC ");
+                                            break;
+                                        case EnergyTransferMode_dc_bpt:
+                                            printf(" DC-BPT ");
+                                            break;
+                                        case EnergyTransferMode_ac:
+                                            printf(" AC ");
+                                            break;
+                                        case EnergyTransferMode_ac_bpt:
+                                            printf(" AC-BPT ");
+                                            break;                                            
+                                        default:
+                                            printf(" Unknown Energy Transfer modes");
+                                    }
+                                }
+                                printf("\n");
+                            }
+                            printf("\n");
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_HighLevelCommunication, hlc);
+                    } else {
+                        fprintf(stderr, "Failed to decode HighLevelCommunication\n");
+                    }
+                    break;
+                case 5:
+                    //printf("EMSP Identifiers Extension\n");
+                    EMSPIdentifiers_t *emsp = NULL;
+                    asn_dec_rval_t rval_emsp = ber_decode(NULL, &asn_DEF_EMSPIdentifiers, (void **)&emsp,
+                                    extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_emsp.code == RC_OK) {
+                        printf("Decoded EMSPIdentifiers:\n");
+                        for (int k = 0; k < emsp -> list.count; k++) {
+                            printf("    EMSP Identifier[%d]: %s\n", k+1, emsp -> list.array[k] -> buf);
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_EMSPIdentifiers, emsp);
+                    } else {
+                        fprintf(stderr, "   Failed to decode EMSP Identifiers\n");
+                    }
+                    break;
+                case 6:
+                    //printf("DC Charging Limits Extension\n");
+                    DCChargingLimits_t *limits = NULL;
+                    asn_dec_rval_t rval_limits = ber_decode(NULL, &asn_DEF_DCChargingLimits, (void **)&limits,
+                                    extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_limits.code == RC_OK) {
+                        printf("Decoded DC Charging Limits:\n");
+                        printf("    Maximum Voltage: %ld [V]\n", limits -> maximumVoltage);
+                        printf("    Maximum Voltage: %ld [V]\n", limits -> minimumVoltage);
+                        ASN_STRUCT_FREE(asn_DEF_DCChargingLimits, limits);
+                    } else {
+                        printf("    Failed to decode DC Charging Limits\n");
+                    }
+                    break;
+                case 7:
+                    ConductiveChargingInterfaceLimitations_t *interface_limits = NULL;
+                    asn_dec_rval_t rval_int_limits = ber_decode(NULL, &asn_DEF_ConductiveChargingInterfaceLimitations,
+                                    (void **)&interface_limits, extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_int_limits.code == RC_OK) {
+                        printf("Decoded Charging Interface Limits: \n");
+                        printf("    Maximum Contactor Temp: %ld [C]\n", interface_limits -> maximumContactorTemperature);
+                        ASN_STRUCT_FREE(asn_DEF_ConductiveChargingInterfaceLimitations, interface_limits);
+                    } else {
+                        printf("    Failed to decode Conductive Charging Interface Limitations\n");
+                    }
+                    break;                    
+                case 8:
+                    EVCharacteristics_t *evChar = NULL;
+                    asn_dec_rval_t rval_evChar = ber_decode(NULL, &asn_DEF_EVCharacteristics, (void **)&evChar,
+                                    extensionVal_buf, extensionVal_size);
+
+                    if(rval_evChar.code == RC_OK) {
+                        printf("Decoded EV Characteristics:\n");
+                        if (evChar -> vehicleIdentificationNumber -> size > 0) {
+                            printf("    Vehicle Identification Number: ");
+                            for (size_t i = 0; i < evChar -> vehicleIdentificationNumber -> size; i++) {
+                                printf("%02X", evChar -> vehicleIdentificationNumber -> buf[i]);
+                            }
+                            printf("\n");
+                        } else {
+                            printf("    Vehicle Identification Number was NOT communicated");
+                        }
+                        if (evChar -> evccSoftwareVersion -> size > 0) {
+                            printf("    EVCC Software Version: %.*s\n", (int)evChar -> evccSoftwareVersion -> size,
+                                    evChar -> evccSoftwareVersion -> buf);
+                        } else {
+                            printf("    EVCC Software version was NOT communicated");
+                        }
+                    } else {
+                        printf("    Failed to decode EV Characteristics\n");
+                    }
+                    break;
+                case 9:
+                    ChargingStationCharacteristics_t *evseChar = NULL;
+                    asn_dec_rval_t rval_evseChar = ber_decode(NULL, &asn_DEF_ChargingStationCharacteristics,
+                                    (void **)&evseChar, extensionVal_buf, extensionVal_size);
+
+                    if(rval_evseChar.code == RC_OK) {
+                        printf("Decoded Charging Station Characteristics:\n");
+                        if (evseChar -> evseID -> size > 0) {
+                            printf("    EVSE ID: ");
+                            for (size_t k = 0; k < (evseChar -> evseID -> size); k++) {
+                                printf("%02X",evseChar -> evseID -> buf[k]);
+                            }
+                            printf("\n");
+                        } else {
+                            printf("    EVSE ID was NOT communicated");
+                        }
+                        if (evseChar -> seccSoftwareVersion -> size > 0) {
+                            printf("    SECC Software Version: %.*s\n", (int)evseChar -> seccSoftwareVersion -> size,
+                                    evseChar -> seccSoftwareVersion -> buf);
+                        } else {
+                            printf("    SECC Software version was NOT communicated");
+                        }
+                    } else {
+                        printf("Failed to decode Charging Station Characteristics\n");
+                    }
+                    break;
+                default:
+                    printf("Unknown Extension ID: %ld\n", ext -> extensionID);
+                    break;
+            }
+        }
+    }
+}
+
+int main(int argc, char **argv) {
+    if (argc < 2) {
+        fprintf(stderr, "Usage: %s <input.ber>\n", argv[0]);
+        exit(1);
+    }
+
+    const char *filename = argv[1];
+    FILE *fp = fopen(filename, "rb");
+    if (!fp) {
+        perror("Error opening file for reading");
+        exit(1);
+    }
+
+    /* Read the BER file into a buffer */
+    fseek(fp, 0, SEEK_END);
+    size_t file_size = ftell(fp);
+    fseek(fp, 0, SEEK_SET);
+
+    uint8_t *buffer = malloc(file_size);
+    if (!buffer) {
+        perror("Memory allocation failed");
+        fclose(fp);
+        exit(1);
+    }
+
+    fread(buffer, 1, file_size, fp);
+    fclose(fp);
+
+    /* Decode the buffer into HighLevelCommunication */
+    Extensions_t *extensions = calloc(1, sizeof(Extensions_t));
+    asn_dec_rval_t rval = asn_decode(NULL, ATS_DER, &asn_DEF_Extensions, (void **)&extensions, buffer, file_size);
+    if (rval.code != RC_OK) {
+        fprintf(stderr, "Decoding failed at byte %ld\n", rval.consumed);
+        ASN_STRUCT_FREE(asn_DEF_Extensions, extensions);
+        exit(1);
+    }
+
+    free(buffer);
+
+    /* Print the decoded structure */
+    printf("Standardized Extensions:\n");
+    print_standardized_extensions(&extensions -> standardized);
+
+    if (extensions -> external) {
+        printf("External Extensions Present\n");
+    } else {
+        printf("No External Extensions present\n");
+    }
+//    xer_fprint(stdout, &asn_DEF_Extensions, extensions);
+
+    /* Free the allocated memory */
+    ASN_STRUCT_FREE(asn_DEF_Extensions, extensions);
+
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/der_encoder.c /ext/source/modules/EVSE/EvseV2G/asn1/der_encoder.c
new file mode 100644
index 000000000..6846e560c
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/der_encoder.c
@@ -0,0 +1,194 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include <errno.h>
+
+static ssize_t der_write_TL(ber_tlv_tag_t tag, ber_tlv_len_t len,
+	asn_app_consume_bytes_f *cb, void *app_key, int constructed);
+
+/*
+ * The DER encoder of any type.
+ */
+asn_enc_rval_t
+der_encode(const asn_TYPE_descriptor_t *type_descriptor, const void *struct_ptr,
+           asn_app_consume_bytes_f *consume_bytes, void *app_key) {
+    ASN_DEBUG("DER encoder invoked for %s",
+		type_descriptor->name);
+
+	/*
+	 * Invoke type-specific encoder.
+	 */
+    return type_descriptor->op->der_encoder(
+        type_descriptor, struct_ptr, /* Pointer to the destination structure */
+        0, 0, consume_bytes, app_key);
+}
+
+/*
+ * Argument type and callback necessary for der_encode_to_buffer().
+ */
+typedef struct enc_to_buf_arg {
+	void *buffer;
+	size_t left;
+} enc_to_buf_arg;
+static int encode_to_buffer_cb(const void *buffer, size_t size, void *key) {
+	enc_to_buf_arg *arg = (enc_to_buf_arg *)key;
+
+	if(arg->left < size)
+		return -1;	/* Data exceeds the available buffer size */
+
+	memcpy(arg->buffer, buffer, size);
+	arg->buffer = ((char *)arg->buffer) + size;
+	arg->left -= size;
+
+	return 0;
+}
+
+/*
+ * A variant of the der_encode() which encodes the data into the provided buffer
+ */
+asn_enc_rval_t
+der_encode_to_buffer(const asn_TYPE_descriptor_t *type_descriptor,
+                     const void *struct_ptr, void *buffer, size_t buffer_size) {
+    enc_to_buf_arg arg;
+	asn_enc_rval_t ec;
+
+	arg.buffer = buffer;
+	arg.left = buffer_size;
+
+	ec = type_descriptor->op->der_encoder(type_descriptor,
+		struct_ptr,	/* Pointer to the destination structure */
+		0, 0, encode_to_buffer_cb, &arg);
+	if(ec.encoded != -1) {
+		assert(ec.encoded == (ssize_t)(buffer_size - arg.left));
+		/* Return the encoded contents size */
+	}
+	return ec;
+}
+
+
+/*
+ * Write out leading TL[v] sequence according to the type definition.
+ */
+ssize_t
+der_write_tags(const asn_TYPE_descriptor_t *sd, size_t struct_length,
+               int tag_mode, int last_tag_form,
+               ber_tlv_tag_t tag, /* EXPLICIT or IMPLICIT tag */
+               asn_app_consume_bytes_f *cb, void *app_key) {
+#define ASN1_DER_MAX_TAGS_COUNT 4
+    ber_tlv_tag_t
+        tags_buf_scratch[ASN1_DER_MAX_TAGS_COUNT * sizeof(ber_tlv_tag_t)];
+    ssize_t lens[ASN1_DER_MAX_TAGS_COUNT * sizeof(ssize_t)];
+    const ber_tlv_tag_t *tags; /* Copy of tags stream */
+    int tags_count;            /* Number of tags */
+    size_t overall_length;
+    int i;
+
+    ASN_DEBUG("Writing tags (%s, tm=%d, tc=%d, tag=%s, mtc=%d)",
+		sd->name, tag_mode, sd->tags_count,
+		ber_tlv_tag_string(tag),
+		tag_mode
+			?(sd->tags_count+1
+				-((tag_mode == -1) && sd->tags_count))
+			:sd->tags_count
+	);
+
+    if(sd->tags_count + 1 > ASN1_DER_MAX_TAGS_COUNT) {
+        ASN_DEBUG("System limit %d on tags count", ASN1_DER_MAX_TAGS_COUNT);
+        return -1;
+    }
+
+	if(tag_mode) {
+		/*
+		 * Instead of doing shaman dance like we do in ber_check_tags(),
+		 * allocate a small array on the stack
+		 * and initialize it appropriately.
+		 */
+		int stag_offset;
+		ber_tlv_tag_t *tags_buf = tags_buf_scratch;
+		tags_count = sd->tags_count
+			+ 1	/* EXPLICIT or IMPLICIT tag is given */
+			- ((tag_mode == -1) && sd->tags_count);
+		/* Copy tags over */
+		tags_buf[0] = tag;
+		stag_offset = -1 + ((tag_mode == -1) && sd->tags_count);
+		for(i = 1; i < tags_count; i++)
+			tags_buf[i] = sd->tags[i + stag_offset];
+		tags = tags_buf;
+	} else {
+		tags = sd->tags;
+		tags_count = sd->tags_count;
+	}
+
+	/* No tags to write */
+	if(tags_count == 0)
+		return 0;
+
+	/*
+	 * Array of tags is initialized.
+	 * Now, compute the size of the TLV pairs, from right to left.
+	 */
+	overall_length = struct_length;
+	for(i = tags_count - 1; i >= 0; --i) {
+		lens[i] = der_write_TL(tags[i], overall_length, 0, 0, 0);
+		if(lens[i] == -1) return -1;
+		overall_length += lens[i];
+		lens[i] = overall_length - lens[i];
+	}
+
+	if(!cb) return overall_length - struct_length;
+
+	ASN_DEBUG("Encoding %s TL sequence (%d elements)", sd->name,
+                  tags_count);
+
+	/*
+	 * Encode the TL sequence for real.
+	 */
+	for(i = 0; i < tags_count; i++) {
+		ssize_t len;
+		int _constr;
+
+		/* Check if this tag happens to be constructed */
+		_constr = (last_tag_form || i < (tags_count - 1));
+
+		len = der_write_TL(tags[i], lens[i], cb, app_key, _constr);
+		if(len == -1) return -1;
+	}
+
+	return overall_length - struct_length;
+}
+
+static ssize_t
+der_write_TL(ber_tlv_tag_t tag, ber_tlv_len_t len,
+		asn_app_consume_bytes_f *cb, void *app_key,
+		int constructed) {
+	uint8_t buf[32];
+	size_t size = 0;
+	int buf_size = cb?sizeof(buf):0;
+	ssize_t tmp;
+
+	/* Serialize tag (T from TLV) into possibly zero-length buffer */
+	tmp = ber_tlv_tag_serialize(tag, buf, buf_size);
+	if(tmp == -1 || tmp > (ssize_t)sizeof(buf)) return -1;
+	size += tmp;
+
+	/* Serialize length (L from TLV) into possibly zero-length buffer */
+	tmp = der_tlv_length_serialize(len, buf+size, buf_size?buf_size-size:0);
+	if(tmp == -1) return -1;
+	size += tmp;
+
+	if(size > sizeof(buf))
+		return -1;
+
+	/*
+	 * If callback is specified, invoke it, and check its return value.
+	 */
+	if(cb) {
+		if(constructed) *buf |= 0x20;
+		if(cb(buf, size, app_key) < 0)
+			return -1;
+	}
+
+	return size;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/der_encoder.h /ext/source/modules/EVSE/EvseV2G/asn1/der_encoder.h
new file mode 100644
index 000000000..2605e064e
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/der_encoder.h
@@ -0,0 +1,68 @@
+/*-
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_DER_ENCODER_H_
+#define	_DER_ENCODER_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * The DER encoder of any type. May be invoked by the application.
+ * Produces DER- and BER-compliant encoding. (DER is a subset of BER).
+ *
+ * NOTE: Use the ber_decode() function (ber_decoder.h) to decode data
+ * produced by der_encode().
+ */
+asn_enc_rval_t der_encode(const struct asn_TYPE_descriptor_s *type_descriptor,
+                          const void *struct_ptr, /* Structure to be encoded */
+                          asn_app_consume_bytes_f *consume_bytes_cb,
+                          void *app_key /* Arbitrary callback argument */
+);
+
+/* A variant of der_encode() which encodes data into the pre-allocated buffer */
+asn_enc_rval_t der_encode_to_buffer(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const void *struct_ptr, /* Structure to be encoded */
+    void *buffer,           /* Pre-allocated buffer */
+    size_t buffer_size      /* Initial buffer size (maximum) */
+);
+
+/*
+ * Type of the generic DER encoder.
+ */
+typedef asn_enc_rval_t(der_type_encoder_f)(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const void *struct_ptr, /* Structure to be encoded */
+    int tag_mode,           /* {-1,0,1}: IMPLICIT, no, EXPLICIT */
+    ber_tlv_tag_t tag, asn_app_consume_bytes_f *consume_bytes_cb, /* Callback */
+    void *app_key /* Arbitrary callback argument */
+);
+
+
+/*******************************
+ * INTERNALLY USEFUL FUNCTIONS *
+ *******************************/
+
+/*
+ * Write out leading TL[v] sequence according to the type definition.
+ */
+ssize_t der_write_tags(const struct asn_TYPE_descriptor_s *type_descriptor,
+                       size_t struct_length,
+                       int tag_mode,      /* {-1,0,1}: IMPLICIT, no, EXPLICIT */
+                       int last_tag_form, /* {0,!0}: prim, constructed */
+                       ber_tlv_tag_t tag,
+                       asn_app_consume_bytes_f *consume_bytes_cb,
+                       void *app_key);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _DER_ENCODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/encode.c /ext/source/modules/EVSE/EvseV2G/asn1/encode.c
new file mode 100644
index 000000000..71c6e2713
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/encode.c
@@ -0,0 +1,395 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "all_asn1c_headers.h" // This contains all header files in the repo
+
+/* Write the encoded output into a FILE stream */
+static int write_out(const void *buffer, size_t size, void *app_key) {
+    FILE *out_fp = app_key;
+    return (fwrite(buffer, 1, size, out_fp) == size) ? 0 : -1;
+}
+
+/* Cleanup function to free resources in case of error */
+void cleanup_extensions(Extensions_t *extensions) {
+	if (!extensions) return;
+}
+
+int main(int argc, char **argv) {
+    if (argc < 2) {
+        fprintf(stderr, "Usage: %s <output.ber>\n", argv[0]);
+        exit(1);
+    }
+
+    const char *filename = argv[1];
+    FILE *fp = fopen(filename, "wb");
+    if (!fp) {
+        perror("Error opening file for writing");
+        exit(1);
+    }
+    
+    /* Create and populate Extensions */
+    Extensions_t *extensions = calloc(1, sizeof(Extensions_t));
+    if (!extensions) {
+    	perror("Failed to allocate memory for Extensions");
+    	return 1;
+    }
+    
+    /* ExtensionID 1 - Charging interface extension */
+    StandardizedExtension_t *charging_interface_ext = calloc(1, sizeof(StandardizedExtension_t));
+    if (!charging_interface_ext) {
+    	perror("Failed to allocate memory for Charging Interface Extension");
+        ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, charging_interface_ext);
+    	fclose(fp);
+    	return 1;
+    }
+    charging_interface_ext -> extensionID = 1;
+    ChargingInterface_t charging_interface = ChargingInterface_ccs1;
+    uint8_t *ci_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t ci_enc_rval = der_encode_to_buffer(&asn_DEF_ChargingInterface, &charging_interface,
+                    ci_buffer, 128);
+    printf("ChargingInterface data encoded: %zu bytes\n", ci_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&charging_interface_ext -> extensionValue, (char *)ci_buffer, ci_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, charging_interface_ext);
+    free(ci_buffer);
+
+
+    /* ExtensionID 2 - Basic signaling extension */
+    StandardizedExtension_t *basic_signaling_ext = calloc(1, sizeof(StandardizedExtension_t));
+    if (!basic_signaling_ext) {
+    	perror("Failed to allocate memory for Basic Signaling Extension");
+    	ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, basic_signaling_ext);  
+    	fclose(fp);
+    	return 1;
+    }    
+    basic_signaling_ext -> extensionID = 2;
+    BasicSignaling_t *basic_signaling = calloc(1, sizeof(BasicSignaling_t));
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, &(BasicSignalingProtocol_t){BasicSignalingProtocol_iec61851_1_ED2});
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, &(BasicSignalingProtocol_t){BasicSignalingProtocol_iec61851_1_ED3});
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, &(BasicSignalingProtocol_t){BasicSignalingProtocol_iec61851_23_ED1});
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, &(BasicSignalingProtocol_t){BasicSignalingProtocol_iec61851_23_ED2});   
+    uint8_t *bs_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t bs_enc_rval = der_encode_to_buffer(&asn_DEF_BasicSignaling, basic_signaling, bs_buffer, 128);
+    printf("Basic Signaling data encoded: %zu bytes\n", bs_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&basic_signaling_ext -> extensionValue, (char *)bs_buffer, bs_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, basic_signaling_ext);
+    free(bs_buffer);
+    
+    /* ExtensionID 3 - IPv6 Socket extension */
+    StandardizedExtension_t *ipv6_socket_ext = calloc(1, sizeof(StandardizedExtension_t));
+    if (!ipv6_socket_ext) {
+    	perror("Failed to allocate memory for IPv6 Socket Extension");
+    	ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, ipv6_socket_ext);  
+    	fclose(fp);
+    	return 1;
+    }    
+    ipv6_socket_ext -> extensionID = 3;
+    IPv6Socket_t *ipv6_socket = calloc(1, sizeof(IPv6Socket_t));
+    const char ipv6_secc_address[] = {0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                        0x79, 0xbd, 0x0f, 0xb1, 0x1d, 0xb0, 0x88, 0xa7};
+    const char ipv6_secc_port[] = {0x00, 0x00, 0xef, 0x9d};
+    OCTET_STRING_fromBuf(&ipv6_socket -> ipv6Address, (const char *)&ipv6_secc_address, sizeof(ipv6_secc_address));
+    OCTET_STRING_fromBuf(&ipv6_socket -> tcpPort, (const char *)&ipv6_secc_port, sizeof(ipv6_secc_port));
+    uint8_t *ip_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t ip_enc_rval = der_encode_to_buffer(&asn_DEF_IPv6Socket, ipv6_socket, ip_buffer, 128);
+    printf("IPv6 Socket data encoded: %zu bytes\n", ip_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&ipv6_socket_ext -> extensionValue, (char *)ip_buffer, ip_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, ipv6_socket_ext);
+    free(ip_buffer);
+
+    /* Verify ipv6 address*/
+/*    for (size_t i = 0; i < ipv6_socket -> ipv6Address.size; i++) {
+        printf("%02x", ipv6_socket -> ipv6Address.buf[i]);
+        if (i % 2 && i != ipv6_socket -> ipv6Address.size - 1) {
+            printf(":");
+        }
+    }
+    printf("\n");   */
+    
+    /* Verify ipv6 tcp port*/
+/*    for (size_t i = 0; i < ipv6_socket -> tcpPort.size; i++) {
+        printf("%02x", ipv6_socket -> tcpPort.buf[i]);
+        if (i % 2 && i != ipv6_socket -> tcpPort.size - 1) {
+            printf(":");
+        }
+    }
+    printf("\n");   */
+
+   /* ExtensionID 4 - High Level Communication extension */
+    StandardizedExtension_t *hlc_ext = calloc(1, sizeof(StandardizedExtension_t));
+    if (!hlc_ext) {
+    	perror("Failed to allocate memory for High Level Communication Extension");
+    	ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, hlc_ext);  
+    	fclose(fp);
+    	return 1;
+    }    
+    hlc_ext -> extensionID = 4;
+    HighLevelCommunication_t *hlc = calloc(1, sizeof(HighLevelCommunication_t));
+    if (!hlc) {
+    	free(hlc_ext);
+    	perror("Failed to allocate memory for High Level Communication_t object");
+    	ASN_STRUCT_FREE(asn_DEF_HighLevelCommunication, hlc);  
+    	fclose(fp);
+    	return 1;
+    }	
+    
+    /* First HLC Tuple - For DIN 70121:2014 (TCP with EIM with DC) */
+    HighLevelCommunicationTuple_t *hlc_tuple01 = calloc(1, sizeof(HighLevelCommunicationTuple_t));
+    hlc_tuple01 -> hlcProtocol = HLCProtocol_din_spec_70121_2014;
+    SecurityProfileTuple_t *sec_profile01 = calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile01 -> securityProfile = SecurityProfile_tcpOnly;
+    AuthorizationMethod_t *auth01 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth01 = AuthorizationMethod_eim;
+    EnergyTransferMode_t *mode01 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode01 = EnergyTransferMode_dc;
+    ASN_SEQUENCE_ADD(&sec_profile01 -> authorizationMethod.list, auth01);
+    ASN_SEQUENCE_ADD(&sec_profile01 -> energyTransferMode.list, mode01);
+    ASN_SEQUENCE_ADD(&hlc_tuple01 -> securityProfileTuple.list, sec_profile01);
+    ASN_SEQUENCE_ADD(&hlc -> list, hlc_tuple01);
+    
+    /* Second HLC Tuple - For ISO 15118-2:2014 (TCP with EIM with dc & ac) */
+    HighLevelCommunicationTuple_t *hlc_tuple02 = calloc(1, sizeof(HighLevelCommunicationTuple_t));
+    hlc_tuple02 -> hlcProtocol = HLCProtocol_iso_15118_2_2014;
+    SecurityProfileTuple_t *sec_profile02_01 = calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile02_01 -> securityProfile = SecurityProfile_tcpOnly;
+    AuthorizationMethod_t *auth02_01 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth02_01 = AuthorizationMethod_eim;
+    EnergyTransferMode_t *mode02_01_01 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_01_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode02_01_02 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_01_02 = EnergyTransferMode_ac;
+    ASN_SEQUENCE_ADD(&sec_profile02_01 -> authorizationMethod.list, auth02_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_01 -> energyTransferMode.list, mode02_01_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_01 -> energyTransferMode.list, mode02_01_02);
+    
+    /* and (TLS12_server with EIM & PNC_2 with dc & ac) */
+    SecurityProfileTuple_t *sec_profile02_02 = calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile02_02 -> securityProfile = SecurityProfile_tls12_server;
+    AuthorizationMethod_t *auth02_02_01 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth02_02_01 = AuthorizationMethod_eim;
+    AuthorizationMethod_t *auth02_02_02 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth02_02_02 = AuthorizationMethod_pnc_2;
+    EnergyTransferMode_t *mode02_02_01 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_02_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode02_02_02 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_02_02 = EnergyTransferMode_ac;
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> authorizationMethod.list, auth02_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> authorizationMethod.list, auth02_02_02);
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> energyTransferMode.list, mode02_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> energyTransferMode.list, mode02_02_02);  
+    ASN_SEQUENCE_ADD(&hlc_tuple02 -> securityProfileTuple.list, sec_profile02_01);
+    ASN_SEQUENCE_ADD(&hlc_tuple02 -> securityProfileTuple.list, sec_profile02_02);
+    ASN_SEQUENCE_ADD(&hlc -> list, hlc_tuple02);       
+    
+    /* Third HLC Tuple - For ISO 15118-20:2022 (TCP with EIM with dc & dc-bpt & ac & ac-bpt) */
+    HighLevelCommunicationTuple_t *hlc_tuple03 = calloc(1, sizeof(HighLevelCommunicationTuple_t));
+    hlc_tuple03 -> hlcProtocol = HLCProtocol_iso_15118_20_2022;
+    SecurityProfileTuple_t *sec_profile03_01 = calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile03_01 -> securityProfile = SecurityProfile_tcpOnly;
+    AuthorizationMethod_t *auth03_01 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_01 = AuthorizationMethod_eim;
+    EnergyTransferMode_t *mode03_01_01 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode03_01_02 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_02 = EnergyTransferMode_dc_bpt;    
+    EnergyTransferMode_t *mode03_01_03 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_03 = EnergyTransferMode_ac;
+    EnergyTransferMode_t *mode03_01_04 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_04 = EnergyTransferMode_ac_bpt;    
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> authorizationMethod.list, auth03_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_03);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_04); 
+    
+    /* and (TLS12_server with EIM & PNC_2 with dc & dc-bpt & ac & ac-bpt) */
+    SecurityProfileTuple_t *sec_profile03_02 = calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile03_02 -> securityProfile = SecurityProfile_tls12_server;
+    AuthorizationMethod_t *auth03_02_01 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_02_01 = AuthorizationMethod_eim;
+    AuthorizationMethod_t *auth03_02_02 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_02_02 = AuthorizationMethod_pnc_2;
+    EnergyTransferMode_t *mode03_02_01 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode03_02_02 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_02 = EnergyTransferMode_dc_bpt;    
+    EnergyTransferMode_t *mode03_02_03 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_03 = EnergyTransferMode_ac;
+    EnergyTransferMode_t *mode03_02_04 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_04 = EnergyTransferMode_ac_bpt;
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> authorizationMethod.list, auth03_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> authorizationMethod.list, auth03_02_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_03);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_04);   
+    
+    /* and (TLS13_mutual with EIM & PNC_2 & PNC_20 with dc & dc-bpt & ac & ac-bpt) */
+    SecurityProfileTuple_t *sec_profile03_03 = calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile03_03 -> securityProfile = SecurityProfile_tls13_mutual;
+    AuthorizationMethod_t *auth03_03_01 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_03_01 = AuthorizationMethod_eim;
+    AuthorizationMethod_t *auth03_03_02 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_03_02 = AuthorizationMethod_pnc_2;
+    AuthorizationMethod_t *auth03_03_03 = calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_03_03 = AuthorizationMethod_pnc_20;    
+    EnergyTransferMode_t *mode03_03_01 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode03_03_02 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_02 = EnergyTransferMode_dc_bpt;    
+    EnergyTransferMode_t *mode03_03_03 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_03 = EnergyTransferMode_ac;
+    EnergyTransferMode_t *mode03_03_04 = calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_04 = EnergyTransferMode_ac_bpt;
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> authorizationMethod.list, auth03_03_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> authorizationMethod.list, auth03_03_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> authorizationMethod.list, auth03_03_03);    
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_03);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_04);
+    ASN_SEQUENCE_ADD(&hlc_tuple03 -> securityProfileTuple.list, sec_profile03_01);
+    ASN_SEQUENCE_ADD(&hlc_tuple03 -> securityProfileTuple.list, sec_profile03_02);
+    ASN_SEQUENCE_ADD(&hlc_tuple03 -> securityProfileTuple.list, sec_profile03_03);
+    ASN_SEQUENCE_ADD(&hlc -> list, hlc_tuple03);
+
+    /* Add hlc sequence of hlc_tuples to extensions -> extensionValue and standardized extension */
+    uint8_t *hlc_buffer = calloc(256, sizeof(uint8_t));
+    asn_enc_rval_t hlc_enc_rval = der_encode_to_buffer(&asn_DEF_HighLevelCommunication, hlc, hlc_buffer, 256);
+    printf("HLC data encoded: %zu bytes\n", hlc_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&hlc_ext -> extensionValue, (char *)hlc_buffer, hlc_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, hlc_ext);
+    free(hlc_buffer);
+
+
+    /* ExtensionID 5 - EMSP identifiers extension */
+    /* Using placeholder EMSP values for now */
+    StandardizedExtension_t *emsp_ids_ext = calloc(1, sizeof(StandardizedExtension_t));
+//    fprintf(stdout, "Size of emsp_ids_ext object: %zu bytes\n", sizeof(*emsp_ids_ext));
+    emsp_ids_ext -> extensionID = 5;
+    EMSPIdentifiers_t *emsp_ids = calloc(1, sizeof(EMSPIdentifiers_t));
+    EMSPIdentifier_t *emsp_id01 = calloc(1, sizeof(EMSPIdentifier_t));
+    OCTET_STRING_fromBuf(emsp_id01, "abcde_0101", strlen("abcde_0101"));
+    ASN_SEQUENCE_ADD(&emsp_ids -> list, emsp_id01);
+    EMSPIdentifier_t *emsp_id02 = calloc(1, sizeof(EMSPIdentifier_t));
+    OCTET_STRING_fromBuf(emsp_id02, "ABCDE_0102", strlen("ABCDE_0102"));
+    ASN_SEQUENCE_ADD(&emsp_ids -> list, emsp_id02);
+    uint8_t *emsp_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t emsp_enc_rval = der_encode_to_buffer(&asn_DEF_EMSPIdentifiers, emsp_ids, emsp_buffer, 128);
+    printf("EMSP Identifiers data encoded: %zu bytes\n", emsp_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&emsp_ids_ext -> extensionValue, (char *)emsp_buffer, emsp_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, emsp_ids_ext);
+    free(emsp_buffer);
+    
+    
+    /* ExtensionID 6 - DC charging limits extension */
+    StandardizedExtension_t *dc_limits_ext = calloc(1, sizeof(StandardizedExtension_t));
+    if (!dc_limits_ext) {
+    	perror("Failed to allocate memory for DC Charging Limits Extension");
+    	ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, dc_limits_ext);
+    	fclose(fp);
+    	return 1;
+    }
+    dc_limits_ext -> extensionID = 6;
+    DCChargingLimits_t *dc_limits = calloc(1, sizeof(DCChargingLimits_t));
+    dc_limits -> maximumVoltage = 1000;
+    dc_limits -> minimumVoltage = 250;
+    uint8_t *dc_limits_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t dc_limits_enc_rval = der_encode_to_buffer(&asn_DEF_DCChargingLimits, dc_limits, dc_limits_buffer, 128);
+    printf("DC Charging Limits data encoded: %zu bytes\n", dc_limits_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&dc_limits_ext -> extensionValue, (char *)dc_limits_buffer, dc_limits_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, dc_limits_ext);
+    free(dc_limits_buffer);
+
+    /*********************************************END OF STANDARD EXTENSIONS*********************************************/
+
+    /* (NOT STANDARD) - ExtensionID 7 - Conductive Charging Interface Limitations extension */
+    StandardizedExtension_t *chrg_int_limits_ext = calloc(1, sizeof(StandardizedExtension_t));
+    if (!chrg_int_limits_ext) {
+    	perror("Failed to allocate memory for Conductive Charging Interface Limits Extension");
+    	ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, chrg_int_limits_ext);
+        //ASN_STRUCT_FREE(asn_DEF_ConductiveChargingInterfaceLimitations, chrg_int_limits);
+    	fclose(fp);
+    	return 1;
+    }
+    chrg_int_limits_ext -> extensionID = 7;
+    ConductiveChargingInterfaceLimitations_t *chrg_int_limits = calloc(1, sizeof(ConductiveChargingInterfaceLimitations_t));
+    chrg_int_limits -> maximumContactorTemperature = 80;
+    uint8_t *chrg_int_limits_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t chrg_int_limits_enc_rval = der_encode_to_buffer(&asn_DEF_ConductiveChargingInterfaceLimitations,
+                    chrg_int_limits, chrg_int_limits_buffer, 128);
+    printf("Conductive Charging Interface Limits data encoded: %zu bytes\n", chrg_int_limits_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&chrg_int_limits_ext -> extensionValue, (char *)chrg_int_limits_buffer,
+                    chrg_int_limits_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, chrg_int_limits_ext);
+    free(chrg_int_limits_buffer);
+
+    /* (NOT STANDARD) - ExtensionID 8 - EV Characteristics extension */
+    StandardizedExtension_t *evChar_ext = calloc(1, sizeof(StandardizedExtension_t));
+    if (!evChar_ext) {
+    	perror("Failed to allocate memory for EV Characteristics Extension");
+    	ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, evChar_ext);
+    	fclose(fp);
+    	return 1;
+    }
+    evChar_ext -> extensionID = 8;
+    EVCharacteristics_t *evChar = calloc(1, sizeof(EVCharacteristics_t));
+    evChar -> vehicleIdentificationNumber = calloc(1, sizeof(OCTET_STRING_t));
+    evChar -> evccSoftwareVersion = calloc(1, sizeof(UTF8String_t));
+    const char vin[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00};
+    const char evcc_sw[] = "v2.5.6_20241031";
+    OCTET_STRING_fromBuf(evChar -> vehicleIdentificationNumber, vin, sizeof(vin));
+    OCTET_STRING_fromBuf(evChar -> evccSoftwareVersion, evcc_sw, sizeof(evcc_sw));
+    uint8_t *evChar_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t evChar_enc_rval = der_encode_to_buffer(&asn_DEF_EVCharacteristics, evChar, evChar_buffer, 128);
+    /* printf("Size of EV Characteristics: %zu bytes\n", sizeof(EVCharacteristics_t));
+    printf("Size of evChar: %zu bytes\n", sizeof(*evChar));
+    printf("Size of evChar->VIN: %zu bytes\n",sizeof(*evChar -> vehicleIdentificationNumber));
+    printf("Size of evChar->evcc_sw: %zu bytes\n",sizeof(*evChar -> evccSoftwareVersion));
+    printf("Size of vin: %zu bytes\n", sizeof(vin));
+    printf("Size of evcc_sw: %zu bytes\n", sizeof(evcc_sw)); */
+    printf("EV Characteristics data encoded: %zu bytes\n", evChar_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&evChar_ext -> extensionValue, (char *)evChar_buffer, evChar_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, evChar_ext);
+    free(evChar_buffer);
+
+    /* (NOT STANDARD) - ExtensionID 9 - Charging Station Characteristics extension */
+    StandardizedExtension_t *evseChar_ext = calloc(1,sizeof(StandardizedExtension_t));
+    if (!evseChar_ext) {
+        perror("Failed to allocate memory for EVSE Characteristics Extension");
+        ASN_STRUCT_FREE(asn_DEF_StandardizedExtension, evseChar_ext);
+        fclose(fp);
+        return 1;
+    }
+    evseChar_ext -> extensionID = 9;
+    ChargingStationCharacteristics_t *evseChar = calloc(1, sizeof(ChargingStationCharacteristics_t));
+    evseChar -> evseID = calloc(1, sizeof(OCTET_STRING_t));
+    evseChar -> seccSoftwareVersion = calloc(1, sizeof(UTF8String_t));
+    const char evseID[] = {0x5A, 0x01};
+    const char evse_sw[] = "vXX.XX.XX";
+    OCTET_STRING_fromBuf(evseChar -> evseID, evseID, sizeof(evseID));
+    OCTET_STRING_fromBuf(evseChar -> seccSoftwareVersion, evse_sw, sizeof(evse_sw));
+    uint8_t *evseChar_buffer = calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t evseChar_enc_rval = der_encode_to_buffer(&asn_DEF_ChargingStationCharacteristics, evseChar, evseChar_buffer, 128);
+    printf("EVSE Characteristics data encoded: %zu bytes\n", evseChar_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&evseChar_ext -> extensionValue, (char *)evseChar_buffer, evseChar_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, evseChar_ext);
+    free(evseChar_buffer);
+
+    /* Encode the structure into DER format */
+    asn_enc_rval_t ec = der_encode(&asn_DEF_Extensions, extensions, write_out, fp);
+    fclose(fp);
+    if (ec.encoded == -1) {
+        fprintf(stderr, "Encoding failed: %s\n", ec.failed_type->name);
+        cleanup_extensions(extensions);
+        exit(1);
+    }
+
+    /* Print Extensions in XER format (for debugging) */
+    //xer_fprint(stdout, &asn_DEF_Extensions, extensions);
+    
+    /* Free resources on success */
+    ASN_STRUCT_FREE(asn_DEF_Extensions, extensions);  
+    fprintf(stdout, "Encoded Extensions successfully to %s\n", filename);
+    return 0;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/esdp_extensions_new.asn /ext/source/modules/EVSE/EvseV2G/asn1/esdp_extensions_new.asn
new file mode 100644
index 000000000..c752ca83d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/esdp_extensions_new.asn
@@ -0,0 +1,114 @@
+ISO15118-200 DEFINITIONS ::=
+BEGIN
+
+Extensions ::= SEQUENCE {
+    standardized	 StandardizedExtensions,
+    external	 ExternalExtensions OPTIONAL
+}
+
+StandardizedExtensions ::= SEQUENCE (SIZE(1..MAX)) OF StandardizedExtension
+
+StandardizedExtension ::= SEQUENCE {
+    extensionID	 INTEGER,
+    extensionValue	 OCTET STRING
+}
+
+ExternalExtensions ::= SEQUENCE (SIZE(1..MAX)) OF ExternalExtension
+
+ExternalExtension ::= SEQUENCE {
+    externalExtensionID	 OBJECT IDENTIFIER,
+    critical	 BOOLEAN DEFAULT TRUE,
+    extensionValue	 OCTET STRING
+}
+
+ChargingInterface ::= ENUMERATED {
+    nacs(0),
+    ccs1(1),
+    ccs2(2),
+    chademo(3),
+    chaoji(4),
+    type-1(5),
+    type-2(6),
+    mcs(7)
+}
+
+BasicSignaling ::= SEQUENCE (SIZE(1..MAX)) OF BasicSignalingProtocol
+
+BasicSignalingProtocol ::= ENUMERATED {
+    iec61851-1-ED2(0),
+    iec61851-1-ED3(1),
+    iec61851-23-ED1(2),
+    iec61851-23-ED2(3)
+}
+
+IPv6Socket ::= SEQUENCE {
+    ipv6Address	 OCTET STRING (SIZE(16)),
+    tcpPort	 OCTET STRING (SIZE(4))
+}
+
+HighLevelCommunication ::= SEQUENCE (SIZE(1..MAX)) OF HighLevelCommunicationTuple
+
+HighLevelCommunicationTuple ::= SEQUENCE {
+    hlcProtocol	 HLCProtocol,
+    securityProfileTuple	 SEQUENCE (SIZE(1..MAX)) OF SecurityProfileTuple
+}
+
+SecurityProfileTuple ::= SEQUENCE {
+    securityProfile	 SecurityProfile,
+    authorizationMethod	 SEQUENCE (SIZE(1..MAX)) OF AuthorizationMethod,
+    energyTransferMode	 SEQUENCE (SIZE(1..MAX)) OF EnergyTransferMode,
+    ...
+}
+
+HLCProtocol ::= ENUMERATED {
+    din-spec-70121-2014(0),
+    iso-15118-2-2014(1),
+    iso-15118-20-2022(2),
+    sae-j2847-2-202309(3)
+}
+
+SecurityProfile ::= ENUMERATED {
+    tcpOnly(0),
+    tls12-server(2),
+    tls13-mutual(20)
+}
+
+AuthorizationMethod ::= ENUMERATED {
+    eim(0),
+    pnc-2(1),
+    pnc-20(2)
+}
+
+EnergyTransferMode ::= ENUMERATED {
+    dc(0),
+    dc-bpt(1),
+    ac(2),
+    ac-bpt(3)
+}
+
+EMSPIdentifiers ::= SEQUENCE (SIZE(1..MAX)) OF EMSPIdentifier
+
+EMSPIdentifier ::= OCTET STRING (SIZE(1..MAX))
+
+DCChargingLimits ::= SEQUENCE {
+    maximumVoltage	 INTEGER,
+    minimumVoltage	 INTEGER,
+    ...
+}
+
+ConductiveChargingInterfaceLimitations ::= SEQUENCE {
+    maximumContactorTemperature	 INTEGER,
+    ...
+}
+
+EVCharacteristics ::= SEQUENCE {
+    vehicleIdentificationNumber	 OCTET STRING (SIZE(17)) OPTIONAL,
+    evccSoftwareVersion	 UTF8String (SIZE(1..MAX)) OPTIONAL
+}
+
+ChargingStationCharacteristics ::= SEQUENCE {
+    evseID	 OCTET STRING (SIZE(1..MAX)) OPTIONAL,
+    seccSoftwareVersion	 UTF8String (SIZE(1..MAX)) OPTIONAL
+}
+
+END
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/jer_decoder.c /ext/source/modules/EVSE/EvseV2G/asn1/jer_decoder.c
new file mode 100644
index 000000000..020591b89
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/jer_decoder.c
@@ -0,0 +1,314 @@
+/*
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "jer_support.h"		/* JER/JSON parsing support */
+
+
+/*
+ * Decode the jer encoding of a given type.
+ */
+asn_dec_rval_t
+jer_decode(const asn_codec_ctx_t *opt_codec_ctx,
+           const asn_TYPE_descriptor_t *td, void **struct_ptr,
+           const void *buffer, size_t size) {
+    asn_codec_ctx_t s_codec_ctx;
+
+	/*
+	 * Stack checker requires that the codec context
+	 * must be allocated on the stack.
+	 */
+	if(opt_codec_ctx) {
+		if(opt_codec_ctx->max_stack_size) {
+			s_codec_ctx = *opt_codec_ctx;
+			opt_codec_ctx = &s_codec_ctx;
+		}
+	} else {
+		/* If context is not given, be security-conscious anyway */
+		memset(&s_codec_ctx, 0, sizeof(s_codec_ctx));
+		s_codec_ctx.max_stack_size = ASN__DEFAULT_STACK_MAX;
+		opt_codec_ctx = &s_codec_ctx;
+	}
+
+	/*
+	 * Invoke type-specific decoder.
+	 */
+    return td->op->jer_decoder(opt_codec_ctx, td, 0, struct_ptr, buffer, size);
+}
+
+
+
+struct jer__cb_arg {
+	pjson_chunk_type_e	chunk_type;
+	size_t			chunk_size;
+	const void		*chunk_buf;
+	int callback_not_invoked;
+};
+
+static int
+jer__token_cb(pjson_chunk_type_e type, const void *_chunk_data, size_t _chunk_size, void *key) {
+	struct jer__cb_arg *arg = (struct jer__cb_arg *)key;
+	arg->chunk_type = type;
+	arg->chunk_size = _chunk_size;
+	arg->chunk_buf = _chunk_data;
+	arg->callback_not_invoked = 0;
+	return -1;	/* Terminate the JSON parsing */
+}
+
+/*
+ * Fetch the next token from the JER/JSON stream.
+ */
+ssize_t
+jer_next_token(int *stateContext, const void *buffer, size_t size, pjer_chunk_type_e *ch_type) {
+	struct jer__cb_arg arg;
+	int new_stateContext = *stateContext;
+	ssize_t ret;
+
+	arg.callback_not_invoked = 1;
+	ret = pjson_parse(&new_stateContext, buffer, size, jer__token_cb, &arg);
+	if(ret < 0) return -1;
+	if(arg.callback_not_invoked) {
+		assert(ret == 0);	/* No data was consumed */
+        *ch_type = PJER_WMORE;
+		return 0;		/* Try again with more data */
+	} else {
+		assert(arg.chunk_size);
+		assert(arg.chunk_buf == buffer);
+	}
+
+	/*
+	 * Translate the JSON chunk types into more convenient ones.
+	 */
+	switch(arg.chunk_type) {
+	case PJSON_TEXT:
+		*ch_type = PJER_TEXT;
+		break;
+	case PJSON_KEY:
+		*ch_type = PJER_WMORE;
+        break;
+    case PJSON_DLM:
+        *ch_type = PJER_DLM;
+        break;
+	case PJSON_KEY_END:
+		*ch_type = PJER_KEY;
+        break;
+	case PJSON_VALUE_END:
+		*ch_type = PJER_VALUE;
+        break;
+    default:
+		return 0;	/* Want more */
+	}
+
+	*stateContext = new_stateContext;
+	return arg.chunk_size;
+}
+
+#define LCBRAC  0x7b    /* '{' */
+#define RCBRAC  0x7d    /* '}' */
+#define	CQUOTE	0x22	/* '"' */
+#define	CCOMMA	0x2c	/* ',' */
+#define	LSBRAC	0x5b	/* '[' */
+#define	RSBRAC	0x5d	/* ']' */
+
+jer_check_sym_e
+jer_check_sym(const void *buf_ptr, int size, const char *need_key) {
+	const char *buf = (const char *)buf_ptr;
+	const char *end;
+
+    if(!need_key) { /* expected data end */
+        switch(buf[size-1]) {
+        case LCBRAC:
+            return JCK_OSTART;
+        case RCBRAC:
+            return JCK_OEND;
+        case LSBRAC:
+            return JCK_ASTART;
+        case RSBRAC:
+            return JCK_AEND;
+        case CCOMMA:
+            return JCK_COMMA;
+        default:
+            return JCK_UNKNOWN;
+        }
+    } 
+
+	if(size < 2 || 
+            (buf[0] != CQUOTE || buf[size-1] != CQUOTE)) {
+		if(size >= 2)
+			ASN_DEBUG("Broken JSON key: \"%c...%c\"",
+			buf[0], buf[size - 1]);
+		return JCK_BROKEN;
+	}
+
+    buf++;		/* advance past first quote */
+    size -= 2;	/* strip quotes */
+
+	/*
+	 * Determine the key name.
+	 */
+	for(end = buf + size; buf < end; buf++, need_key++) {
+		int b = *buf, n = *need_key;
+		if(b != n) {
+			if(n == 0) {
+				switch(b) {
+				case 0x09: case 0x0a: case 0x0c: case 0x0d:
+				case 0x20:
+					/* "abc def": accept whitespace */
+					return JCK_KEY;
+				}
+			}
+			return JCK_UNKNOWN;
+		}
+		if(b == 0)
+			return JCK_BROKEN;	/* Embedded 0 in buf?! */
+	}
+	if(*need_key)
+		return JCK_UNKNOWN;
+
+	return JCK_KEY;
+}
+
+
+#undef	ADVANCE
+#define	ADVANCE(num_bytes)	do {				\
+		size_t num = (num_bytes);			\
+		buf_ptr = ((const char *)buf_ptr) + num;	\
+		size -= num;					\
+		consumed_myself += num;				\
+	} while(0)
+
+#undef	RETURN
+#define	RETURN(_code)	do {					\
+		rval.code = _code;				\
+		rval.consumed = consumed_myself;		\
+		if(rval.code != RC_OK)				\
+			ASN_DEBUG("Failed with %d", rval.code);	\
+		return rval;					\
+	} while(0)
+
+#define	JER_GOT_BODY(chunk_buf, chunk_size, size)	do {	\
+		ssize_t converted_size = body_receiver		\
+			(struct_key, chunk_buf, chunk_size,	\
+				(size_t)chunk_size <= size);	\
+		if(converted_size == -1) RETURN(RC_FAIL);	\
+		if(converted_size == 0				\
+			&& size == (size_t)chunk_size)		\
+			RETURN(RC_WMORE);			\
+		chunk_size = converted_size;			\
+	} while(0)
+#define	JER_GOT_EMPTY()	do {					\
+	if(body_receiver(struct_key, 0, 0, size > 0) == -1)	\
+			RETURN(RC_FAIL);			\
+	} while(0)
+
+/*
+ * Generalized function for decoding the primitive values.
+ */
+asn_dec_rval_t
+jer_decode_general(const asn_codec_ctx_t *opt_codec_ctx,
+	asn_struct_ctx_t *ctx,	/* Type decoder context */
+	void *struct_key,
+	const void *buf_ptr, size_t size,
+	int (*opt_unexpected_key_decoder)
+		(void *struct_key, const void *chunk_buf, size_t chunk_size),
+	ssize_t (*body_receiver)
+		(void *struct_key, const void *chunk_buf, size_t chunk_size,
+			int have_more)
+	) {
+
+	asn_dec_rval_t rval;
+	ssize_t consumed_myself = 0;
+
+	(void)opt_codec_ctx;
+    (void)opt_unexpected_key_decoder;
+
+	/*
+	 * Phases of jer/JSON processing:
+	 * Phase 0: Check that the opening key matches our expectations.
+	 * Phase 1: Processing body and reacting on closing token.
+	 */
+	if(ctx->phase > 1) RETURN(RC_FAIL);
+	for(;;) {
+		pjer_chunk_type_e ch_type;	/* jer chunk type */
+		ssize_t ch_size;		/* Chunk size */
+
+		/*
+		 * Get the next part of the JSON stream.
+		 */
+		ch_size = jer_next_token(&ctx->context, buf_ptr, size,
+			&ch_type);
+		if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+			switch(ch_type) {
+			case PJER_WMORE:
+                RETURN(RC_WMORE);
+			case PJER_TEXT:
+                ADVANCE(ch_size);
+				continue;
+			case PJER_VALUE:
+				JER_GOT_BODY(buf_ptr, ch_size, size);
+				ADVANCE(ch_size);
+                ADVANCE(jer_whitespace_span(buf_ptr, size)); /* skip whitespace */
+                ch_size = 1;
+            case PJER_KEY:
+            case PJER_DLM:
+                break;	/* Check the rest down there */
+			}
+		}
+
+        ctx->phase = 2;	/* Phase out */
+        RETURN(RC_OK);
+
+		break;	/* Dark and mysterious things have just happened */
+	}
+
+	RETURN(RC_FAIL);
+}
+
+
+size_t
+jer_whitespace_span(const void *chunk_buf, size_t chunk_size) {
+	const char *p = (const char *)chunk_buf;
+	const char *pend = (p == NULL)? NULL : p + chunk_size;
+
+	for(; p < pend; p++) {
+		switch(*p) {
+		/* X.693, #8.1.4
+		 * HORISONTAL TAB (9)
+		 * LINE FEED (10) 
+		 * CARRIAGE RETURN (13) 
+		 * SPACE (32)
+		 */
+		case 0x09: case 0x0a: case 0x0d: case 0x20:
+			continue;
+		default:
+			break;
+		}
+		break;
+	}
+	return (p - (const char *)chunk_buf);
+}
+
+/*
+ * This is a vastly simplified, non-validating JSON tree skipper. [TODO]
+ */
+int
+jer_skip_unknown(jer_check_sym_e scv, ber_tlv_len_t *depth) {
+	assert(*depth > 0);
+	switch(scv) {
+	case JCK_KEY:
+		++(*depth);
+		return 0;
+	case JCK_COMMA:
+	case JCK_OEND:
+	case JCK_UNKNOWN:
+		if(--(*depth) == 0)
+			return (scv == JCK_OEND) ? 2 : 1;
+		return 0;
+	default:
+		return -1;
+	}
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/jer_decoder.h /ext/source/modules/EVSE/EvseV2G/asn1/jer_decoder.h
new file mode 100644
index 000000000..d0f620c23
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/jer_decoder.h
@@ -0,0 +1,109 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_JER_DECODER_H_
+#define	_JER_DECODER_H_
+
+#include "asn_application.h"
+#include "jer_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * The JER decoder of any ASN.1 type. May be invoked by the application.
+ * Decodes CANONICAL-JER and BASIC-JER.
+ */
+asn_dec_rval_t jer_decode(
+    const struct asn_codec_ctx_s *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    void **struct_ptr,  /* Pointer to a target structure's pointer */
+    const void *buffer, /* Data to be decoded */
+    size_t size         /* Size of data buffer */
+);
+
+/*
+ * Type of the type-specific JER decoder function.
+ */
+typedef asn_dec_rval_t(jer_type_decoder_f)(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_jer_constraints_t *constraints,
+    void **struct_ptr,
+    const void *buf_ptr, size_t size);
+
+/*******************************
+ * INTERNALLY USEFUL FUNCTIONS *
+ *******************************/
+
+/*
+ * Generalized function for decoding the primitive values.
+ * Used by more specialized functions, such as OCTET_STRING_decode_jer_utf8
+ * and others. This function should not be used by applications, as its API
+ * is subject to changes.
+ */
+asn_dec_rval_t jer_decode_general(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    asn_struct_ctx_t *ctx, /* Type decoder context */
+    void *struct_key,      /* Treated as opaque pointer */
+    const void *buf_ptr, size_t size,
+    int (*opt_unexpected_tag_decoder)(void *struct_key, const void *chunk_buf,
+                                      size_t chunk_size),
+    ssize_t (*body_receiver)(void *struct_key, const void *chunk_buf,
+                             size_t chunk_size, int have_more));
+
+
+/*
+ * Fetch the next JER (JSON) token from the stream.
+ * The function returns the number of bytes occupied by the chunk type,
+ * returned in the _ch_type. The _ch_type is only set (and valid) when
+ * the return value is >= 0.
+ */
+typedef enum pjer_chunk_type {
+	PJER_WMORE,     /* Chunk type is not clear, more data expected. */
+	PJER_TEXT,	    /* General data */
+	PJER_KEY,	    /* Complete JSON key */
+    PJER_VALUE,     /* Complete JSON value */
+	PJER_DLM	    /* JSON delimiter */
+  } pjer_chunk_type_e;
+ssize_t jer_next_token(int *stateContext,
+	const void *buffer, size_t size, pjer_chunk_type_e *_ch_type);
+
+/*
+ * This function checks the buffer for the current token or 
+ * against the key name expected to occur.
+ */
+typedef enum jer_check_sym {
+	JCK_BROKEN,	  /* Something is broken */
+	JCK_UNKNOWN,  /* Key or delimiter is unknown */	
+	JCK_KEY,	  /* Key is OK */
+	JCK_COMMA,    /* Delimiter is ',' */
+	JCK_OSTART,	  /* Delimiter is '{' */
+	JCK_OEND,     /* Delimiter is '}' */
+	JCK_ASTART,	  /* Delimiter is '[' */
+	JCK_AEND      /* Delimiter is ']' */
+} jer_check_sym_e;
+jer_check_sym_e jer_check_sym(const void *buf_ptr, int size,
+		const char *need_key);
+
+/*
+ * Get the number of bytes consisting entirely of JER whitespace characters.
+ * RETURN VALUES:
+ * >=0:	Number of whitespace characters in the string.
+ */
+size_t jer_whitespace_span(const void *chunk_buf, size_t chunk_size);
+
+/*
+ * Skip the series of anticipated extensions.
+ */
+int jer_skip_unknown(jer_check_sym_e scv, ber_tlv_len_t *depth);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _JER_DECODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/jer_encoder.c /ext/source/modules/EVSE/EvseV2G/asn1/jer_encoder.c
new file mode 100644
index 000000000..0d9d6202d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/jer_encoder.c
@@ -0,0 +1,58 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include <stdio.h>
+#include <errno.h>
+
+/*
+ * The JER encoder of any type. May be invoked by the application.
+ */
+asn_enc_rval_t
+jer_encode(const asn_TYPE_descriptor_t *td, const void *sptr,
+           enum jer_encoder_flags_e jer_flags,
+           asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_enc_rval_t er = {0, 0, 0};
+	asn_enc_rval_t tmper;
+
+	if(!td || !sptr) goto cb_failed;
+
+	tmper = td->op->jer_encoder(td, 0, sptr, 0, jer_flags, cb, app_key);
+	if(tmper.encoded == -1) return tmper;
+	er.encoded += tmper.encoded;
+
+	ASN__ENCODED_OK(er);
+cb_failed:
+	ASN__ENCODE_FAILED;
+}
+
+/*
+ * This is a helper function for jer_fprint, which directs all incoming data
+ * into the provided file descriptor.
+ */
+static int
+jer__print2fp(const void *buffer, size_t size, void *app_key) {
+	FILE *stream = (FILE *)app_key;
+
+	if(fwrite(buffer, 1, size, stream) != size)
+		return -1;
+
+	return 0;
+}
+
+int
+jer_fprint(FILE *stream, const asn_TYPE_descriptor_t *td, const void *sptr) {
+	asn_enc_rval_t er = {0,0,0};
+
+	if(!stream) stream = stdout;
+	if(!td || !sptr)
+		return -1;
+
+	er = jer_encode(td, sptr, JER_F, jer__print2fp, stream);
+	if(er.encoded == -1)
+		return -1;
+
+	return fflush(stream);
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/jer_encoder.h /ext/source/modules/EVSE/EvseV2G/asn1/jer_encoder.h
new file mode 100644
index 000000000..deabdb0a6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/jer_encoder.h
@@ -0,0 +1,87 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_JER_ENCODER_H_
+#define	_JER_ENCODER_H_
+
+#include "asn_application.h"
+#include "jer_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * Flags used by the jer_encode() and (*jer_type_encoder_f), defined below
+ */
+enum jer_encoder_flags_e {
+	/* Mode of encoding */
+	JER_F	        = 0x01,	/* JER (pretty-printing) */
+	JER_F_MINIFIED	= 0x02,	/* JER (minified) */
+};
+
+/*
+ * The JER encoder of any type. May be invoked by the application.
+ * Produces JER output.
+ */
+asn_enc_rval_t jer_encode(const struct asn_TYPE_descriptor_s *type_descriptor,
+                          const void *struct_ptr, /* Structure to be encoded */
+                          enum jer_encoder_flags_e jer_flags,
+                          asn_app_consume_bytes_f *consume_bytes_cb,
+                          void *app_key /* Arbitrary callback argument */
+);
+
+/*
+ * The variant of the above function which dumps the JER
+ * output into the chosen file pointer.
+ * RETURN VALUES:
+ * 	 0: The structure is printed.
+ * 	-1: Problem printing the structure.
+ * WARNING: No sensible errno value is returned.
+ */
+int jer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td,
+               const void *struct_ptr);
+
+/*
+ * A helper function that uses JER encoding/decoding to verify that:
+ * - Both structures encode into the same JER.
+ * - Both resulting JER byte streams can be decoded back.
+ * - Both decoded structures encode into the same JER (round-trip).
+ * All of this verifies equivalence between structures and a round-trip.
+ * ARGUMENTS:
+ *  (opt_debug_stream)  - If specified, prints ongoing details.
+ */
+enum jer_equivalence_e {
+    JEQ_SUCCESS,          /* The only completely positive return value */
+    JEQ_FAILURE,          /* General failure */
+    JEQ_ENCODE1_FAILED,   /* First structure JER encoding failed */
+    JEQ_ENCODE2_FAILED,   /* Second structure JER encoding failed */
+    JEQ_DIFFERENT,        /* Structures encoded into different JER */
+    JEQ_DECODE_FAILED,    /* Decode of the JER data failed */
+    JEQ_ROUND_TRIP_FAILED /* Bad round-trip */
+};
+enum jer_equivalence_e jer_equivalent(
+    const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1,
+    const void *struct2, FILE *opt_debug_stream);
+
+/*
+ * Type of the generic JER encoder.
+ */
+typedef asn_enc_rval_t(jer_type_encoder_f)(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_jer_constraints_t *constraints,
+    const void *struct_ptr, /* Structure to be encoded */
+    int ilevel,             /* Level of indentation */
+    enum jer_encoder_flags_e jer_flags,
+    asn_app_consume_bytes_f *consume_bytes_cb, /* Callback */
+    void *app_key                              /* Arbitrary callback argument */
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _JER_ENCODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/jer_support.c /ext/source/modules/EVSE/EvseV2G/asn1/jer_support.c
new file mode 100644
index 000000000..998bafe52
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/jer_support.c
@@ -0,0 +1,278 @@
+/*
+ * Copyright (c) 2003, 2004 X/IO Labs, xiolabs.com.
+ * Copyright (c) 2003, 2004, 2005 Lev Walkin <vlm@lionet.info>.
+ * 	All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_system.h"
+#include "jer_support.h"
+
+/* Parser states */
+typedef enum {
+    ST_TEXT,
+    ST_KEY,
+    ST_KEY_BODY,
+    ST_COLON,
+    ST_VALUE,
+    ST_VALUE_BODY,
+    ST_ARRAY_VALUE,
+    ST_ARRAY_VALUE_BODY,
+    ST_END
+} pstate_e;
+
+static const int _charclass[256] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, /* 01234567 89
+                                                                 */
+    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /*  ABCDEFG HIJKLMNO */
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, /* PQRSTUVW XYZ      */
+    0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /*  abcdefg hijklmno */
+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0  /* pqrstuvw xyz      */
+};
+#define WHITESPACE(c) (_charclass[(unsigned char)(c)] == 1)
+#define ALNUM(c) (_charclass[(unsigned char)(c)] >= 2)
+#define ALPHA(c) (_charclass[(unsigned char)(c)] == 3)
+
+/* Aliases for characters, ASCII/UTF-8 */
+#define CCOLON 0x3a /* ':' */
+#define LCBRAC 0x7b /* '{' */
+#define RCBRAC 0x7d /* '}' */
+#define CQUOTE 0x22 /* '"' */
+#define LSBRAC 0x5b /* '[' */
+#define RSBRAC 0x5d /* ']' */
+#define CCOMMA 0x2c /* ',' */
+
+/* Invoke token callback */
+#define TOKEN_CB_CALL(type, _ns, _current_too, _final)  \
+    do {                                                \
+        int _ret;                                       \
+        pstate_e ns = _ns;                              \
+        ssize_t _sz = (p - chunk_start) + _current_too; \
+        if(!_sz) {                                      \
+            /* Shortcut */                              \
+            state = _ns;                                \
+            break;                                      \
+        }                                               \
+        _ret = cb(type, chunk_start, _sz, key);         \
+        if(_ret < _sz) {                                \
+            if(_current_too && _ret == -1) state = ns;  \
+            goto finish;                                \
+        }                                               \
+        chunk_start = p + _current_too;                 \
+        state = ns;                                     \
+    } while(0)
+
+#define TOKEN_CB(_type, _ns, _current_too) \
+    TOKEN_CB_CALL(_type, _ns, _current_too, 0)
+
+#define PJSON_KEY_FINAL_CHUNK_TYPE PJSON_KEY_END
+#define PJSON_VALUE_FINAL_CHUNK_TYPE PJSON_VALUE_END
+
+#define TOKEN_CB_FINAL(_type, _ns, _current_too) \
+    TOKEN_CB_CALL(_type##_FINAL_CHUNK_TYPE, _ns, _current_too, 1)
+
+/*
+ * Parser itself
+ */
+ssize_t
+pjson_parse(int *stateContext, const void *jsonbuf, size_t size,
+            pjson_callback_f *cb, void *key) {
+    pstate_e state = (pstate_e)*stateContext;
+    const char *chunk_start = (const char *)jsonbuf;
+    const char *p = chunk_start;
+    const char *end = p + size;
+
+    int include = 0;
+    int in_string = 0;
+    int escaped = 0;
+
+    for(; p < end; p++) {
+        int C = *(const unsigned char *)p;
+        switch(state) {
+        case ST_TEXT:
+            /*
+             * Initial state: we're in the middle of some text,
+             * or just have started.
+             */
+
+            if(C == CQUOTE && !escaped) { /* " */
+                in_string = !in_string;
+                break;
+            } else {
+                if (C == '\\') {
+                    escaped = !escaped;
+                    break;
+                } else {
+                    escaped = 0;
+                }
+            }
+
+            if (!in_string) {
+                switch(C) {
+                case LCBRAC:
+                    /* We're now in an object */
+                    TOKEN_CB(PJSON_DLM, ST_KEY, 1);
+                    break;
+                case LSBRAC:
+                    /* We're now in an array */
+                    TOKEN_CB(PJSON_DLM, ST_ARRAY_VALUE, 1);
+                    break;
+
+                case RSBRAC:
+                    include = !(p - chunk_start);
+                    TOKEN_CB_FINAL(PJSON_VALUE, ST_TEXT, include);
+                    break;
+                case RCBRAC:
+                    include = !(p - chunk_start);
+                    TOKEN_CB_FINAL(PJSON_VALUE, ST_TEXT, include);
+                    break;
+                case CCOMMA:
+                    TOKEN_CB_FINAL(PJSON_VALUE, ST_TEXT, 0);
+                    break;
+                default:
+                    break;
+                }
+            }
+            break;
+
+        case ST_KEY: /* Looking for key */
+            switch(C) {
+            case RCBRAC: /* Empty object { } */
+                TOKEN_CB_FINAL(PJSON_VALUE, ST_TEXT, 1);
+                break;
+            case CQUOTE: /* Key start */
+                TOKEN_CB(PJSON_TEXT, ST_KEY_BODY, 0);
+                break;
+            default:
+                break;
+            }
+            break;
+
+        case ST_KEY_BODY: /* Inside key */
+            switch(C) {
+            case CQUOTE: /* Key end */
+                TOKEN_CB_FINAL(PJSON_KEY, ST_COLON, 1);
+                break;
+            default:
+                break;
+            }
+            break;
+
+		case ST_COLON: /* Looking for colon */
+			switch(C) {
+			case CCOLON:
+                state = ST_VALUE;
+				break;
+			default:
+                break;
+			}
+			break;
+
+		case ST_VALUE: /* Looking for value */
+            if (WHITESPACE(C)) {
+                break;
+            } else {
+                switch(C) {
+                case CCOMMA:
+                    TOKEN_CB(PJSON_DLM, ST_KEY, 1);
+                    break;
+                case RCBRAC:
+                    TOKEN_CB(PJSON_DLM, ST_END, 1);
+                    break;
+                case RSBRAC:
+                    TOKEN_CB_FINAL(PJSON_VALUE, ST_TEXT, 1);
+                    break;
+                default:
+                    TOKEN_CB(PJSON_TEXT, ST_VALUE_BODY, 0);
+                    break;
+                }
+            }
+			break;
+
+        case ST_VALUE_BODY: /* Inside value */
+            switch(C)  {
+            case RCBRAC:
+                TOKEN_CB_FINAL(PJSON_VALUE, ST_END, 0);
+                break;
+            case CCOMMA:
+                include = !(p - chunk_start);
+                TOKEN_CB_FINAL(PJSON_VALUE, ST_KEY, include);
+                break;
+            default:
+                break;
+            }
+            break;
+
+        case ST_ARRAY_VALUE: /* Looking for array value */
+            if (WHITESPACE(C)) {
+                break;
+            } else {
+                switch(C) {
+                case LCBRAC:
+                    TOKEN_CB(PJSON_DLM, ST_ARRAY_VALUE, 1);
+                    break;
+                case CCOMMA:
+                    TOKEN_CB(PJSON_DLM, ST_ARRAY_VALUE, 1);
+                    break;
+                case LSBRAC:
+                    TOKEN_CB(PJSON_DLM, ST_ARRAY_VALUE, 1);
+                    break;
+                case RSBRAC:
+                    TOKEN_CB(PJSON_DLM, ST_END, 1);
+                    break;
+                default:
+                    TOKEN_CB(PJSON_TEXT, ST_ARRAY_VALUE_BODY, 0);
+                    break;
+                }
+            }
+            break;
+
+        case ST_ARRAY_VALUE_BODY: /* Inside array value */
+            switch(C)  {
+            case RSBRAC:
+                include = !(p - chunk_start);
+                TOKEN_CB_FINAL(PJSON_VALUE, ST_TEXT, include);
+                break;
+            case CCOMMA:
+                include = !(p - chunk_start);
+                if (!include) {
+                    TOKEN_CB_FINAL(PJSON_VALUE, ST_ARRAY_VALUE, 0);
+                } else {
+                    TOKEN_CB(PJSON_DLM, ST_ARRAY_VALUE, 0);
+                }
+                break;
+            default:
+                break;
+            }
+            break;
+
+        case ST_END: /* End */
+            switch (C)  {
+            case RCBRAC:
+                TOKEN_CB_FINAL(PJSON_VALUE, ST_TEXT, 1);
+                break;
+            default:
+                break;
+            }
+            break;
+        } /* switch(*ptr) */
+    }     /* for() */
+
+    /*
+     * Flush the partially processed chunk, state permitting.
+     */
+    if(p - chunk_start) {
+        switch (state) {
+        case ST_TEXT:
+            TOKEN_CB_FINAL(PJSON_VALUE, state, 0);
+            break;
+        default:
+            break;
+        }
+    }
+
+finish:
+    *stateContext = (int)state;
+    return chunk_start - (const char *)jsonbuf;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/jer_support.h /ext/source/modules/EVSE/EvseV2G/asn1/jer_support.h
new file mode 100644
index 000000000..3dc93c92b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/jer_support.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2003, 2004 X/IO Labs, xiolabs.com.
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_JER_SUPPORT_H_
+#define	_JER_SUPPORT_H_
+
+#include "asn_system.h"		/* Platform-specific types */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Pre-computed JER constraints
+ */
+typedef struct asn_jer_constraints_s {
+    ssize_t size;    /* -1 (no constraint) or >= 0 */
+} asn_jer_constraints_t;
+
+/*
+ * Types of data transferred to the application.
+ */
+typedef enum {
+	PJSON_TEXT,
+	PJSON_KEY,
+	PJSON_VALUE,
+	PJSON_DLM,
+	/* 
+	 * The following chunk types are reported if the chunk
+	 * terminates the specified JSON element.
+	 */
+	PJSON_KEY_END,	 /* Key ended */
+	PJSON_VALUE_END  /* Value ended */
+} pjson_chunk_type_e;
+
+/*
+ * Callback function that is called by the parser when parsed data is
+ * available. The _opaque is the pointer to a field containing opaque user 
+ * data specified in pxml_create() call. The chunk type is _type and the text 
+ * data is the piece of buffer identified by _bufid (as supplied to
+ * pxml_feed() call) starting at offset _offset and of _size bytes size. 
+ * The chunk is NOT '\0'-terminated.
+ */
+typedef int (pjson_callback_f)(pjson_chunk_type_e _type,
+	const void *_chunk_data, size_t _chunk_size, void *_key);
+
+/*
+ * Parse the given buffer as it were a chunk of XML data.
+ * Invoke the specified callback each time the meaningful data is found.
+ * This function returns number of bytes consumed from the buffer.
+ * It will always be lesser than or equal to the specified _size.
+ * The next invocation of this function must account the difference.
+ */
+ssize_t pjson_parse(int *_stateContext, const void *_buf, size_t _size,
+	pjson_callback_f *cb, void *_key);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _JER_SUPPORT_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/oer_decoder.c /ext/source/modules/EVSE/EvseV2G/asn1/oer_decoder.c
new file mode 100644
index 000000000..accd4b2aa
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/oer_decoder.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+
+/*
+ * The OER decoder of any type.
+ */
+asn_dec_rval_t
+oer_decode(const asn_codec_ctx_t *opt_codec_ctx,
+           const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr,
+           const void *ptr, size_t size) {
+    asn_codec_ctx_t s_codec_ctx;
+
+	/*
+	 * Stack checker requires that the codec context
+	 * must be allocated on the stack.
+	 */
+	if(opt_codec_ctx) {
+		if(opt_codec_ctx->max_stack_size) {
+			s_codec_ctx = *opt_codec_ctx;
+			opt_codec_ctx = &s_codec_ctx;
+		}
+	} else {
+		/* If context is not given, be security-conscious anyway */
+		memset(&s_codec_ctx, 0, sizeof(s_codec_ctx));
+		s_codec_ctx.max_stack_size = ASN__DEFAULT_STACK_MAX;
+		opt_codec_ctx = &s_codec_ctx;
+	}
+
+	/*
+	 * Invoke type-specific decoder.
+	 */
+	return type_descriptor->op->oer_decoder(opt_codec_ctx, type_descriptor, 0,
+		struct_ptr,	/* Pointer to the destination structure */
+		ptr, size	/* Buffer and its size */
+		);
+}
+
+/*
+ * Open Type is encoded as a length (#8.6) followed by that number of bytes.
+ * Since we're just skipping, reading the length would be enough.
+ */
+ssize_t
+oer_open_type_skip(const void *bufptr, size_t size) {
+    size_t len = 0;
+    return oer_fetch_length(bufptr, size, &len);
+}
+
+/*
+ * Read the Open Type (X.696 (08/2015), #30).
+ * RETURN VALUES:
+ *       0:     More data expected than bufptr contains.
+ *      -1:     Fatal error deciphering length.
+ *      >0:     Number of bytes used from bufptr.
+ */
+ssize_t
+oer_open_type_get(const asn_codec_ctx_t *opt_codec_ctx,
+                  const struct asn_TYPE_descriptor_s *td,
+                  const asn_oer_constraints_t *constraints, void **struct_ptr,
+                  const void *bufptr, size_t size) {
+    asn_dec_rval_t dr;
+    size_t container_len = 0;
+    ssize_t len_len;
+    enum asn_struct_free_method dispose_method =
+        (*struct_ptr) ? ASFM_FREE_UNDERLYING_AND_RESET : ASFM_FREE_EVERYTHING;
+
+    /* Get the size of a length determinant */
+    len_len = oer_fetch_length(bufptr, size, &container_len);
+    if(len_len <= 0) {
+        return len_len; /* Error or more data expected */
+    }
+
+    /*
+     * len_len can't be bigger than size, but size without len_len
+     * should be bigger or equal to container length
+     */
+    if(size - len_len < container_len) {
+        /* More data is expected */
+        return 0;
+    }
+
+    dr = td->op->oer_decoder(opt_codec_ctx, td, constraints, struct_ptr,
+                         (const uint8_t *)bufptr + len_len, container_len);
+    if(dr.code == RC_OK) {
+        return len_len + container_len;
+    } else {
+        /* Even if RC_WMORE, we can't get more data into a closed container. */
+        td->op->free_struct(td, *struct_ptr, dispose_method);
+        *struct_ptr = NULL;
+        return -1;
+    }
+}
+
+
+asn_dec_rval_t
+oer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td,
+                     const asn_oer_constraints_t *constraints, void **sptr,
+                     const void *ptr, size_t size) {
+    ASN__PRIMITIVE_TYPE_t *st = (ASN__PRIMITIVE_TYPE_t *)*sptr;
+    asn_dec_rval_t rval = {RC_OK, 0};
+    size_t expected_length = 0;
+    ssize_t len_len;
+
+    (void)td;
+    (void)opt_codec_ctx;
+    (void)constraints;
+
+    if(!st) {
+        st = (ASN__PRIMITIVE_TYPE_t *)(*sptr = CALLOC(
+                                           1, sizeof(ASN__PRIMITIVE_TYPE_t)));
+        if(!st) ASN__DECODE_FAILED;
+    }
+
+
+    /*
+     * X.696 (08/2015) #27.2
+     * Encode length determinant as _number of octets_, but only
+     * if upper bound is not equal to lower bound.
+     */
+    len_len = oer_fetch_length(ptr, size, &expected_length);
+    if(len_len > 0) {
+        rval.consumed = len_len;
+        ptr = (const char *)ptr + len_len;
+        size -= len_len;
+    } else if(len_len == 0) {
+        ASN__DECODE_STARVED;
+    } else if(len_len < 0) {
+        ASN__DECODE_FAILED;
+    }
+
+    if(size < expected_length) {
+        ASN__DECODE_STARVED;
+    } else {
+        uint8_t *buf = MALLOC(expected_length + 1);
+        if(buf == NULL) {
+            ASN__DECODE_FAILED;
+        } else {
+            memcpy(buf, ptr, expected_length);
+            buf[expected_length] = '\0';
+        }
+        FREEMEM(st->buf);
+        st->buf = buf;
+        st->size = expected_length;
+
+        rval.consumed += expected_length;
+        return rval;
+    }
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/oer_decoder.h /ext/source/modules/EVSE/EvseV2G/asn1/oer_decoder.h
new file mode 100644
index 000000000..a503f5056
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/oer_decoder.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	OER_DECODER_H
+#define	OER_DECODER_H
+
+#include "asn_application.h"
+#include "oer_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+struct asn_codec_ctx_s;		/* Forward declaration */
+
+/*
+ * The Octet Encoding Rules (OER, X.696 08/2015) decoder for any given type.
+ * This function may be invoked directly by the application.
+ * Parses CANONICAL-OER and BASIC-OER.
+ */
+asn_dec_rval_t oer_decode(const struct asn_codec_ctx_s *opt_codec_ctx,
+	const struct asn_TYPE_descriptor_s *type_descriptor,
+	void **struct_ptr,	/* Pointer to a target structure's pointer */
+	const void *buffer,	/* Data to be decoded */
+	size_t size		/* Size of that buffer */
+	);
+
+/*
+ * Type of generic function which decodes the byte stream into the structure.
+ */
+typedef asn_dec_rval_t(oer_type_decoder_f)(
+    const struct asn_codec_ctx_s *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_oer_constraints_t *constraints,
+    void **struct_ptr,
+    const void *buf_ptr,
+    size_t size);
+
+/*
+ * Swallow the Open Type (X.696 (08/2015), #30) into /dev/null.
+ * RETURN VALUES:
+ *      -1:     Fatal error deciphering length.
+ *       0:     More data expected than bufptr contains.
+ *      >0:     Number of bytes used from bufptr.
+ */
+ssize_t oer_open_type_skip(const void *bufptr, size_t size);
+
+/*
+ * Read the Open Type (X.696 (08/2015), #30).
+ * RETURN VALUES:
+ *       0:     More data expected than bufptr contains.
+ *      -1:     Fatal error deciphering length.
+ *      >0:     Number of bytes used from bufptr.
+ */
+ssize_t oer_open_type_get(const asn_codec_ctx_t *opt_codec_ctx,
+                          const struct asn_TYPE_descriptor_s *td,
+                          const asn_oer_constraints_t *constraints,
+                          void **struct_ptr, const void *bufptr, size_t size);
+
+/*
+ * Length-prefixed buffer decoding for primitive types.
+ */
+oer_type_decoder_f oer_decode_primitive;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* OER_DECODER_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/oer_encoder.c /ext/source/modules/EVSE/EvseV2G/asn1/oer_encoder.c
new file mode 100644
index 000000000..aa8fb0a49
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/oer_encoder.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "asn_codecs_prim.h"
+
+/*
+ * The OER encoder of any type.
+ */
+asn_enc_rval_t
+oer_encode(const asn_TYPE_descriptor_t *type_descriptor, const void *struct_ptr,
+           asn_app_consume_bytes_f *consume_bytes, void *app_key) {
+    ASN_DEBUG("OER encoder invoked for %s", type_descriptor->name);
+
+    /*
+     * Invoke type-specific encoder.
+     */
+    return type_descriptor->op->oer_encoder(
+        type_descriptor, 0,
+        struct_ptr, /* Pointer to the destination structure */
+        consume_bytes, app_key);
+}
+
+/*
+ * Argument type and callback necessary for oer_encode_to_buffer().
+ */
+typedef struct enc_to_buf_arg {
+        void *buffer;
+        size_t left;
+} enc_to_buf_arg;
+static int
+encode_to_buffer_cb(const void *buffer, size_t size, void *key) {
+    enc_to_buf_arg *arg = (enc_to_buf_arg *)key;
+
+    if(arg->left < size) return -1; /* Data exceeds the available buffer size */
+
+    memcpy(arg->buffer, buffer, size);
+    arg->buffer = ((char *)arg->buffer) + size;
+    arg->left -= size;
+
+    return 0;
+}
+
+/*
+ * A variant of the oer_encode() which encodes the data into the provided buffer
+ */
+asn_enc_rval_t
+oer_encode_to_buffer(const asn_TYPE_descriptor_t *type_descriptor,
+                     const asn_oer_constraints_t *constraints,
+                     const void *struct_ptr, /* Structure to be encoded */
+                     void *buffer,           /* Pre-allocated buffer */
+                     size_t buffer_size      /* Initial buffer size (maximum) */
+) {
+    enc_to_buf_arg arg;
+    asn_enc_rval_t ec;
+
+    arg.buffer = buffer;
+    arg.left = buffer_size;
+
+    if(type_descriptor->op->oer_encoder == NULL) {
+        ec.encoded = -1;
+        ec.failed_type = type_descriptor;
+        ec.structure_ptr = struct_ptr;
+        ASN_DEBUG("OER encoder is not defined for %s",
+                type_descriptor->name);
+    } else {
+        ec = type_descriptor->op->oer_encoder(
+            type_descriptor, constraints,
+            struct_ptr, /* Pointer to the destination structure */
+            encode_to_buffer_cb, &arg);
+        if(ec.encoded != -1) {
+            assert(ec.encoded == (ssize_t)(buffer_size - arg.left));
+            /* Return the encoded contents size */
+        }
+    }
+    return ec;
+}
+
+asn_enc_rval_t
+oer_encode_primitive(const asn_TYPE_descriptor_t *td,
+                     const asn_oer_constraints_t *constraints, const void *sptr,
+                     asn_app_consume_bytes_f *cb, void *app_key) {
+    const ASN__PRIMITIVE_TYPE_t *st = (const ASN__PRIMITIVE_TYPE_t *)sptr;
+    asn_enc_rval_t er = {0, 0, 0};
+    ssize_t ret;
+
+    (void)constraints;
+
+    if(!st) ASN__ENCODE_FAILED;
+
+    ASN_DEBUG("Encoding %s (%" ASN_PRI_SIZE " bytes)", td ? td->name : "", st->size);
+
+    /*
+     * X.696 (08/2015) #27.2
+     */
+    ret = oer_serialize_length(st->size, cb, app_key);
+    if(ret < 0) {
+        ASN__ENCODE_FAILED;
+    }
+    er.encoded += ret;
+
+    er.encoded += st->size;
+    if(cb(st->buf, st->size, app_key) < 0) {
+        ASN__ENCODE_FAILED;
+    } else {
+        ASN__ENCODED_OK(er);
+    }
+}
+
+static int
+oer__count_bytes(const void *buffer, size_t size, void *bytes_ptr) {
+    size_t *bytes = bytes_ptr;
+    (void)buffer;
+    *bytes += size;
+    return 0;
+}
+
+ssize_t
+oer_open_type_put(const asn_TYPE_descriptor_t *td,
+                  const asn_oer_constraints_t *constraints, const void *sptr,
+                  asn_app_consume_bytes_f *cb, void *app_key) {
+    size_t serialized_byte_count = 0;
+    asn_enc_rval_t er = {0,0,0};
+    ssize_t len_len;
+
+    er = td->op->oer_encoder(td, constraints, sptr, oer__count_bytes,
+                             &serialized_byte_count);
+    if(er.encoded < 0) return -1;
+    assert(serialized_byte_count == (size_t)er.encoded);
+
+    len_len = oer_serialize_length(serialized_byte_count, cb, app_key);
+    if(len_len == -1) return -1;
+
+    er = td->op->oer_encoder(td, constraints, sptr, cb, app_key);
+    if(er.encoded < 0) return -1;
+    assert(serialized_byte_count == (size_t)er.encoded);
+
+    return len_len + er.encoded;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/oer_encoder.h /ext/source/modules/EVSE/EvseV2G/asn1/oer_encoder.h
new file mode 100644
index 000000000..3c9ebdeee
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/oer_encoder.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	OER_ENCODER_H
+#define	OER_ENCODER_H
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * The Octet Encoding Rules (OER, X.696 08/2015) encoder for any type.
+ * This function may be invoked directly by the application.
+ * Produces CANONICAL-OER output compatible with CANONICAL-OER
+ * and BASIC-OER decoders.
+ */
+asn_enc_rval_t oer_encode(const struct asn_TYPE_descriptor_s *type_descriptor,
+                          const void *struct_ptr, /* Structure to be encoded */
+                          asn_app_consume_bytes_f *consume_bytes_cb,
+                          void *app_key /* Arbitrary callback argument */
+);
+
+/* A variant of oer_encode() which encodes data into the pre-allocated buffer */
+asn_enc_rval_t oer_encode_to_buffer(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_oer_constraints_t *constraints,
+    const void *struct_ptr, /* Structure to be encoded */
+    void *buffer,           /* Pre-allocated buffer */
+    size_t buffer_size      /* Initial buffer size (maximum) */
+);
+
+/*
+ * Type of the generic OER encoder.
+ */
+typedef asn_enc_rval_t(oer_type_encoder_f)(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_oer_constraints_t *constraints,
+    const void *struct_ptr,                    /* Structure to be encoded */
+    asn_app_consume_bytes_f *consume_bytes_cb, /* Callback */
+    void *app_key                              /* Arbitrary callback argument */
+);
+
+/*
+ * Write out the Open Type (X.696 (08/2015), #30).
+ * RETURN VALUES:
+ *  -1: Fatal error encoding the type.
+ *  >0: Number of bytes serialized.
+ */
+ssize_t oer_open_type_put(const struct asn_TYPE_descriptor_s *td,
+                          const asn_oer_constraints_t *constraints,
+                          const void *struct_ptr,
+                          asn_app_consume_bytes_f *consume_bytes_cb,
+                          void *app_key);
+
+
+/*
+ * Length-prefixed buffer encoding for primitive types.
+ */
+oer_type_encoder_f oer_encode_primitive;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* OER_ENCODER_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/oer_support.c /ext/source/modules/EVSE/EvseV2G/asn1/oer_support.c
new file mode 100644
index 000000000..6a6fa5cdb
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/oer_support.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>.
+ * All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_system.h"
+#include "asn_internal.h"
+
+#include "oer_support.h"
+
+/*
+ * Fetch the length determinant (X.696 08/2015, #8.6) into *len_r.
+ * RETURN VALUES:
+ *       0:     More data expected than bufptr contains.
+ *      -1:     Fatal error deciphering length.
+ *      >0:     Number of bytes used from bufptr.
+ */
+ssize_t
+oer_fetch_length(const void *bufptr, size_t size, size_t *len_r) {
+    uint8_t first_byte;
+    size_t len_len;    /* Length of the length determinant */
+    const uint8_t *b;
+    const uint8_t *bend;
+    size_t len;
+
+    if(size == 0) {
+        *len_r = 0;
+        return 0;
+    }
+
+    first_byte = *(const uint8_t *)bufptr;
+    if((first_byte & 0x80) == 0) {   /* Short form */
+        *len_r = first_byte; /* 0..127 */
+        return 1;
+    }
+
+    len_len = (first_byte & 0x7f);
+    if((1 + len_len) > size) {
+        *len_r = 0;
+        return 0;
+    }
+
+    b = (const uint8_t *)bufptr + 1;
+    bend = b + len_len;
+
+    for(; b < bend && *b == 0; b++) {
+        /* Skip the leading 0-bytes */
+    }
+
+    if((bend - b) > (ssize_t)sizeof(size_t)) {
+        /* Length is not representable by the native size_t type */
+        *len_r = 0;
+        return -1;
+    }
+
+    for(len = 0; b < bend; b++) {
+        len = (len << 8) + *b;
+    }
+
+    if(len > RSIZE_MAX) { /* A bit of C11 validation */
+        *len_r = 0;
+        return -1;
+    }
+
+    *len_r = len;
+    assert(len_len + 1 == (size_t)(bend - (const uint8_t *)bufptr));
+    return len_len + 1;
+}
+
+
+/*
+ * Serialize OER length. Returns the number of bytes serialized
+ * or -1 if a given callback returned with negative result.
+ */
+ssize_t
+oer_serialize_length(size_t length, asn_app_consume_bytes_f *cb,
+                     void *app_key) {
+    uint8_t scratch[1 + sizeof(length)];
+    uint8_t *sp = scratch;
+    int littleEndian = 1;   /* Run-time detection */
+    const uint8_t *pstart;
+    const uint8_t *pend;
+    const uint8_t *p;
+    int add;
+
+    if(length <= 127) {
+        uint8_t b = length;
+        if(cb(&b, 1, app_key) < 0) {
+            return -1;
+        }
+        return 1;
+    }
+
+    if(*(char *)&littleEndian) {
+        pstart = (const uint8_t *)&length + sizeof(length) - 1;
+        pend = (const uint8_t *)&length;
+        add = -1;
+    } else {
+        pstart = (const uint8_t *)&length;
+        pend = pstart + sizeof(length);
+        add = 1;
+    }
+
+    for(p = pstart; p != pend; p += add) {
+        /* Skip leading zeros. */
+        if(*p) break;
+    }
+
+    for(sp = scratch + 1; ; p += add) {
+        *sp++ = *p;
+        if(p == pend) break;
+    }
+    assert((sp - scratch) - 1 <= 0x7f);
+    scratch[0] = 0x80 + ((sp - scratch) - 1);
+
+    if(cb(scratch, sp - scratch, app_key) < 0) {
+        return -1;
+    }
+
+    return sp - scratch;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/oer_support.h /ext/source/modules/EVSE/EvseV2G/asn1/oer_support.h
new file mode 100644
index 000000000..152796d45
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/oer_support.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	OER_SUPPORT_H
+#define	OER_SUPPORT_H
+
+#include "asn_system.h"		/* Platform-specific types */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Pre-computed OER constraints.
+ */
+typedef struct asn_oer_constraint_number_s {
+    unsigned width;    /* 8,4,2,1 fixed bytes */
+    unsigned positive; /* 1 for unsigned number, 0 for signed */
+} asn_oer_constraint_number_t;
+typedef struct asn_oer_constraints_s {
+    asn_oer_constraint_number_t value;
+    ssize_t size;    /* -1 (no constraint) or >= 0 */
+} asn_oer_constraints_t;
+
+
+/*
+ * Fetch the length determinant (X.696 (08/2015), #8.6) into *len_r.
+ * RETURN VALUES:
+ *       0:     More data expected than bufptr contains.
+ *      -1:     Fatal error deciphering length.
+ *      >0:     Number of bytes used from bufptr.
+ */
+ssize_t oer_fetch_length(const void *bufptr, size_t size, size_t *len_r);
+
+/*
+ * Serialize OER length. Returns the number of bytes serialized
+ * or -1 if a given callback returned with negative result.
+ */
+ssize_t oer_serialize_length(size_t length, asn_app_consume_bytes_f *cb, void *app_key);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* OER_SUPPORT_H */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_decoder.c /ext/source/modules/EVSE/EvseV2G/asn1/per_decoder.c
new file mode 100644
index 000000000..75ee69eb3
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_decoder.c
@@ -0,0 +1,5 @@
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "per_decoder.h"
+
+// Absolutely nothing
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_decoder.h /ext/source/modules/EVSE/EvseV2G/asn1/per_decoder.h
new file mode 100644
index 000000000..f7071b849
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_decoder.h
@@ -0,0 +1,30 @@
+/*-
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_PER_DECODER_H_
+#define	_PER_DECODER_H_
+
+#include "asn_application.h"
+#include "per_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * Type of the type-specific PER decoder function.
+ */
+typedef asn_dec_rval_t(per_type_decoder_f)(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_per_constraints_t *constraints, void **struct_ptr,
+    asn_per_data_t *per_data);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _PER_DECODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_encoder.c /ext/source/modules/EVSE/EvseV2G/asn1/per_encoder.c
new file mode 100644
index 000000000..4dcf5ec5d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_encoder.c
@@ -0,0 +1,35 @@
+#include "asn_internal.h"
+#include "per_encoder.h"
+
+int
+ignore_output(const void *data, size_t size, void *app_key) {
+    (void)data;
+    (void)size;
+    (void)app_key;
+    return 0;
+}
+
+int
+encode_dyn_cb(const void *buffer, size_t size, void *key) {
+    enc_dyn_arg *arg = key;
+    if(arg->length + size >= arg->allocated) {
+        size_t new_size = arg->allocated ? arg->allocated : 8;
+        void *p;
+
+        do {
+            new_size <<= 2;
+        } while(arg->length + size >= new_size);
+
+        p = REALLOC(arg->buffer, new_size);
+        if(!p) {
+            FREEMEM(arg->buffer);
+            memset(arg, 0, sizeof(*arg));
+            return -1;
+        }
+        arg->buffer = p;
+        arg->allocated = new_size;
+    }
+    memcpy(((char *)arg->buffer) + arg->length, buffer, size);
+    arg->length += size;
+    return 0;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_encoder.h /ext/source/modules/EVSE/EvseV2G/asn1/per_encoder.h
new file mode 100644
index 000000000..9a2432ef7
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_encoder.h
@@ -0,0 +1,38 @@
+/*-
+ * Copyright (c) 2006-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_PER_ENCODER_H_
+#define	_PER_ENCODER_H_
+
+#include "asn_application.h"
+#include "per_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * Type of the generic PER encoder function.
+ */
+typedef asn_enc_rval_t(per_type_encoder_f)(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_per_constraints_t *constraints, const void *struct_ptr,
+    asn_per_outp_t *per_output);
+
+int ignore_output(const void *data, size_t size, void *app_key);
+
+typedef struct enc_dyn_arg {
+    void *buffer;
+    size_t length;
+    size_t allocated;
+} enc_dyn_arg;
+int encode_dyn_cb(const void *buffer, size_t size, void *key);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _PER_ENCODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_opentype.c /ext/source/modules/EVSE/EvseV2G/asn1/per_opentype.c
new file mode 100644
index 000000000..f2e784770
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_opentype.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2007 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "per_opentype.h"
+
+/*
+ * Internal functions.
+ */
+
+asn_dec_rval_t
+uper_sot_suck(const asn_codec_ctx_t *ctx, const asn_TYPE_descriptor_t *td,
+              const asn_per_constraints_t *constraints, void **sptr,
+              asn_per_data_t *pd) {
+    asn_dec_rval_t rv;
+
+	(void)ctx;
+	(void)td;
+	(void)constraints;
+	(void)sptr;
+
+	while(per_get_few_bits(pd, 1) >= 0);
+
+	rv.code = RC_OK;
+	rv.consumed = pd->moved;
+
+	return rv;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_opentype.h /ext/source/modules/EVSE/EvseV2G/asn1/per_opentype.h
new file mode 100644
index 000000000..2825dd5db
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_opentype.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2007-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_PER_OPENTYPE_H_
+#define	_PER_OPENTYPE_H_
+
+#include "asn_internal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+asn_dec_rval_t uper_sot_suck(
+        const asn_codec_ctx_t *,
+        const asn_TYPE_descriptor_t *td,
+        const asn_per_constraints_t *constraints,
+        void **sptr, asn_per_data_t *pd);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _PER_OPENTYPE_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_support.c /ext/source/modules/EVSE/EvseV2G/asn1/per_support.c
new file mode 100644
index 000000000..2b889b56b
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_support.c
@@ -0,0 +1,9 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_system.h"
+#include "asn_internal.h"
+#include "per_support.h"
+
+// Absolutely nothing
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/per_support.h /ext/source/modules/EVSE/EvseV2G/asn1/per_support.h
new file mode 100644
index 000000000..59f69893a
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/per_support.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_PER_SUPPORT_H_
+#define	_PER_SUPPORT_H_
+
+#include "asn_system.h"		/* Platform-specific types */
+#include "asn_bit_data.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Pre-computed PER constraints.
+ */
+typedef struct asn_per_constraint_s {
+	enum asn_per_constraint_flags {
+		APC_UNCONSTRAINED	= 0x0,	/* No PER visible constraints */
+		APC_SEMI_CONSTRAINED	= 0x1,	/* Constrained at "lb" */
+		APC_CONSTRAINED		= 0x2,	/* Fully constrained */
+		APC_EXTENSIBLE		= 0x4	/* May have extension */
+	} flags;
+	int  range_bits;		/* Full number of bits in the range */
+	int  effective_bits;		/* Effective bits */
+	intmax_t lower_bound;		/* "lb" value */
+	intmax_t upper_bound;		/* "ub" value */
+} asn_per_constraint_t;
+typedef struct asn_per_constraints_s {
+	asn_per_constraint_t value;
+	asn_per_constraint_t size;
+	int (*value2code)(unsigned int value);
+	int (*code2value)(unsigned int code);
+} asn_per_constraints_t;
+
+/* Temporary compatibility layer. Will get removed. */
+typedef struct asn_bit_data_s asn_per_data_t;
+#define per_get_few_bits(data, bits)   asn_get_few_bits(data, bits)
+#define per_get_undo(data, bits)   asn_get_undo(data, bits)
+#define per_get_many_bits(data, dst, align, bits) \
+    asn_get_many_bits(data, dst, align, bits)
+
+/* Temporary compatibility layer. Will get removed. */
+typedef struct asn_bit_outp_s asn_per_outp_t;
+#define per_put_few_bits(out, bits, obits) asn_put_few_bits(out, bits, obits)
+#define per_put_many_bits(out, src, nbits) asn_put_many_bits(out, src, nbits)
+#define per_put_aligned_flush(out) asn_put_aligned_flush(out)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _PER_SUPPORT_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_decoder.c /ext/source/modules/EVSE/EvseV2G/asn1/uper_decoder.c
new file mode 100644
index 000000000..95b5465e7
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_decoder.c
@@ -0,0 +1,96 @@
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "uper_decoder.h"
+
+/*
+ * Decode a "Production of a complete encoding", X.691#10.1.
+ * The complete encoding contains at least one byte, and is an integral
+ * multiple of 8 bytes.
+ */
+asn_dec_rval_t
+uper_decode_complete(const asn_codec_ctx_t *opt_codec_ctx,
+                     const asn_TYPE_descriptor_t *td, void **sptr,
+                     const void *buffer, size_t size) {
+    asn_dec_rval_t rval;
+
+	rval = uper_decode(opt_codec_ctx, td, sptr, buffer, size, 0, 0);
+	if(rval.consumed) {
+		/*
+		 * We've always given 8-aligned data,
+		 * so convert bits to integral bytes.
+		 */
+		rval.consumed += 7;
+		rval.consumed >>= 3;
+	} else if(rval.code == RC_OK) {
+		if(size) {
+			if(((const uint8_t *)buffer)[0] == 0) {
+				rval.consumed = 1;	/* 1 byte */
+			} else {
+				ASN_DEBUG("Expecting single zeroed byte");
+				rval.code = RC_FAIL;
+			}
+		} else {
+			/* Must contain at least 8 bits. */
+			rval.code = RC_WMORE;
+		}
+	}
+
+	return rval;
+}
+
+asn_dec_rval_t
+uper_decode(const asn_codec_ctx_t *opt_codec_ctx,
+            const asn_TYPE_descriptor_t *td, void **sptr, const void *buffer,
+            size_t size, int skip_bits, int unused_bits) {
+    asn_codec_ctx_t s_codec_ctx;
+	asn_dec_rval_t rval;
+	asn_per_data_t pd;
+
+	if(skip_bits < 0 || skip_bits > 7
+	|| unused_bits < 0 || unused_bits > 7
+	|| (unused_bits > 0 && !size))
+		ASN__DECODE_FAILED;
+
+	/*
+	 * Stack checker requires that the codec context
+	 * must be allocated on the stack.
+	 */
+	if(opt_codec_ctx) {
+		if(opt_codec_ctx->max_stack_size) {
+			s_codec_ctx = *opt_codec_ctx;
+			opt_codec_ctx = &s_codec_ctx;
+		}
+	} else {
+		/* If context is not given, be security-conscious anyway */
+		memset(&s_codec_ctx, 0, sizeof(s_codec_ctx));
+		s_codec_ctx.max_stack_size = ASN__DEFAULT_STACK_MAX;
+		opt_codec_ctx = &s_codec_ctx;
+	}
+
+	/* Fill in the position indicator */
+	memset(&pd, 0, sizeof(pd));
+	pd.buffer = (const uint8_t *)buffer;
+	pd.nboff = skip_bits;
+	pd.nbits = 8 * size - unused_bits; /* 8 is CHAR_BIT from <limits.h> */
+	if(pd.nboff > pd.nbits)
+		ASN__DECODE_FAILED;
+
+	/*
+	 * Invoke type-specific decoder.
+	 */
+	if(!td->op->uper_decoder)
+		ASN__DECODE_FAILED;	/* PER is not compiled in */
+	rval = td->op->uper_decoder(opt_codec_ctx, td, 0, sptr, &pd);
+	if(rval.code == RC_OK) {
+		/* Return the number of consumed bits */
+		rval.consumed = ((pd.buffer - (const uint8_t *)buffer) << 3)
+					+ pd.nboff - skip_bits;
+		ASN_DEBUG("PER decoding consumed %ld, counted %ld",
+			(long)rval.consumed, (long)pd.moved);
+		assert(rval.consumed == pd.moved);
+	} else {
+		/* PER codec is not a restartable */
+		rval.consumed = 0;
+	}
+	return rval;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_decoder.h /ext/source/modules/EVSE/EvseV2G/asn1/uper_decoder.h
new file mode 100644
index 000000000..df3da4831
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_decoder.h
@@ -0,0 +1,47 @@
+/*-
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_UPER_DECODER_H_
+#define	_UPER_DECODER_H_
+
+#include "asn_application.h"
+#include "uper_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * Unaligned PER decoder of a "complete encoding" as per X.691 (08/2015) #11.1.
+ * On success, this call always returns (.consumed >= 1), as per #11.1.3.
+ */
+asn_dec_rval_t uper_decode_complete(
+    const struct asn_codec_ctx_s *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor, /* Type to decode */
+    void **struct_ptr,  /* Pointer to a target structure's pointer */
+    const void *buffer, /* Data to be decoded */
+    size_t size         /* Size of data buffer */
+);
+
+/*
+ * Unaligned PER decoder of any ASN.1 type. May be invoked by the application.
+ * WARNING: This call returns the number of BITS read from the stream. Beware.
+ */
+asn_dec_rval_t uper_decode(
+    const struct asn_codec_ctx_s *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor, /* Type to decode */
+    void **struct_ptr,  /* Pointer to a target structure's pointer */
+    const void *buffer, /* Data to be decoded */
+    size_t size,        /* Size of the input data buffer, in bytes */
+    int skip_bits,      /* Number of unused leading bits, 0..7 */
+    int unused_bits     /* Number of unused tailing bits, 0..7 */
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _UPER_DECODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_encoder.c /ext/source/modules/EVSE/EvseV2G/asn1/uper_encoder.c
new file mode 100644
index 000000000..e5120c631
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_encoder.c
@@ -0,0 +1,127 @@
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "uper_encoder.h"
+
+static int _uper_encode_flush_outp(asn_per_outp_t *po);
+
+asn_enc_rval_t
+uper_encode(const asn_TYPE_descriptor_t *td,
+            const asn_per_constraints_t *constraints, const void *sptr,
+            asn_app_consume_bytes_f *cb, void *app_key) {
+    asn_per_outp_t po;
+    asn_enc_rval_t er = {0,0,0};
+
+    /*
+     * Invoke type-specific encoder.
+     */
+    if(!td || !td->op->uper_encoder)
+        ASN__ENCODE_FAILED;	/* PER is not compiled in */
+
+    po.buffer = po.tmpspace;
+    po.nboff = 0;
+    po.nbits = 8 * sizeof(po.tmpspace);
+    po.output = cb ? cb : ignore_output;
+    po.op_key = app_key;
+    po.flushed_bytes = 0;
+
+    er = td->op->uper_encoder(td, constraints, sptr, &po);
+    if(er.encoded != -1) {
+        size_t bits_to_flush;
+
+        bits_to_flush = ((po.buffer - po.tmpspace) << 3) + po.nboff;
+
+        /* Set number of bits encoded to a firm value */
+        er.encoded = (po.flushed_bytes << 3) + bits_to_flush;
+
+        if(_uper_encode_flush_outp(&po)) ASN__ENCODE_FAILED;
+    }
+
+    return er;
+}
+
+/*
+ * Argument type and callback necessary for uper_encode_to_buffer().
+ */
+typedef struct enc_to_buf_arg {
+	void *buffer;
+	size_t left;
+} enc_to_buf_arg;
+static int encode_to_buffer_cb(const void *buffer, size_t size, void *key) {
+	enc_to_buf_arg *arg = (enc_to_buf_arg *)key;
+
+	if(arg->left < size)
+		return -1;	/* Data exceeds the available buffer size */
+
+	memcpy(arg->buffer, buffer, size);
+	arg->buffer = ((char *)arg->buffer) + size;
+	arg->left -= size;
+
+	return 0;
+}
+
+asn_enc_rval_t
+uper_encode_to_buffer(const asn_TYPE_descriptor_t *td,
+                      const asn_per_constraints_t *constraints,
+                      const void *sptr, void *buffer, size_t buffer_size) {
+    enc_to_buf_arg key;
+
+    key.buffer = buffer;
+    key.left = buffer_size;
+
+    if(td) ASN_DEBUG("Encoding \"%s\" using UNALIGNED PER", td->name);
+
+    return uper_encode(td, constraints, sptr, encode_to_buffer_cb, &key);
+}
+
+ssize_t
+uper_encode_to_new_buffer(const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints,
+                          const void *sptr, void **buffer_r) {
+    asn_enc_rval_t er = {0,0,0};
+	enc_dyn_arg key;
+
+	memset(&key, 0, sizeof(key));
+
+	er = uper_encode(td, constraints, sptr, encode_dyn_cb, &key);
+	switch(er.encoded) {
+	case -1:
+		FREEMEM(key.buffer);
+		return -1;
+	case 0:
+		FREEMEM(key.buffer);
+		key.buffer = MALLOC(1);
+		if(key.buffer) {
+			*(char *)key.buffer = '\0';
+			*buffer_r = key.buffer;
+			return 1;
+		} else {
+			return -1;
+		}
+	default:
+		*buffer_r = key.buffer;
+		ASN_DEBUG("Complete encoded in %ld bits", (long)er.encoded);
+		return ((er.encoded + 7) >> 3);
+	}
+}
+
+/*
+ * Internally useful functions.
+ */
+
+/* Flush partially filled buffer */
+static int
+_uper_encode_flush_outp(asn_per_outp_t *po) {
+	uint8_t *buf;
+
+	if(po->nboff == 0 && po->buffer == po->tmpspace)
+		return 0;
+
+	buf = po->buffer + (po->nboff >> 3);
+	/* Make sure we account for the last, partially filled */
+	if(po->nboff & 0x07) {
+		buf[0] &= 0xff << (8 - (po->nboff & 0x07));
+		buf++;
+	}
+
+	return po->output(po->tmpspace, buf - po->tmpspace, po->op_key);
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_encoder.h /ext/source/modules/EVSE/EvseV2G/asn1/uper_encoder.h
new file mode 100644
index 000000000..044baf126
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_encoder.h
@@ -0,0 +1,62 @@
+/*-
+ * Copyright (c) 2006-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_UPER_ENCODER_H_
+#define	_UPER_ENCODER_H_
+
+#include "asn_application.h"
+#include "uper_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * Unaligned PER encoder of any ASN.1 type. May be invoked by the application.
+ * WARNING: This function returns the number of encoded bits in the .encoded
+ * field of the return value. Use the following formula to convert to bytes:
+ * 	bytes = ((.encoded + 7) / 8)
+ */
+asn_enc_rval_t uper_encode(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_per_constraints_t *constraints,
+    const void *struct_ptr,                    /* Structure to be encoded */
+    asn_app_consume_bytes_f *consume_bytes_cb, /* Data collector */
+    void *app_key                              /* Arbitrary callback argument */
+);
+
+/*
+ * A variant of uper_encode() which encodes data into the existing buffer
+ * WARNING: This function returns the number of encoded bits in the .encoded
+ * field of the return value.
+ */
+asn_enc_rval_t uper_encode_to_buffer(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_per_constraints_t *constraints,
+    const void *struct_ptr, /* Structure to be encoded */
+    void *buffer,           /* Pre-allocated buffer */
+    size_t buffer_size      /* Initial buffer size (max) */
+);
+
+/*
+ * A variant of uper_encode_to_buffer() which allocates buffer itself.
+ * Returns the number of bytes in the buffer or -1 in case of failure.
+ * WARNING: This function produces a "Production of the complete encoding",
+ * with length of at least one octet. Contrast this to precise bit-packing
+ * encoding of uper_encode() and uper_encode_to_buffer().
+ */
+ssize_t uper_encode_to_new_buffer(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const asn_per_constraints_t *constraints,
+    const void *struct_ptr, /* Structure to be encoded */
+    void **buffer_r         /* Buffer allocated and returned */
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _UPER_ENCODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_opentype.c /ext/source/modules/EVSE/EvseV2G/asn1/uper_opentype.c
new file mode 100644
index 000000000..6f96a35d2
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_opentype.c
@@ -0,0 +1,372 @@
+/*
+ * Copyright (c) 2007 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include "uper_encoder.h"
+#include "uper_support.h"
+#include "uper_opentype.h"
+
+typedef struct uper_ugot_key {
+	asn_per_data_t oldpd;	/* Old per data source */
+	size_t unclaimed;
+	size_t ot_moved;	/* Number of bits moved by OT processing */
+	int repeat;
+} uper_ugot_key;
+
+static int uper_ugot_refill(asn_per_data_t *pd);
+static int per_skip_bits(asn_per_data_t *pd, int skip_nbits);
+
+/*
+ * Encode an "open type field".
+ * #10.1, #10.2
+ */
+int
+uper_open_type_put(const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, const void *sptr,
+                   asn_per_outp_t *po) {
+    void *buf;
+    void *bptr;
+    ssize_t size;
+
+    ASN_DEBUG("Open type put %s ...", td->name);
+
+    size = uper_encode_to_new_buffer(td, constraints, sptr, &buf);
+    if(size <= 0) return -1;
+
+    ASN_DEBUG("Open type put %s of length %" ASN_PRI_SSIZE " + overhead (1byte?)", td->name,
+              size);
+
+    bptr = buf;
+    do {
+        int need_eom = 0;
+        ssize_t may_save = uper_put_length(po, size, &need_eom);
+        ASN_DEBUG("Prepending length %" ASN_PRI_SSIZE
+                  " to %s and allowing to save %" ASN_PRI_SSIZE,
+                  size, td->name, may_save);
+        if(may_save < 0) break;
+        if(per_put_many_bits(po, bptr, may_save * 8)) break;
+        bptr = (char *)bptr + may_save;
+        size -= may_save;
+        if(need_eom && uper_put_length(po, 0, 0)) {
+            FREEMEM(buf);
+            return -1;
+        }
+    } while(size);
+
+    FREEMEM(buf);
+    if(size) return -1;
+
+    return 0;
+}
+
+static asn_dec_rval_t
+uper_open_type_get_simple(const asn_codec_ctx_t *ctx,
+                          const asn_TYPE_descriptor_t *td,
+                          const asn_per_constraints_t *constraints, void **sptr,
+                          asn_per_data_t *pd) {
+    asn_dec_rval_t rv;
+	ssize_t chunk_bytes;
+	int repeat;
+	uint8_t *buf = 0;
+	size_t bufLen = 0;
+	size_t bufSize = 0;
+	asn_per_data_t spd;
+	size_t padding;
+
+	ASN__STACK_OVERFLOW_CHECK(ctx);
+
+	ASN_DEBUG("Getting open type %s...", td->name);
+
+	do {
+		chunk_bytes = uper_get_length(pd, -1, 0, &repeat);
+		if(chunk_bytes < 0) {
+			FREEMEM(buf);
+			ASN__DECODE_STARVED;
+		}
+		if(bufLen + chunk_bytes > bufSize) {
+			void *ptr;
+			bufSize = chunk_bytes + (bufSize << 2);
+			ptr = REALLOC(buf, bufSize);
+			if(!ptr) {
+				FREEMEM(buf);
+				ASN__DECODE_FAILED;
+			}
+			buf = ptr;
+		}
+		if(per_get_many_bits(pd, (buf == NULL)? NULL : buf + bufLen, 0, chunk_bytes << 3)) {
+			FREEMEM(buf);
+			ASN__DECODE_STARVED;
+		}
+		bufLen += chunk_bytes;
+	} while(repeat);
+
+	ASN_DEBUG("Getting open type %s encoded in %ld bytes", td->name,
+		(long)bufLen);
+
+	memset(&spd, 0, sizeof(spd));
+	spd.buffer = buf;
+	spd.nbits = bufLen << 3;
+
+	ASN_DEBUG_INDENT_ADD(+4);
+	rv = td->op->uper_decoder(ctx, td, constraints, sptr, &spd);
+	ASN_DEBUG_INDENT_ADD(-4);
+
+	if(rv.code == RC_OK) {
+		/* Check padding validity */
+		padding = spd.nbits - spd.nboff;
+                if (((padding > 0 && padding < 8) ||
+		/* X.691#10.1.3 */
+		(spd.nboff == 0 && spd.nbits == 8 && spd.buffer == buf)) &&
+                    per_get_few_bits(&spd, padding) == 0) {
+			/* Everything is cool */
+			FREEMEM(buf);
+			return rv;
+		}
+		FREEMEM(buf);
+		if(padding >= 8) {
+			ASN_DEBUG("Too large padding %d in open type", (int)padding);
+			ASN__DECODE_FAILED;
+		} else {
+			ASN_DEBUG("No padding");
+		}
+	} else {
+		FREEMEM(buf);
+		/* rv.code could be RC_WMORE, nonsense in this context */
+		rv.code = RC_FAIL; /* No one would give us more */
+	}
+
+	return rv;
+}
+
+static asn_dec_rval_t CC_NOTUSED
+uper_open_type_get_complex(const asn_codec_ctx_t *ctx,
+                           const asn_TYPE_descriptor_t *td,
+                           asn_per_constraints_t *constraints, void **sptr,
+                           asn_per_data_t *pd) {
+    uper_ugot_key arg;
+	asn_dec_rval_t rv;
+	ssize_t padding;
+
+	ASN__STACK_OVERFLOW_CHECK(ctx);
+
+	ASN_DEBUG("Getting open type %s from %s", td->name,
+		asn_bit_data_string(pd));
+	arg.oldpd = *pd;
+	arg.unclaimed = 0;
+	arg.ot_moved = 0;
+	arg.repeat = 1;
+	pd->refill = uper_ugot_refill;
+	pd->refill_key = &arg;
+	pd->nbits = pd->nboff;	/* 0 good bits at this point, will refill */
+	pd->moved = 0;	/* This now counts the open type size in bits */
+
+	ASN_DEBUG_INDENT_ADD(+4);
+	rv = td->op->uper_decoder(ctx, td, constraints, sptr, pd);
+	ASN_DEBUG_INDENT_ADD(-4);
+
+#define	UPDRESTOREPD	do {						\
+	/* buffer and nboff are valid, preserve them. */		\
+	pd->nbits = arg.oldpd.nbits - (pd->moved - arg.ot_moved);	\
+	pd->moved = arg.oldpd.moved + (pd->moved - arg.ot_moved);	\
+	pd->refill = arg.oldpd.refill;					\
+	pd->refill_key = arg.oldpd.refill_key;				\
+  } while(0)
+
+	if(rv.code != RC_OK) {
+		UPDRESTOREPD;
+		return rv;
+	}
+
+	ASN_DEBUG("OpenType %s pd%s old%s unclaimed=%d, repeat=%d", td->name,
+		asn_bit_data_string(pd),
+		asn_bit_data_string(&arg.oldpd),
+		(int)arg.unclaimed, (int)arg.repeat);
+
+	padding = pd->moved % 8;
+	if(padding) {
+		int32_t pvalue;
+		if(padding > 7) {
+			ASN_DEBUG("Too large padding %d in open type",
+				(int)padding);
+			rv.code = RC_FAIL;
+			UPDRESTOREPD;
+			return rv;
+		}
+		padding = 8 - padding;
+		ASN_DEBUG("Getting padding of %d bits", (int)padding);
+		pvalue = per_get_few_bits(pd, padding);
+		switch(pvalue) {
+		case -1:
+			ASN_DEBUG("Padding skip failed");
+			UPDRESTOREPD;
+			ASN__DECODE_STARVED;
+		case 0: break;
+		default:
+			ASN_DEBUG("Non-blank padding (%d bits 0x%02x)",
+				(int)padding, (int)pvalue);
+			UPDRESTOREPD;
+			ASN__DECODE_FAILED;
+		}
+	}
+	if(pd->nboff != pd->nbits) {
+		ASN_DEBUG("Open type %s overhead pd%s old%s", td->name,
+			asn_bit_data_string(pd), asn_bit_data_string(&arg.oldpd));
+		if(1) {
+			UPDRESTOREPD;
+			ASN__DECODE_FAILED;
+		} else {
+			arg.unclaimed += pd->nbits - pd->nboff;
+		}
+	}
+
+	/* Adjust pd back so it points to original data */
+	UPDRESTOREPD;
+
+	/* Skip data not consumed by the decoder */
+	if(arg.unclaimed) {
+		ASN_DEBUG("Getting unclaimed %d", (int)arg.unclaimed);
+		switch(per_skip_bits(pd, arg.unclaimed)) {
+		case -1:
+			ASN_DEBUG("Claim of %d failed", (int)arg.unclaimed);
+			ASN__DECODE_STARVED;
+		case 0:
+			ASN_DEBUG("Got claim of %d", (int)arg.unclaimed);
+			break;
+		default:
+			/* Padding must be blank */
+			ASN_DEBUG("Non-blank unconsumed padding");
+			ASN__DECODE_FAILED;
+		}
+		arg.unclaimed = 0;
+	}
+
+	if(arg.repeat) {
+		ASN_DEBUG("Not consumed the whole thing");
+		rv.code = RC_FAIL;
+		return rv;
+	}
+
+	return rv;
+}
+
+
+asn_dec_rval_t
+uper_open_type_get(const asn_codec_ctx_t *ctx, const asn_TYPE_descriptor_t *td,
+                   const asn_per_constraints_t *constraints, void **sptr,
+                   asn_per_data_t *pd) {
+    return uper_open_type_get_simple(ctx, td, constraints, sptr, pd);
+}
+
+int
+uper_open_type_skip(const asn_codec_ctx_t *ctx, asn_per_data_t *pd) {
+	asn_TYPE_descriptor_t s_td;
+    asn_TYPE_operation_t s_op;
+	asn_dec_rval_t rv;
+
+	s_td.name = "<unknown extension>";
+	s_td.op = &s_op;
+    s_op.uper_decoder = uper_sot_suck;
+
+	rv = uper_open_type_get(ctx, &s_td, 0, 0, pd);
+	if(rv.code != RC_OK)
+		return -1;
+	else
+		return 0;
+}
+
+/*
+ * Internal functions.
+ */
+
+static int
+uper_ugot_refill(asn_per_data_t *pd) {
+	uper_ugot_key *arg = pd->refill_key;
+	ssize_t next_chunk_bytes, next_chunk_bits;
+	ssize_t avail;
+
+	asn_per_data_t *oldpd = &arg->oldpd;
+
+	ASN_DEBUG("REFILLING pd->moved=%ld, oldpd->moved=%ld",
+		(long)pd->moved, (long)oldpd->moved);
+
+	/* Advance our position to where pd is */
+	oldpd->buffer = pd->buffer;
+	oldpd->nboff  = pd->nboff;
+	oldpd->nbits -= pd->moved - arg->ot_moved;
+	oldpd->moved += pd->moved - arg->ot_moved;
+	arg->ot_moved = pd->moved;
+
+	if(arg->unclaimed) {
+		/* Refill the container */
+		if(per_get_few_bits(oldpd, 1))
+			return -1;
+		if(oldpd->nboff == 0) {
+			assert(0);
+			return -1;
+		}
+		pd->buffer = oldpd->buffer;
+		pd->nboff = oldpd->nboff - 1;
+		pd->nbits = oldpd->nbits;
+		ASN_DEBUG("UNCLAIMED <- return from (pd->moved=%ld)",
+			(long)pd->moved);
+		return 0;
+	}
+
+	if(!arg->repeat) {
+		ASN_DEBUG("Want more but refill doesn't have it");
+		return -1;
+	}
+
+	next_chunk_bytes = uper_get_length(oldpd, -1, 0, &arg->repeat);
+	ASN_DEBUG("Open type LENGTH %ld bytes at off %ld, repeat %ld",
+		(long)next_chunk_bytes, (long)oldpd->moved, (long)arg->repeat);
+	if(next_chunk_bytes < 0) return -1;
+	if(next_chunk_bytes == 0) {
+		pd->refill = 0;	/* No more refills, naturally */
+		assert(!arg->repeat);	/* Implementation guarantee */
+	}
+	next_chunk_bits = next_chunk_bytes << 3;
+	avail = oldpd->nbits - oldpd->nboff;
+	if(avail >= next_chunk_bits) {
+		pd->nbits = oldpd->nboff + next_chunk_bits;
+		arg->unclaimed = 0;
+		ASN_DEBUG("!+Parent frame %ld bits, alloting %ld [%ld..%ld] (%ld)",
+			(long)next_chunk_bits, (long)oldpd->moved,
+			(long)oldpd->nboff, (long)oldpd->nbits,
+			(long)(oldpd->nbits - oldpd->nboff));
+	} else {
+		pd->nbits = oldpd->nbits;
+		arg->unclaimed = next_chunk_bits - avail;
+		ASN_DEBUG("!-Parent frame %ld, require %ld, will claim %ld",
+			(long)avail, (long)next_chunk_bits,
+			(long)arg->unclaimed);
+	}
+	pd->buffer = oldpd->buffer;
+	pd->nboff = oldpd->nboff;
+	ASN_DEBUG("Refilled pd%s old%s",
+		asn_bit_data_string(pd), asn_bit_data_string(oldpd));
+	return 0;
+}
+
+static int
+per_skip_bits(asn_per_data_t *pd, int skip_nbits) {
+	int hasNonZeroBits = 0;
+	while(skip_nbits > 0) {
+		int skip;
+
+		/* per_get_few_bits() is more efficient when nbits <= 24 */
+		if(skip_nbits < 24)
+			skip = skip_nbits;
+		else
+			skip = 24;
+		skip_nbits -= skip;
+
+		switch(per_get_few_bits(pd, skip)) {
+		case -1: return -1;	/* Starving */
+		case 0: continue;	/* Skipped empty space */
+		default: hasNonZeroBits = 1; continue;
+		}
+	}
+	return hasNonZeroBits;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_opentype.h /ext/source/modules/EVSE/EvseV2G/asn1/uper_opentype.h
new file mode 100644
index 000000000..421fa1983
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_opentype.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2007-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_UPER_OPENTYPE_H_
+#define	_UPER_OPENTYPE_H_
+
+#include "per_opentype.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+asn_dec_rval_t uper_open_type_get(const asn_codec_ctx_t *opt_codec_ctx,
+                                  const asn_TYPE_descriptor_t *td,
+                                  const asn_per_constraints_t *constraints,
+                                  void **sptr, asn_per_data_t *pd);
+
+int uper_open_type_skip(const asn_codec_ctx_t *opt_codec_ctx,
+                        asn_per_data_t *pd);
+
+/*
+ * X.691 (2015/08), #11.2
+ * Returns -1 if error is encountered. 0 if all OK.
+ */
+int uper_open_type_put(const asn_TYPE_descriptor_t *td,
+                       const asn_per_constraints_t *constraints,
+                       const void *sptr, asn_per_outp_t *po);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _UPER_OPENTYPE_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_support.c /ext/source/modules/EVSE/EvseV2G/asn1/uper_support.c
new file mode 100644
index 000000000..231bda9a1
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_support.c
@@ -0,0 +1,311 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_system.h"
+#include "asn_internal.h"
+#include "uper_support.h"
+
+/*
+ * X.691-201508 #10.9 General rules for encoding a length determinant.
+ * Get the optionally constrained length "n" from the stream.
+ */
+ssize_t
+uper_get_length(asn_per_data_t *pd, int ebits, size_t lower_bound,
+                int *repeat) {
+    ssize_t value;
+
+    *repeat = 0;
+
+    /* #11.9.4.1 Encoding if constrained (according to effective bits) */
+    if(ebits >= 0 && ebits <= 16) {
+        value = per_get_few_bits(pd, ebits);
+        if(value >= 0) value += lower_bound;
+        return value;
+    }
+
+	value = per_get_few_bits(pd, 8);
+    if((value & 0x80) == 0) { /* #11.9.3.6 */
+        return (value & 0x7F);
+    } else if((value & 0x40) == 0) { /* #11.9.3.7 */
+        /* bit 8 ... set to 1 and bit 7 ... set to zero */
+        value = ((value & 0x3f) << 8) | per_get_few_bits(pd, 8);
+        return value; /* potential -1 from per_get_few_bits passes through. */
+    } else if(value < 0) {
+        ASN_DEBUG("END of stream reached for PER");
+        return -1;
+    }
+    value &= 0x3f; /* this is "m" from X.691, #11.9.3.8 */
+    if(value < 1 || value > 4) {
+        return -1; /* Prohibited by #11.9.3.8 */
+    }
+    *repeat = 1;
+    return (16384 * value);
+}
+
+/*
+ * Get the normally small length "n".
+ * This procedure used to decode length of extensions bit-maps
+ * for SET and SEQUENCE types.
+ */
+ssize_t
+uper_get_nslength(asn_per_data_t *pd) {
+	ssize_t length;
+
+	ASN_DEBUG("Getting normally small length");
+
+	if(per_get_few_bits(pd, 1) == 0) {
+		length = per_get_few_bits(pd, 6) + 1;
+		if(length <= 0) return -1;
+		ASN_DEBUG("l=%d", (int)length);
+		return length;
+	} else {
+		int repeat;
+		length = uper_get_length(pd, -1, 0, &repeat);
+		if(length >= 0 && !repeat) return length;
+		return -1; /* Error, or do not support >16K extensions */
+	}
+}
+
+/*
+ * Get the normally small non-negative whole number.
+ * X.691, #10.6
+ */
+ssize_t
+uper_get_nsnnwn(asn_per_data_t *pd) {
+	ssize_t value;
+
+	value = per_get_few_bits(pd, 7);
+	if(value & 64) {	/* implicit (value < 0) */
+		value &= 63;
+		value <<= 2;
+		value |= per_get_few_bits(pd, 2);
+		if(value & 128)	/* implicit (value < 0) */
+			return -1;
+		if(value == 0)
+			return 0;
+		if(value >= 3)
+			return -1;
+		value = per_get_few_bits(pd, 8 * value);
+		return value;
+	}
+
+	return value;
+}
+
+/*
+ * X.691-11/2008, #11.6
+ * Encoding of a normally small non-negative whole number
+ */
+int
+uper_put_nsnnwn(asn_per_outp_t *po, int n) {
+	int bytes;
+
+	if(n <= 63) {
+		if(n < 0) return -1;
+		return per_put_few_bits(po, n, 7);
+	}
+	if(n < 256)
+		bytes = 1;
+	else if(n < 65536)
+		bytes = 2;
+	else if(n < 256 * 65536)
+		bytes = 3;
+	else
+		return -1;	/* This is not a "normally small" value */
+	if(per_put_few_bits(po, bytes, 8))
+		return -1;
+
+	return per_put_few_bits(po, n, 8 * bytes);
+}
+
+
+/* X.691-2008/11, #11.5.6 -> #11.3 */
+int uper_get_constrained_whole_number(asn_per_data_t *pd, uintmax_t *out_value, int nbits) {
+	uintmax_t lhalf;    /* Lower half of the number*/
+	intmax_t half;
+
+	if(nbits <= 31) {
+		half = per_get_few_bits(pd, nbits);
+		if(half < 0) return -1;
+		*out_value = half;
+		return 0;
+	}
+
+	if((size_t)nbits > 8 * sizeof(*out_value))
+		return -1;  /* RANGE */
+
+	half = per_get_few_bits(pd, 31);
+	if(half < 0) return -1;
+
+	if(uper_get_constrained_whole_number(pd, &lhalf, nbits - 31))
+		return -1;
+
+	*out_value = ((uintmax_t)half << (nbits - 31)) | lhalf;
+	return 0;
+}
+
+
+/* X.691-2008/11, #11.5.6 -> #11.3 */
+int
+uper_put_constrained_whole_number_u(asn_per_outp_t *po, uintmax_t v,
+                                    int nbits) {
+    if(nbits <= 31) {
+        return per_put_few_bits(po, v, nbits);
+    } else {
+        /* Put higher portion first, followed by lower 31-bit */
+        if(uper_put_constrained_whole_number_u(po, v >> 31, nbits - 31))
+            return -1;
+        return per_put_few_bits(po, v, 31);
+    }
+}
+
+/*
+ * X.691 (08/2015) #11.9 "General rules for encoding a length determinant"
+ * Put the length "n" (or part of it) into the stream.
+ */
+ssize_t
+uper_put_length(asn_per_outp_t *po, size_t length, int *need_eom) {
+    int dummy = 0;
+    if(!need_eom) need_eom = &dummy;
+
+    if(length <= 127) {	/* #11.9.3.6 */
+        *need_eom = 0;
+        return per_put_few_bits(po, length, 8)
+            ? -1 : (ssize_t)length;
+    } else if(length < 16384) { /* #10.9.3.7 */
+        *need_eom = 0;
+        return per_put_few_bits(po, length|0x8000, 16)
+            ? -1 : (ssize_t)length;
+    }
+
+    *need_eom = 0 == (length & 16383);
+    length >>= 14;
+    if(length > 4) {
+        *need_eom = 0;
+        length = 4;
+    }
+
+    return per_put_few_bits(po, 0xC0 | length, 8)
+            ? -1 : (ssize_t)(length << 14);
+
+}
+
+
+/*
+ * Put the normally small length "n" into the stream.
+ * This procedure used to encode length of extensions bit-maps
+ * for SET and SEQUENCE types.
+ */
+int
+uper_put_nslength(asn_per_outp_t *po, size_t length) {
+    if(length <= 64) {
+        /* #11.9.3.4 */
+        if(length == 0) return -1;
+        return per_put_few_bits(po, length - 1, 7) ? -1 : 0;
+    } else {
+        int need_eom = 0;
+        if(uper_put_length(po, length, &need_eom) != (ssize_t)length
+           || need_eom) {
+            /* This might happen in case of >16K extensions */
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int
+per__imax_range(intmax_t lb, intmax_t ub, uintmax_t *range_r) {
+    uintmax_t bounds_range;
+    if((ub < 0) == (lb < 0)) {
+        bounds_range = ub - lb;
+    } else if(lb < 0) {
+        assert(ub >= 0);
+        bounds_range = 1 + ((uintmax_t)ub + (uintmax_t)-(lb + 1));
+    } else {
+        assert(!"Unreachable");
+        return -1;
+    }
+    *range_r = bounds_range;
+    return 0;
+}
+
+int
+per_imax_range_rebase(intmax_t v, intmax_t lb, intmax_t ub, uintmax_t *output) {
+    uintmax_t range;
+
+    assert(lb <= ub);
+
+    if(v < lb || v > ub || per__imax_range(lb, ub, &range) < 0) {
+        /* Range error. */
+        return -1;
+    }
+
+    /*
+     * Fundamentally what we're doing is returning (v-lb).
+     * However, this triggers undefined behavior when the word width
+     * of signed (v) is the same as the size of unsigned (*output).
+     * In practice, it triggers the UndefinedSanitizer. Therefore we shall
+     * compute the ranges accurately to avoid C's undefined behavior.
+     */
+    if((v < 0) == (lb < 0)) {
+        *output = v-lb;
+        return 0;
+    } else if(v < 0) {
+        uintmax_t rebased = 1 + (uintmax_t)-(v+1) + (uintmax_t)lb;
+        assert(rebased <= range);   /* By construction */
+        *output = rebased;
+        return 0;
+    } else if(lb < 0) {
+        uintmax_t rebased = 1 + (uintmax_t)-(lb+1) + (uintmax_t)v;
+        assert(rebased <= range);   /* By construction */
+        *output = rebased;
+        return 0;
+    } else {
+        assert(!"Unreachable");
+        return -1;
+    }
+}
+
+int
+per_long_range_rebase(long v, intmax_t lb, intmax_t ub, unsigned long *output) {
+    uintmax_t tmp = *output;
+    int rc = per_imax_range_rebase((intmax_t)v, lb, ub, &tmp);
+    *output = tmp;
+    return rc;
+}
+
+int
+per_imax_range_unrebase(uintmax_t inp, intmax_t lb, intmax_t ub, intmax_t *outp) {
+    uintmax_t range;
+
+    if(per__imax_range(lb, ub, &range) != 0) {
+        return -1;
+    }
+
+    if(inp > range) {
+        /*
+         * We can encode something in the given number of bits that technically
+         * exceeds the range. This is an avenue for security errors,
+         * so we don't allow that.
+         */
+        return -1;
+    }
+
+    if(inp <= INTMAX_MAX) {
+        *outp = (intmax_t)inp + lb;
+    } else {
+        *outp = (lb + INTMAX_MAX + 1) + (intmax_t)((inp - INTMAX_MAX) - 1);
+    }
+
+    return 0;
+}
+
+int
+per_long_range_unrebase(unsigned long inp, intmax_t lb, intmax_t ub, long *outp) {
+    intmax_t tmp = *outp;
+    int rc = per_imax_range_unrebase((uintmax_t)inp, lb, ub, &tmp);
+    *outp = tmp;
+    return rc;
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/uper_support.h /ext/source/modules/EVSE/EvseV2G/asn1/uper_support.h
new file mode 100644
index 000000000..6927f3ea4
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/uper_support.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2005-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_UPER_SUPPORT_H_
+#define	_UPER_SUPPORT_H_
+
+#include "asn_system.h"		/* Platform-specific types */
+#include "per_support.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * X.691 (08/2015) #11.9 "General rules for encoding a length determinant"
+ * Get the length "n" from the Unaligned PER stream.
+ */
+ssize_t uper_get_length(asn_per_data_t *pd, int effective_bound_bits,
+                        size_t lower_bound, int *repeat);
+
+/*
+ * Get the normally small length "n".
+ */
+ssize_t uper_get_nslength(asn_per_data_t *pd);
+
+/*
+ * Get the normally small non-negative whole number.
+ */
+ssize_t uper_get_nsnnwn(asn_per_data_t *pd);
+
+/* X.691-2008/11, #11.5.6 */
+int uper_get_constrained_whole_number(asn_per_data_t *pd, uintmax_t *v, int nbits);
+
+/*
+ * Rebase the given value as an offset into the range specified by the
+ * lower bound (lb) and upper bound (ub).
+ * RETURN VALUES:
+ *  -1: Conversion failed due to range problems.
+ *   0: Conversion was successful.
+ */
+int per_long_range_rebase(long, intmax_t lb, intmax_t ub, unsigned long *output);
+int per_imax_range_rebase(intmax_t v, intmax_t lb, intmax_t ub, uintmax_t *output);
+/* The inverse operation: restores the value by the offset and its bounds. */
+int per_long_range_unrebase(unsigned long inp, intmax_t lb, intmax_t ub, long *outp);
+int per_imax_range_unrebase(uintmax_t inp, intmax_t lb, intmax_t ub, intmax_t *outp);
+
+/* X.691-2008/11, #11.5 */
+int uper_put_constrained_whole_number_u(asn_per_outp_t *po, uintmax_t v, int nbits);
+
+/*
+ * X.691 (08/2015) #11.9 "General rules for encoding a length determinant"
+ * Put the length "whole_length" to the Unaligned PER stream.
+ * If (opt_need_eom) is given, it will be set to 1 if final 0-length is needed.
+ * In that case, invoke uper_put_length(po, 0, 0) after encoding the last block.
+ * This function returns the number of units which may be flushed
+ * in the next units saving iteration.
+ */
+ssize_t uper_put_length(asn_per_outp_t *po, size_t whole_length,
+                        int *opt_need_eom);
+
+/*
+ * Put the normally small length "n" to the Unaligned PER stream.
+ * Returns 0 or -1.
+ */
+int uper_put_nslength(asn_per_outp_t *po, size_t length);
+
+/*
+ * Put the normally small non-negative whole number.
+ */
+int uper_put_nsnnwn(asn_per_outp_t *po, int n);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _UPER_SUPPORT_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/xer_decoder.c /ext/source/modules/EVSE/EvseV2G/asn1/xer_decoder.c
new file mode 100644
index 000000000..b4aa77fbc
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/xer_decoder.c
@@ -0,0 +1,369 @@
+/*
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_application.h"
+#include "asn_internal.h"
+#include "xer_support.h"		/* XER/XML parsing support */
+
+
+/*
+ * Decode the XER encoding of a given type.
+ */
+asn_dec_rval_t
+xer_decode(const asn_codec_ctx_t *opt_codec_ctx,
+           const asn_TYPE_descriptor_t *td, void **struct_ptr,
+           const void *buffer, size_t size) {
+    asn_codec_ctx_t s_codec_ctx;
+
+	/*
+	 * Stack checker requires that the codec context
+	 * must be allocated on the stack.
+	 */
+	if(opt_codec_ctx) {
+		if(opt_codec_ctx->max_stack_size) {
+			s_codec_ctx = *opt_codec_ctx;
+			opt_codec_ctx = &s_codec_ctx;
+		}
+	} else {
+		/* If context is not given, be security-conscious anyway */
+		memset(&s_codec_ctx, 0, sizeof(s_codec_ctx));
+		s_codec_ctx.max_stack_size = ASN__DEFAULT_STACK_MAX;
+		opt_codec_ctx = &s_codec_ctx;
+	}
+
+	/*
+	 * Invoke type-specific decoder.
+	 */
+	return td->op->xer_decoder(opt_codec_ctx, td, struct_ptr, 0, buffer, size);
+}
+
+
+
+struct xer__cb_arg {
+	pxml_chunk_type_e	chunk_type;
+	size_t			chunk_size;
+	const void		*chunk_buf;
+	int callback_not_invoked;
+};
+
+static int
+xer__token_cb(pxml_chunk_type_e type, const void *_chunk_data, size_t _chunk_size, void *key) {
+	struct xer__cb_arg *arg = (struct xer__cb_arg *)key;
+	arg->chunk_type = type;
+	arg->chunk_size = _chunk_size;
+	arg->chunk_buf = _chunk_data;
+	arg->callback_not_invoked = 0;
+	return -1;	/* Terminate the XML parsing */
+}
+
+/*
+ * Fetch the next token from the XER/XML stream.
+ */
+ssize_t
+xer_next_token(int *stateContext, const void *buffer, size_t size, pxer_chunk_type_e *ch_type) {
+	struct xer__cb_arg arg;
+	int new_stateContext = *stateContext;
+	ssize_t ret;
+
+	arg.callback_not_invoked = 1;
+	ret = pxml_parse(&new_stateContext, buffer, size, xer__token_cb, &arg);
+	if(ret < 0) return -1;
+	if(arg.callback_not_invoked) {
+		assert(ret == 0);	/* No data was consumed */
+        *ch_type = PXER_WMORE;
+		return 0;		/* Try again with more data */
+	} else {
+		assert(arg.chunk_size);
+		assert(arg.chunk_buf == buffer);
+	}
+
+	/*
+	 * Translate the XML chunk types into more convenient ones.
+	 */
+	switch(arg.chunk_type) {
+	case PXML_TEXT:
+		*ch_type = PXER_TEXT;
+		break;
+	case PXML_TAG:
+		*ch_type = PXER_WMORE;
+		return 0;	/* Want more */
+	case PXML_TAG_END:
+		*ch_type = PXER_TAG;
+		break;
+	case PXML_COMMENT:
+	case PXML_COMMENT_END:
+		*ch_type = PXER_COMMENT;
+		break;
+	}
+
+	*stateContext = new_stateContext;
+	return arg.chunk_size;
+}
+
+#define	CSLASH	0x2f	/* '/' */
+#define	LANGLE	0x3c	/* '<' */
+#define	RANGLE	0x3e	/* '>' */
+
+xer_check_tag_e
+xer_check_tag(const void *buf_ptr, int size, const char *need_tag) {
+	const char *buf = (const char *)buf_ptr;
+	const char *end;
+	xer_check_tag_e ct = XCT_OPENING;
+
+	if(size < 2 || buf[0] != LANGLE || buf[size-1] != RANGLE) {
+		if(size >= 2)
+			ASN_DEBUG("Broken XML tag: \"%c...%c\"",
+			buf[0], buf[size - 1]);
+		return XCT_BROKEN;
+	}
+
+	/*
+	 * Determine the tag class.
+	 */
+	if(buf[1] == CSLASH) {
+		buf += 2;	/* advance past "</" */
+		size -= 3;	/* strip "</" and ">" */
+		ct = XCT_CLOSING;
+		if(size > 0 && buf[size-1] == CSLASH)
+			return XCT_BROKEN;	/* </abc/> */
+	} else {
+		buf++;		/* advance past "<" */
+		size -= 2;	/* strip "<" and ">" */
+		if(size > 0 && buf[size-1] == CSLASH) {
+			ct = XCT_BOTH;
+			size--;	/* One more, for "/" */
+		}
+	}
+
+	/* Sometimes we don't care about the tag */
+	if(!need_tag || !*need_tag)
+		return (xer_check_tag_e)(XCT__UNK__MASK | ct);
+
+	/*
+	 * Determine the tag name.
+	 */
+	for(end = buf + size; buf < end; buf++, need_tag++) {
+		int b = *buf, n = *need_tag;
+		if(b != n) {
+			if(n == 0) {
+				switch(b) {
+				case 0x09: case 0x0a: case 0x0c: case 0x0d:
+				case 0x20:
+					/* "<abc def/>": whitespace is normal */
+					return ct;
+				}
+			}
+			return (xer_check_tag_e)(XCT__UNK__MASK | ct);
+		}
+		if(b == 0)
+			return XCT_BROKEN;	/* Embedded 0 in buf?! */
+	}
+	if(*need_tag)
+		return (xer_check_tag_e)(XCT__UNK__MASK | ct);
+
+	return ct;
+}
+
+
+#undef	ADVANCE
+#define	ADVANCE(num_bytes)	do {				\
+		size_t num = (num_bytes);			\
+		buf_ptr = ((const char *)buf_ptr) + num;	\
+		size -= num;					\
+		consumed_myself += num;				\
+	} while(0)
+
+#undef	RETURN
+#define	RETURN(_code)	do {					\
+		rval.code = _code;				\
+		rval.consumed = consumed_myself;		\
+		if(rval.code != RC_OK)				\
+			ASN_DEBUG("Failed with %d", rval.code);	\
+		return rval;					\
+	} while(0)
+
+#define	XER_GOT_BODY(chunk_buf, chunk_size, size)	do {	\
+		ssize_t converted_size = body_receiver		\
+			(struct_key, chunk_buf, chunk_size,	\
+				(size_t)chunk_size < size);	\
+		if(converted_size == -1) RETURN(RC_FAIL);	\
+		if(converted_size == 0				\
+			&& size == (size_t)chunk_size)		\
+			RETURN(RC_WMORE);			\
+		chunk_size = converted_size;			\
+	} while(0)
+#define	XER_GOT_EMPTY()	do {					\
+	if(body_receiver(struct_key, 0, 0, size > 0) == -1)	\
+			RETURN(RC_FAIL);			\
+	} while(0)
+
+/*
+ * Generalized function for decoding the primitive values.
+ */
+asn_dec_rval_t
+xer_decode_general(const asn_codec_ctx_t *opt_codec_ctx,
+	asn_struct_ctx_t *ctx,	/* Type decoder context */
+	void *struct_key,
+	const char *xml_tag,	/* Expected XML tag */
+	const void *buf_ptr, size_t size,
+	int (*opt_unexpected_tag_decoder)
+		(void *struct_key, const void *chunk_buf, size_t chunk_size),
+	ssize_t (*body_receiver)
+		(void *struct_key, const void *chunk_buf, size_t chunk_size,
+			int have_more)
+	) {
+
+	asn_dec_rval_t rval;
+	ssize_t consumed_myself = 0;
+
+	(void)opt_codec_ctx;
+
+	/*
+	 * Phases of XER/XML processing:
+	 * Phase 0: Check that the opening tag matches our expectations.
+	 * Phase 1: Processing body and reacting on closing tag.
+	 */
+	if(ctx->phase > 1) RETURN(RC_FAIL);
+	for(;;) {
+		pxer_chunk_type_e ch_type;	/* XER chunk type */
+		ssize_t ch_size;		/* Chunk size */
+		xer_check_tag_e tcv;		/* Tag check value */
+
+		/*
+		 * Get the next part of the XML stream.
+		 */
+		ch_size = xer_next_token(&ctx->context, buf_ptr, size,
+			&ch_type);
+		if(ch_size == -1) {
+            RETURN(RC_FAIL);
+        } else {
+			switch(ch_type) {
+			case PXER_WMORE:
+                RETURN(RC_WMORE);
+			case PXER_COMMENT:		/* Got XML comment */
+				ADVANCE(ch_size);	/* Skip silently */
+				continue;
+			case PXER_TEXT:
+				if(ctx->phase == 0) {
+					/*
+					 * We have to ignore whitespace here,
+					 * but in order to be forward compatible
+					 * with EXTENDED-XER (EMBED-VALUES, #25)
+					 * any text is just ignored here.
+					 */
+				} else {
+					XER_GOT_BODY(buf_ptr, ch_size, size);
+				}
+				ADVANCE(ch_size);
+				continue;
+			case PXER_TAG:
+				break;	/* Check the rest down there */
+			}
+		}
+
+		assert(ch_type == PXER_TAG && size);
+
+		tcv = xer_check_tag(buf_ptr, ch_size, xml_tag);
+		/*
+		 * Phase 0:
+		 * 	Expecting the opening tag
+		 * 	for the type being processed.
+		 * Phase 1:
+		 * 	Waiting for the closing XML tag.
+		 */
+		switch(tcv) {
+		case XCT_BOTH:
+			if(ctx->phase) break;
+			/* Finished decoding of an empty element */
+			XER_GOT_EMPTY();
+			ADVANCE(ch_size);
+			ctx->phase = 2;	/* Phase out */
+			RETURN(RC_OK);
+		case XCT_OPENING:
+			if(ctx->phase) break;
+			ADVANCE(ch_size);
+			ctx->phase = 1;	/* Processing body phase */
+			continue;
+		case XCT_CLOSING:
+			if(!ctx->phase) break;
+			ADVANCE(ch_size);
+			ctx->phase = 2;	/* Phase out */
+			RETURN(RC_OK);
+		case XCT_UNKNOWN_BO:
+			/*
+			 * Certain tags in the body may be expected.
+			 */
+			if(opt_unexpected_tag_decoder
+			&& opt_unexpected_tag_decoder(struct_key,
+					buf_ptr, ch_size) >= 0) {
+				/* Tag's processed fine */
+				ADVANCE(ch_size);
+				if(!ctx->phase) {
+					/* We are not expecting
+					 * the closing tag anymore. */
+					ctx->phase = 2;	/* Phase out */
+					RETURN(RC_OK);
+				}
+				continue;
+			}
+			/* Fall through */
+		default:
+			break;		/* Unexpected tag */
+		}
+
+		ASN_DEBUG("Unexpected XML tag (expected \"%s\")", xml_tag);
+		break;	/* Dark and mysterious things have just happened */
+	}
+
+	RETURN(RC_FAIL);
+}
+
+
+size_t
+xer_whitespace_span(const void *chunk_buf, size_t chunk_size) {
+	const char *p = (const char *)chunk_buf;
+	const char *pend = (p == NULL)? NULL : p + chunk_size;
+
+	for(; p < pend; p++) {
+		switch(*p) {
+		/* X.693, #8.1.4
+		 * HORISONTAL TAB (9)
+		 * LINE FEED (10) 
+		 * CARRIAGE RETURN (13) 
+		 * SPACE (32)
+		 */
+		case 0x09: case 0x0a: case 0x0d: case 0x20:
+			continue;
+		default:
+			break;
+		}
+		break;
+	}
+	return (p - (const char *)chunk_buf);
+}
+
+/*
+ * This is a vastly simplified, non-validating XML tree skipper.
+ */
+int
+xer_skip_unknown(xer_check_tag_e tcv, ber_tlv_len_t *depth) {
+	assert(*depth > 0);
+	switch(tcv) {
+	case XCT_BOTH:
+	case XCT_UNKNOWN_BO:
+		/* These negate each other. */
+		return 0;
+	case XCT_OPENING:
+	case XCT_UNKNOWN_OP:
+		++(*depth);
+		return 0;
+	case XCT_CLOSING:
+	case XCT_UNKNOWN_CL:
+		if(--(*depth) == 0)
+			return (tcv == XCT_CLOSING) ? 2 : 1;
+		return 0;
+	default:
+		return -1;
+	}
+}
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/xer_decoder.h /ext/source/modules/EVSE/EvseV2G/asn1/xer_decoder.h
new file mode 100644
index 000000000..17924d3a6
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/xer_decoder.h
@@ -0,0 +1,106 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_XER_DECODER_H_
+#define	_XER_DECODER_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/*
+ * The XER decoder of any ASN.1 type. May be invoked by the application.
+ * Decodes CANONICAL-XER and BASIC-XER.
+ */
+asn_dec_rval_t xer_decode(
+    const struct asn_codec_ctx_s *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    void **struct_ptr,  /* Pointer to a target structure's pointer */
+    const void *buffer, /* Data to be decoded */
+    size_t size         /* Size of data buffer */
+);
+
+/*
+ * Type of the type-specific XER decoder function.
+ */
+typedef asn_dec_rval_t(xer_type_decoder_f)(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr,
+    const char *opt_mname, /* Member name */
+    const void *buf_ptr, size_t size);
+
+/*******************************
+ * INTERNALLY USEFUL FUNCTIONS *
+ *******************************/
+
+/*
+ * Generalized function for decoding the primitive values.
+ * Used by more specialized functions, such as OCTET_STRING_decode_xer_utf8
+ * and others. This function should not be used by applications, as its API
+ * is subject to changes.
+ */
+asn_dec_rval_t xer_decode_general(
+    const asn_codec_ctx_t *opt_codec_ctx,
+    asn_struct_ctx_t *ctx, /* Type decoder context */
+    void *struct_key,      /* Treated as opaque pointer */
+    const char *xml_tag,   /* Expected XML tag name */
+    const void *buf_ptr, size_t size,
+    int (*opt_unexpected_tag_decoder)(void *struct_key, const void *chunk_buf,
+                                      size_t chunk_size),
+    ssize_t (*body_receiver)(void *struct_key, const void *chunk_buf,
+                             size_t chunk_size, int have_more));
+
+
+/*
+ * Fetch the next XER (XML) token from the stream.
+ * The function returns the number of bytes occupied by the chunk type,
+ * returned in the _ch_type. The _ch_type is only set (and valid) when
+ * the return value is >= 0.
+ */
+  typedef enum pxer_chunk_type {
+	PXER_WMORE,     /* Chunk type is not clear, more data expected. */
+	PXER_TAG,	    /* Complete XER tag */
+	PXER_TEXT,	    /* Plain text between XER tags */
+	PXER_COMMENT	/* A comment, may be part of */
+  } pxer_chunk_type_e;
+ssize_t xer_next_token(int *stateContext,
+	const void *buffer, size_t size, pxer_chunk_type_e *_ch_type);
+
+/*
+ * This function checks the buffer against the tag name is expected to occur.
+ */
+  typedef enum xer_check_tag {
+	XCT_BROKEN	= 0,	/* The tag is broken */
+	XCT_OPENING	= 1,	/* This is the <opening> tag */
+	XCT_CLOSING	= 2,	/* This is the </closing> tag */
+	XCT_BOTH	= 3,	/* This is the <modified/> tag */
+	XCT__UNK__MASK	= 4,	/* Mask of everything unexpected */
+	XCT_UNKNOWN_OP	= 5,	/* Unexpected <opening> tag */
+	XCT_UNKNOWN_CL	= 6,	/* Unexpected </closing> tag */
+	XCT_UNKNOWN_BO	= 7	/* Unexpected <modified/> tag */
+  } xer_check_tag_e;
+xer_check_tag_e xer_check_tag(const void *buf_ptr, int size,
+		const char *need_tag);
+
+/*
+ * Get the number of bytes consisting entirely of XER whitespace characters.
+ * RETURN VALUES:
+ * >=0:	Number of whitespace characters in the string.
+ */
+size_t xer_whitespace_span(const void *chunk_buf, size_t chunk_size);
+
+/*
+ * Skip the series of anticipated extensions.
+ */
+int xer_skip_unknown(xer_check_tag_e tcv, ber_tlv_len_t *depth);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _XER_DECODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/xer_encoder.c /ext/source/modules/EVSE/EvseV2G/asn1/xer_encoder.c
new file mode 100644
index 000000000..c0a435c67
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/xer_encoder.c
@@ -0,0 +1,237 @@
+/*-
+ * Copyright (c) 2003, 2004 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_internal.h"
+#include <stdio.h>
+#include <errno.h>
+
+/*
+ * The XER encoder of any type. May be invoked by the application.
+ */
+asn_enc_rval_t
+xer_encode(const asn_TYPE_descriptor_t *td, const void *sptr,
+           enum xer_encoder_flags_e xer_flags, asn_app_consume_bytes_f *cb,
+           void *app_key) {
+    asn_enc_rval_t er = {0, 0, 0};
+	asn_enc_rval_t tmper;
+	const char *mname;
+	size_t mlen;
+	int xcan = (xer_flags & XER_F_CANONICAL) ? 1 : 2;
+
+	if(!td || !sptr) goto cb_failed;
+
+	mname = td->xml_tag;
+	mlen = strlen(mname);
+
+	ASN__CALLBACK3("<", 1, mname, mlen, ">", 1);
+
+	tmper = td->op->xer_encoder(td, sptr, 1, xer_flags, cb, app_key);
+	if(tmper.encoded == -1) return tmper;
+	er.encoded += tmper.encoded;
+
+	ASN__CALLBACK3("</", 2, mname, mlen, ">\n", xcan);
+
+	ASN__ENCODED_OK(er);
+cb_failed:
+	ASN__ENCODE_FAILED;
+}
+
+/*
+ * This is a helper function for xer_fprint, which directs all incoming data
+ * into the provided file descriptor.
+ */
+static int
+xer__print2fp(const void *buffer, size_t size, void *app_key) {
+	FILE *stream = (FILE *)app_key;
+
+	if(fwrite(buffer, 1, size, stream) != size)
+		return -1;
+
+	return 0;
+}
+
+int
+xer_fprint(FILE *stream, const asn_TYPE_descriptor_t *td, const void *sptr) {
+	asn_enc_rval_t er = {0,0,0};
+
+	if(!stream) stream = stdout;
+	if(!td || !sptr)
+		return -1;
+
+	er = xer_encode(td, sptr, XER_F_BASIC, xer__print2fp, stream);
+	if(er.encoded == -1)
+		return -1;
+
+	return fflush(stream);
+}
+
+struct xer_buffer {
+    char *buffer;
+    size_t buffer_size;
+    size_t allocated_size;
+};
+
+static int
+xer__buffer_append(const void *buffer, size_t size, void *app_key) {
+    struct xer_buffer *xb = app_key;
+
+    while(xb->buffer_size + size + 1 > xb->allocated_size) {
+        size_t new_size = 2 * (xb->allocated_size ? xb->allocated_size : 64);
+        char *new_buf = MALLOC(new_size);
+        if(!new_buf) return -1;
+        if (xb->buffer) {
+            memcpy(new_buf, xb->buffer, xb->buffer_size);
+        }
+        FREEMEM(xb->buffer);
+        xb->buffer = new_buf;
+        xb->allocated_size = new_size;
+    }
+
+    memcpy(xb->buffer + xb->buffer_size, buffer, size);
+    xb->buffer_size += size;
+    xb->buffer[xb->buffer_size] = '\0';
+    return 0;
+}
+
+enum xer_equivalence_e
+xer_equivalent(const struct asn_TYPE_descriptor_s *td, const void *struct1,
+               const void *struct2, FILE *opt_debug_stream) {
+    struct xer_buffer xb1 = {0, 0, 0};
+    struct xer_buffer xb2 = {0, 0, 0};
+    asn_enc_rval_t e1, e2;
+    asn_dec_rval_t rval;
+    void *sptr = NULL;
+
+    if(!td || !struct1 || !struct2) {
+        if(opt_debug_stream) {
+            if(!td) fprintf(opt_debug_stream, "Type descriptor missing\n");
+            if(!struct1) fprintf(opt_debug_stream, "Structure 1 missing\n");
+            if(!struct2) fprintf(opt_debug_stream, "Structure 2 missing\n");
+        }
+        return XEQ_FAILURE;
+    }
+
+    e1 = xer_encode(td, struct1, XER_F_BASIC, xer__buffer_append, &xb1);
+    if(e1.encoded == -1) {
+        if(opt_debug_stream) {
+            fprintf(stderr, "XER Encoding of %s failed\n", td->name);
+        }
+        FREEMEM(xb1.buffer);
+        return XEQ_ENCODE1_FAILED;
+    }
+
+    e2 = xer_encode(td, struct2, XER_F_BASIC, xer__buffer_append, &xb2);
+    if(e2.encoded == -1) {
+        if(opt_debug_stream) {
+            fprintf(stderr, "XER Encoding of %s failed\n", td->name);
+        }
+        FREEMEM(xb1.buffer);
+        FREEMEM(xb2.buffer);
+        return XEQ_ENCODE1_FAILED;
+    }
+
+    if(xb1.buffer_size != xb2.buffer_size
+       || memcmp(xb1.buffer, xb2.buffer, xb1.buffer_size) != 0) {
+        if(opt_debug_stream) {
+            fprintf(opt_debug_stream,
+                    "Structures XER-encoded into different byte streams:\n=== "
+                    "Structure 1 ===\n%s\n=== Structure 2 ===\n%s\n",
+                    xb1.buffer, xb2.buffer);
+        }
+        FREEMEM(xb1.buffer);
+        FREEMEM(xb2.buffer);
+        return XEQ_DIFFERENT;
+    } else {
+        if(opt_debug_stream) {
+            fprintf(opt_debug_stream,
+                    "Both structures encoded into the same XER byte stream "
+                    "of size %" ASN_PRI_SIZE ":\n%s",
+                    xb1.buffer_size, xb1.buffer);
+        }
+    }
+
+    rval = xer_decode(NULL, td, (void **)&sptr, xb1.buffer,
+               xb1.buffer_size);
+    switch(rval.code) {
+    case RC_OK:
+        break;
+    case RC_WMORE:
+        if(opt_debug_stream) {
+            fprintf(opt_debug_stream,
+                    "Structure %s XER decode unexpectedly requires "
+                    "more data:\n%s\n",
+                    td->name, xb1.buffer);
+        }
+        /* Fall through */
+    case RC_FAIL:
+    default:
+        if(opt_debug_stream) {
+            fprintf(opt_debug_stream,
+                    "Structure %s XER decoding resulted in failure.\n",
+                    td->name);
+        }
+        ASN_STRUCT_FREE(*td, sptr);
+        FREEMEM(xb1.buffer);
+        FREEMEM(xb2.buffer);
+        return XEQ_DECODE_FAILED;
+    }
+
+    if(rval.consumed != xb1.buffer_size
+       && ((rval.consumed > xb1.buffer_size)
+           || xer_whitespace_span(xb1.buffer + rval.consumed,
+                                  xb1.buffer_size - rval.consumed)
+                  != (xb1.buffer_size - rval.consumed))) {
+        if(opt_debug_stream) {
+            fprintf(opt_debug_stream,
+                    "Round-trip decode of %s required less bytes (%" ASN_PRI_SIZE ") than "
+                    "encoded (%" ASN_PRI_SIZE ")\n",
+                    td->name, rval.consumed, xb1.buffer_size);
+        }
+        ASN_STRUCT_FREE(*td, sptr);
+        FREEMEM(xb1.buffer);
+        FREEMEM(xb2.buffer);
+        return XEQ_ROUND_TRIP_FAILED;
+    }
+
+    /*
+     * Reuse xb2 to encode newly decoded structure.
+     */
+    FREEMEM(xb2.buffer);
+    memset(&xb2, 0, sizeof(xb2));
+
+    e2 = xer_encode(td, sptr, XER_F_BASIC, xer__buffer_append, &xb2);
+    if(e2.encoded == -1) {
+        if(opt_debug_stream) {
+            fprintf(stderr, "XER Encoding of round-trip decode of %s failed\n",
+                    td->name);
+        }
+        ASN_STRUCT_FREE(*td, sptr);
+        FREEMEM(xb1.buffer);
+        FREEMEM(xb2.buffer);
+        return XEQ_ROUND_TRIP_FAILED;
+    }
+
+    ASN_STRUCT_FREE(*td, sptr);
+    sptr = 0;
+
+    if(xb1.buffer_size != xb2.buffer_size
+       || memcmp(xb1.buffer, xb2.buffer, xb1.buffer_size) != 0) {
+        if(opt_debug_stream) {
+            fprintf(opt_debug_stream,
+                    "XER Encoding of round-trip decode of %s resulted in "
+                    "different byte stream:\n"
+                    "=== Original ===\n%s\n"
+                    "=== Round-tripped ===\n%s\n",
+                    xb1.buffer, xb2.buffer, td->name);
+        }
+        FREEMEM(xb1.buffer);
+        FREEMEM(xb2.buffer);
+        return XEQ_ROUND_TRIP_FAILED;
+    }
+
+	FREEMEM(xb1.buffer);
+	FREEMEM(xb2.buffer);
+	return XEQ_SUCCESS;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/xer_encoder.h /ext/source/modules/EVSE/EvseV2G/asn1/xer_encoder.h
new file mode 100644
index 000000000..f703f01df
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/xer_encoder.h
@@ -0,0 +1,83 @@
+/*-
+ * Copyright (c) 2004-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_XER_ENCODER_H_
+#define	_XER_ENCODER_H_
+
+#include "asn_application.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+/* Flags used by the xer_encode() and (*xer_type_encoder_f), defined below */
+enum xer_encoder_flags_e {
+	/* Mode of encoding */
+	XER_F_BASIC	= 0x01,	/* BASIC-XER (pretty-printing) */
+	XER_F_CANONICAL	= 0x02	/* Canonical XER (strict rules) */
+};
+
+/*
+ * The XER encoder of any type. May be invoked by the application.
+ * Produces CANONICAL-XER and BASIC-XER depending on the (xer_flags).
+ */
+asn_enc_rval_t xer_encode(const struct asn_TYPE_descriptor_s *type_descriptor,
+                          const void *struct_ptr, /* Structure to be encoded */
+                          enum xer_encoder_flags_e xer_flags,
+                          asn_app_consume_bytes_f *consume_bytes_cb,
+                          void *app_key /* Arbitrary callback argument */
+);
+
+/*
+ * The variant of the above function which dumps the BASIC-XER (XER_F_BASIC)
+ * output into the chosen file pointer.
+ * RETURN VALUES:
+ * 	 0: The structure is printed.
+ * 	-1: Problem printing the structure.
+ * WARNING: No sensible errno value is returned.
+ */
+int xer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td,
+               const void *struct_ptr);
+
+/*
+ * A helper function that uses XER encoding/decoding to verify that:
+ * - Both structures encode into the same BASIC XER.
+ * - Both resulting XER byte streams can be decoded back.
+ * - Both decoded structures encode into the same BASIC XER (round-trip).
+ * All of this verifies equivalence between structures and a round-trip.
+ * ARGUMENTS:
+ *  (opt_debug_stream)  - If specified, prints ongoing details.
+ */
+enum xer_equivalence_e {
+    XEQ_SUCCESS,          /* The only completely positive return value */
+    XEQ_FAILURE,          /* General failure */
+    XEQ_ENCODE1_FAILED,   /* First structure XER encoding failed */
+    XEQ_ENCODE2_FAILED,   /* Second structure XER encoding failed */
+    XEQ_DIFFERENT,        /* Structures encoded into different XER */
+    XEQ_DECODE_FAILED,    /* Decode of the XER data failed */
+    XEQ_ROUND_TRIP_FAILED /* Bad round-trip */
+};
+enum xer_equivalence_e xer_equivalent(
+    const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1,
+    const void *struct2, FILE *opt_debug_stream);
+
+/*
+ * Type of the generic XER encoder.
+ */
+typedef asn_enc_rval_t(xer_type_encoder_f)(
+    const struct asn_TYPE_descriptor_s *type_descriptor,
+    const void *struct_ptr, /* Structure to be encoded */
+    int ilevel,             /* Level of indentation */
+    enum xer_encoder_flags_e xer_flags,
+    asn_app_consume_bytes_f *consume_bytes_cb, /* Callback */
+    void *app_key                              /* Arbitrary callback argument */
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _XER_ENCODER_H_ */
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/xer_support.c /ext/source/modules/EVSE/EvseV2G/asn1/xer_support.c
new file mode 100644
index 000000000..e14e1887d
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/xer_support.c
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2003, 2004 X/IO Labs, xiolabs.com.
+ * Copyright (c) 2003, 2004, 2005 Lev Walkin <vlm@lionet.info>.
+ * 	All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#include "asn_system.h"
+#include "xer_support.h"
+
+/* Parser states */
+typedef enum {
+	ST_TEXT,
+	ST_TAG_START,
+	ST_TAG_BODY,
+	ST_TAG_QUOTE_WAIT,
+	ST_TAG_QUOTED_STRING,
+	ST_TAG_UNQUOTED_STRING,
+	ST_COMMENT_WAIT_DASH1,	/* "<!--"[1] */
+	ST_COMMENT_WAIT_DASH2,	/* "<!--"[2] */
+	ST_COMMENT,
+	ST_COMMENT_CLO_DASH2,	/* "-->"[0] */
+	ST_COMMENT_CLO_RT	/* "-->"[1] */
+} pstate_e;
+
+static const int
+_charclass[256] = {
+	0,0,0,0,0,0,0,0, 0,1,1,0,1,1,0,0,
+	0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
+	1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
+	2,2,2,2,2,2,2,2, 2,2,0,0,0,0,0,0,	/* 01234567 89       */
+	0,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,	/*  ABCDEFG HIJKLMNO */
+	3,3,3,3,3,3,3,3, 3,3,3,0,0,0,0,0,	/* PQRSTUVW XYZ      */
+	0,3,3,3,3,3,3,3, 3,3,3,3,3,3,3,3,	/*  abcdefg hijklmno */
+	3,3,3,3,3,3,3,3, 3,3,3,0,0,0,0,0	/* pqrstuvw xyz      */
+};
+#define WHITESPACE(c)	(_charclass[(unsigned char)(c)] == 1)
+#define ALNUM(c)	(_charclass[(unsigned char)(c)] >= 2)
+#define ALPHA(c)	(_charclass[(unsigned char)(c)] == 3)
+
+/* Aliases for characters, ASCII/UTF-8 */
+#define	EXCLAM	0x21	/* '!' */
+#define	CQUOTE	0x22	/* '"' */
+#define	CDASH	0x2d	/* '-' */
+#define	CSLASH	0x2f	/* '/' */
+#define	LANGLE	0x3c	/* '<' */
+#define	CEQUAL	0x3d	/* '=' */
+#define	RANGLE	0x3e	/* '>' */
+#define	CQUEST	0x3f	/* '?' */
+
+/* Invoke token callback */
+#define	TOKEN_CB_CALL(type, _ns, _current_too, _final) do {	\
+		int _ret;					\
+		pstate_e ns  = _ns;				\
+		ssize_t _sz = (p - chunk_start) + _current_too;	\
+		if (!_sz) {					\
+			/* Shortcut */				\
+			state = _ns;				\
+			break;					\
+		}						\
+		_ret = cb(type, chunk_start, _sz, key);		\
+		if(_ret < _sz) {				\
+			if(_current_too && _ret == -1)		\
+				state = ns;			\
+			goto finish;				\
+		}						\
+		chunk_start = p + _current_too;			\
+		state = ns;					\
+	} while(0)
+
+#define TOKEN_CB(_type, _ns, _current_too)			\
+	TOKEN_CB_CALL(_type, _ns, _current_too, 0)
+
+#define PXML_TAG_FINAL_CHUNK_TYPE      PXML_TAG_END
+#define PXML_COMMENT_FINAL_CHUNK_TYPE  PXML_COMMENT_END
+
+#define TOKEN_CB_FINAL(_type, _ns, _current_too)		\
+	TOKEN_CB_CALL( _type ## _FINAL_CHUNK_TYPE , _ns, _current_too, 1)
+
+/*
+ * Parser itself
+ */
+ssize_t pxml_parse(int *stateContext, const void *xmlbuf, size_t size, pxml_callback_f *cb, void *key) {
+	pstate_e state = (pstate_e)*stateContext;
+	const char *chunk_start = (const char *)xmlbuf;
+	const char *p = chunk_start;
+	const char *end = p + size;
+
+	for(; p < end; p++) {
+	  int C = *(const unsigned char *)p;
+	  switch(state) {
+	  case ST_TEXT:
+		/*
+		 * Initial state: we're in the middle of some text,
+		 * or just have started.
+		 */
+		if (C == LANGLE) 
+			/* We're now in the tag, probably */
+			TOKEN_CB(PXML_TEXT, ST_TAG_START, 0);
+		break;
+	  case ST_TAG_START:
+		if (ALPHA(C) || (C == CSLASH))
+			state = ST_TAG_BODY;
+		else if (C == EXCLAM)
+			state = ST_COMMENT_WAIT_DASH1;
+		else 
+			/*
+			 * Not characters and not whitespace.
+			 * Must be something like "3 < 4".
+			 */
+			TOKEN_CB(PXML_TEXT, ST_TEXT, 1);/* Flush as data */
+		break;
+	  case ST_TAG_BODY:
+		switch(C) {
+		case RANGLE:
+			/* End of the tag */
+			TOKEN_CB_FINAL(PXML_TAG, ST_TEXT, 1);
+			break;
+		case LANGLE:
+			/*
+			 * The previous tag wasn't completed, but still
+			 * recognized as valid. (Mozilla-compatible)
+			 */
+			TOKEN_CB_FINAL(PXML_TAG, ST_TAG_START, 0);	
+			break;
+		case CEQUAL:
+			state = ST_TAG_QUOTE_WAIT;
+			break;
+		}
+		break;
+	  case ST_TAG_QUOTE_WAIT:
+		/*
+		 * State after the equal sign ("=") in the tag.
+		 */
+		switch(C) {
+		case CQUOTE:
+			state = ST_TAG_QUOTED_STRING;
+			break;
+		case RANGLE:
+			/* End of the tag */
+			TOKEN_CB_FINAL(PXML_TAG, ST_TEXT, 1);
+			break;
+		default:
+			if(!WHITESPACE(C))
+				/* Unquoted string value */
+				state = ST_TAG_UNQUOTED_STRING;
+		}
+		break;
+	  case ST_TAG_QUOTED_STRING:
+		/*
+		 * Tag attribute's string value in quotes.
+		 */
+		if(C == CQUOTE) {
+			/* Return back to the tag state */
+			state = ST_TAG_BODY;
+		}
+		break;
+	  case ST_TAG_UNQUOTED_STRING:
+		if(C == RANGLE) {
+			/* End of the tag */
+			TOKEN_CB_FINAL(PXML_TAG, ST_TEXT, 1);
+		} else if(WHITESPACE(C)) {
+			/* Return back to the tag state */
+			state = ST_TAG_BODY;
+		}
+		break;
+	  case ST_COMMENT_WAIT_DASH1:
+		if(C == CDASH) {
+			state = ST_COMMENT_WAIT_DASH2;
+		} else {
+			/* Some ordinary tag. */
+			state = ST_TAG_BODY;
+		}
+		break;
+	  case ST_COMMENT_WAIT_DASH2:
+		if(C == CDASH) {
+			/* Seen "<--" */
+			state = ST_COMMENT;
+		} else {
+			/* Some ordinary tag */
+			state = ST_TAG_BODY;
+		}
+		break;
+	  case ST_COMMENT:
+		if(C == CDASH) {
+			state = ST_COMMENT_CLO_DASH2;
+		}
+		break;
+	  case ST_COMMENT_CLO_DASH2:
+		if(C == CDASH) {
+			state = ST_COMMENT_CLO_RT;
+		} else {
+			/* This is not an end of a comment */
+			state = ST_COMMENT;
+		}
+		break;
+	  case ST_COMMENT_CLO_RT:
+		if(C == RANGLE) {
+			TOKEN_CB_FINAL(PXML_COMMENT, ST_TEXT, 1);
+		} else if(C == CDASH) {
+			/* Maintain current state, still waiting for '>' */
+		} else {
+			state = ST_COMMENT;
+		}
+		break;
+	  } /* switch(*ptr) */
+	} /* for() */
+
+	/*
+	 * Flush the partially processed chunk, state permitting.
+	 */
+	if(p - chunk_start) {
+		switch (state) {
+		case ST_COMMENT:
+			TOKEN_CB(PXML_COMMENT, state, 0);
+			break;
+		case ST_TEXT:
+			TOKEN_CB(PXML_TEXT, state, 0);
+			break;
+		default: break;	/* a no-op */
+		}
+	}
+
+finish:
+	*stateContext = (int)state;
+	return chunk_start - (const char *)xmlbuf;
+}
+
diff --git /ext/source/modules/EVSE/EvseV2G/asn1/xer_support.h /ext/source/modules/EVSE/EvseV2G/asn1/xer_support.h
new file mode 100644
index 000000000..620fc3913
--- /dev/null
+++ /ext/source/modules/EVSE/EvseV2G/asn1/xer_support.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2003, 2004 X/IO Labs, xiolabs.com.
+ * Copyright (c) 2003-2017 Lev Walkin <vlm@lionet.info>. All rights reserved.
+ * Redistribution and modifications are permitted subject to BSD license.
+ */
+#ifndef	_XER_SUPPORT_H_
+#define	_XER_SUPPORT_H_
+
+#include "asn_system.h"		/* Platform-specific types */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Types of data transferred to the application.
+ */
+typedef enum {
+	PXML_TEXT,	/* Plain text between XML tags. */
+	PXML_TAG,	/* A tag, starting with '<'. */
+	PXML_COMMENT,	/* An XML comment, including "<!--" and "-->". */
+	/* 
+	 * The following chunk types are reported if the chunk
+	 * terminates the specified XML element.
+	 */
+	PXML_TAG_END,		/* Tag ended */
+	PXML_COMMENT_END	/* Comment ended */
+} pxml_chunk_type_e;
+
+/*
+ * Callback function that is called by the parser when parsed data is
+ * available. The _opaque is the pointer to a field containing opaque user 
+ * data specified in pxml_create() call. The chunk type is _type and the text 
+ * data is the piece of buffer identified by _bufid (as supplied to
+ * pxml_feed() call) starting at offset _offset and of _size bytes size. 
+ * The chunk is NOT '\0'-terminated.
+ */
+typedef int (pxml_callback_f)(pxml_chunk_type_e _type,
+	const void *_chunk_data, size_t _chunk_size, void *_key);
+
+/*
+ * Parse the given buffer as it were a chunk of XML data.
+ * Invoke the specified callback each time the meaningful data is found.
+ * This function returns number of bytes consumed from the buffer.
+ * It will always be lesser than or equal to the specified _size.
+ * The next invocation of this function must account the difference.
+ */
+ssize_t pxml_parse(int *_stateContext, const void *_buf, size_t _size,
+	pxml_callback_f *cb, void *_key);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _XER_SUPPORT_H_ */

diff --git /ext/source/modules/EVSE/EvseV2G/sdp.cpp /ext/source/modules/EVSE/EvseV2G/sdp.cpp
index b40c774e7..b35882b1e 100644
--- /ext/source/modules/EVSE/EvseV2G/sdp.cpp
+++ /ext/source/modules/EVSE/EvseV2G/sdp.cpp
@@ -3,6 +3,10 @@
 // Copyright (C) 2022-2023 Contributors to EVerest
 #include "sdp.hpp"
 #include "log.hpp"
+extern "C" {
+    #include "asn1/all_asn1c_headers.h"
+}
+//#include "all_asn1c_headers.h"
 
 #include <arp/ext/sourceinet.h>
 #include <errno.h>
@@ -22,18 +26,34 @@
 #define DEBUG 1
 
 /* defines for V2G SDP implementation */
-#define SDP_SRV_PORT 15118
+#define SDP_SRV_PORT 15118 // Regular port defined in DIN SPEC 70121 [V2G-DC-159] and ISO 15118-02 [V2G2-125/205] for SDP Server
+#define ESDP_SRV_PORT 15200 // As per [V2G200-51-1/2] in ISO/PAS CD 15118-200:2024(E) - STANDARD NOT YET PUBLISHED
 
 #define SDP_VERSION         0x01
 #define SDP_INVERSE_VERSION 0xfe
 
-#define SDP_HEADER_LEN           8
+#define SDP_HEADER_LEN           8 // Header length is the same for SDP and ESDP as per [V2G200-4-1] in ISO/PAS CD 15118-200:2024(E)
 #define SDP_REQUEST_PAYLOAD_LEN  2
 #define SDP_RESPONSE_PAYLOAD_LEN 20
 
+// Define ESDP Req & Res payload lengths for ESDP (Subject to change)
+#define MAX_ESDP_REQUEST_PAYLOAD_LEN 512
+#define MAX_ESDP_RESPONSE_PAYLOAD_LEN 512
+
+// Assign regular SDP Payload types as per DIN 70121 [V2G2-DC-194/208] & ISO 15118-02 [V2G2-140/152]
 #define SDP_REQUEST_TYPE  0x9000
 #define SDP_RESPONSE_TYPE 0x9001
 
+// Assign ESDP Payload types as per [V2G200-41-1] in ISO/PAS CD 15118-200:2024(E) - STANDARD NOT YET PUBLISHED
+#define ESDP_REQUEST_TYPE  0x2000 
+#define ESDP_RESPONSE_TYPE 0x2000
+
+// Define ESDP Version for verification as per [V2G200-52-2] in ISO/PAS CD 15118-200:2024(E)
+#define ESDP_VERSION        0x0100
+
+// Define Maximum V2GTP Paylod Size as per [V2G200-52-3] in ISO/PAS CD 15118-200:2024(E)
+#define ESDP_MAX_V2GTP_PAYLOAD_SIZE 0x1000
+
 #define POLL_TIMEOUT 20
 
 /* link-local multicast address ff02::1 aka ip6-allnodes */
@@ -51,7 +71,8 @@ struct sdp_query {
 };
 
 /*
- * Fills the SDP header into a given buffer
+ * Fills the SDP header into a given buffer. Same function for both SDP and ESDP
+ * since the header length is the same for both
  */
 int sdp_write_header(uint8_t* buffer, uint16_t payload_type, uint32_t payload_len) {
     int offset = 0;
@@ -103,6 +124,51 @@ int sdp_validate_header(uint8_t* buffer, uint16_t expected_payload_type, uint32_
     return 0;
 }
 
+static int esdp_validate_header(uint8_t* buffer, uint16_t expected_payload_type, uint32_t max_esdp_payload_len, uint16_t expected_esdp_version) {
+    /* Returns -1 for invalid V2GTP header, 1 for invalid ESDP Header (version, max payload size), and 0 otherwise*/
+
+    uint16_t payload_type;
+    uint32_t payload_len;
+    uint16_t esdp_version;
+
+    if (buffer[0] != SDP_VERSION) {
+        dlog(DLOG_LEVEL_ERROR, "Invalid SDP version in header of ESDP packet");
+        return -1;
+    }
+
+    if (buffer[1] != SDP_INVERSE_VERSION) {
+        dlog(DLOG_LEVEL_ERROR, "Invalid SDP inverse version in header of ESDP packet");
+        return -1;
+    }
+
+    payload_type = (buffer[2] << 8) + buffer[3];
+    if (payload_type != expected_payload_type) {
+        dlog(DLOG_LEVEL_ERROR, "Invalid payload type: expected %" PRIu16 ", received %" PRIu16 " in header of ESDP packet",
+             expected_payload_type, payload_type);
+        return -1;
+    }
+
+    payload_len = (buffer[4] << 24) + (buffer[5] << 16) + (buffer[6] << 8) + buffer[7];
+    if (payload_len >= max_esdp_payload_len) {
+        dlog(DLOG_LEVEL_ERROR, "Size of ESDPReq payload exceeds max limit. ESDPReq payload is %" PRIu32 " bytes while max limit is %" PRIu32 " bytes",
+             payload_len, max_esdp_payload_len);
+        return 1;
+    }
+    
+    /* Verify ESDP version as per [V2G200-52-2] in ISO/PAS CD 15118-200:2024(E). Added for ESDP */
+    esdp_version = (buffer[8] << 8) + buffer[9];    
+    if (esdp_version != expected_esdp_version) {
+    	dlog(DLOG_LEVEL_ERROR, "Unsupported ESDP Version: expected %" PRIu16 ", received %" PRIu16 " in ESDP Payload",
+    	     expected_esdp_version, esdp_version);
+     	dlog(DLOG_LEVEL_ERROR, "The last ESDP packet will be discarded since the ESDP version is unsupported");
+     	return 1;
+    } else {
+        dlog(DLOG_LEVEL_INFO, "EVCC's reported ESDP Version: %" PRIu16, esdp_version);
+    }
+    
+    return 0;
+}
+
 int sdp_create_response(uint8_t* buffer, struct sockaddr_in6* addr, enum sdp_security security,
                         enum sdp_transport_protocol proto) {
     int offset = SDP_HEADER_LEN;
@@ -124,6 +190,349 @@ int sdp_create_response(uint8_t* buffer, struct sockaddr_in6* addr, enum sdp_sec
 
     return offset;
 }
+
+int encode_ESDPRes_Extensions(uint8_t* buffer_esdp, int offset, struct sockaddr_in6* addr, enum sdp_security security) {
+    /* Create and populate Extensions */
+    Extensions_t *extensions = (Extensions_t *)calloc(1, sizeof(Extensions_t));
+    if (!extensions) {
+        dlog(DLOG_LEVEL_ERROR, "Failed to allocate memory for extensions");
+    }
+
+    /* ExtensionID 1 - Charging interface extension */
+    /* Using placeholder value corresponding to CCS1 for charging interface */
+    /* All enumerations can be found in asn1/ChargingInterface.h */
+    StandardizedExtension_t *charging_interface_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    if (!charging_interface_ext) {
+        dlog(DLOG_LEVEL_ERROR, "Failed to allocate memory for Charging Interface Extension");
+    }
+    charging_interface_ext -> extensionID = 1;
+    ChargingInterface_t charging_interface = ChargingInterface_ccs1;
+    uint8_t *ci_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t ci_enc_rval = der_encode_to_buffer(&asn_DEF_ChargingInterface, &charging_interface,
+                    ci_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "ChargingInterface data encoded: %zu bytes\n", ci_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&charging_interface_ext -> extensionValue, (char *)ci_buffer, ci_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, charging_interface_ext);
+    free(ci_buffer);
+
+    /* ExtensionID 2 - Basic signaling extension */
+    /* Using a placeholder list including all Protocols defined in ISO/PAS CD 15118-200:2024(E) */
+    StandardizedExtension_t *basic_signaling_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    basic_signaling_ext -> extensionID = 2;
+    BasicSignaling_t *basic_signaling = (BasicSignaling_t *)calloc(1, sizeof(BasicSignaling_t));
+    BasicSignalingProtocol_t *protocol01 = (BasicSignalingProtocol_t *)calloc(1, sizeof(BasicSignalingProtocol_t));
+    BasicSignalingProtocol_t *protocol02 = (BasicSignalingProtocol_t *)calloc(1, sizeof(BasicSignalingProtocol_t));
+    BasicSignalingProtocol_t *protocol03 = (BasicSignalingProtocol_t *)calloc(1, sizeof(BasicSignalingProtocol_t));
+    BasicSignalingProtocol_t *protocol04 = (BasicSignalingProtocol_t *)calloc(1, sizeof(BasicSignalingProtocol_t));
+    *protocol01 = BasicSignalingProtocol_iec61851_1_ED2;
+    *protocol02 = BasicSignalingProtocol_iec61851_1_ED3;
+    *protocol03 = BasicSignalingProtocol_iec61851_23_ED1;
+    *protocol04 = BasicSignalingProtocol_iec61851_23_ED2;
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, protocol01);
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, protocol02);
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, protocol03);
+    ASN_SEQUENCE_ADD(&basic_signaling -> list, protocol04);       
+    uint8_t *bs_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t bs_enc_rval = der_encode_to_buffer(&asn_DEF_BasicSignaling, basic_signaling, bs_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "Basic Signaling data encoded: %zu bytes\n", bs_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&basic_signaling_ext -> extensionValue, (char *)bs_buffer, bs_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, basic_signaling_ext);
+    free(bs_buffer);
+
+    /* ExtensionID 3 - IPv6 Socket extension */
+    StandardizedExtension_t *ipv6_socket_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    ipv6_socket_ext -> extensionID = 3;
+    IPv6Socket_t *ipv6_socket = (IPv6Socket_t *)calloc(1, sizeof(IPv6Socket_t));
+    uint8_t ipv6_secc_address[sizeof(addr -> sin6_addr)] = {0};
+    uint8_t ipv6_secc_port[4] = {0};
+    memcpy(&ipv6_secc_address[0], &addr->sin6_addr, sizeof(addr->sin6_addr));
+    memcpy(&ipv6_secc_port[2], &addr->sin6_port, sizeof(addr->sin6_port));
+    OCTET_STRING_fromBuf(&ipv6_socket -> ipv6Address, (const char *)&ipv6_secc_address, sizeof(ipv6_secc_address));
+    OCTET_STRING_fromBuf(&ipv6_socket -> tcpPort, (const char *)&ipv6_secc_port, sizeof(ipv6_secc_port));
+    uint8_t *ip_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t ip_enc_rval = der_encode_to_buffer(&asn_DEF_IPv6Socket, ipv6_socket, ip_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "IPv6 Socket data encoded: %zu bytes\n", ip_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&ipv6_socket_ext -> extensionValue, (char *)ip_buffer, ip_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, ipv6_socket_ext);
+    free(ip_buffer);
+
+    /* Placeholder switch block. Can be used to selectively encode HLC Extension */
+    /* switch (security) {
+        case SDP_SECURITY_TLS:
+            sec_profile01 -> securityProfile = SecurityProfile_tls12_server;
+        case SDP_SECURITY_NONE:
+            sec_profile01 -> securityProfile = SecurityProfile_tcpOnly;
+            break;
+        default:
+            dlog(DLOG_LEVEL_ERROR, "Unknown Security. Unable to encode correct security into ESDPResponse's HLC extension");
+            break:
+    } */
+
+    /* ExtensionID 4 - High Level Communication extension */
+    /* Using a placeholder list of all possible combinations for now. Use the switch block above to selectively encode supported HLC Extensions.
+        Then remove unsupported combinations in the future */
+    StandardizedExtension_t *hlc_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    hlc_ext -> extensionID = 4;
+    HighLevelCommunication_t *hlc = (HighLevelCommunication_t *)calloc(1, sizeof(HighLevelCommunication_t));
+
+    /* First HLC Tuple - For DIN 70121:2014 (TCP with EIM with DC) */
+    HighLevelCommunicationTuple_t *hlc_tuple01 = (HighLevelCommunicationTuple_t *)calloc(1, sizeof(HighLevelCommunicationTuple_t));
+    hlc_tuple01 -> hlcProtocol = HLCProtocol_din_spec_70121_2014;
+    SecurityProfileTuple_t *sec_profile01 = (SecurityProfileTuple_t *)calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile01 -> securityProfile = SecurityProfile_tcpOnly;
+    AuthorizationMethod_t *auth01 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth01 = AuthorizationMethod_eim;
+    EnergyTransferMode_t *mode01 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode01 = EnergyTransferMode_dc;
+    ASN_SEQUENCE_ADD(&sec_profile01 -> authorizationMethod.list, auth01);
+    ASN_SEQUENCE_ADD(&sec_profile01 -> energyTransferMode.list, mode01);
+    ASN_SEQUENCE_ADD(&hlc_tuple01 -> securityProfileTuple.list, sec_profile01);
+    ASN_SEQUENCE_ADD(&hlc -> list, hlc_tuple01);
+
+    /* Second HLC Tuple - For ISO 15118-2:2014 (TCP with EIM with dc & ac) */
+    HighLevelCommunicationTuple_t *hlc_tuple02 = (HighLevelCommunicationTuple_t *)calloc(1, sizeof(HighLevelCommunicationTuple_t));
+    hlc_tuple02 -> hlcProtocol = HLCProtocol_iso_15118_2_2014;
+    SecurityProfileTuple_t *sec_profile02_01 = (SecurityProfileTuple_t *)calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile02_01 -> securityProfile = SecurityProfile_tcpOnly;
+    AuthorizationMethod_t *auth02_01 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth02_01 = AuthorizationMethod_eim;
+    EnergyTransferMode_t *mode02_01_01 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_01_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode02_01_02 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_01_02 = EnergyTransferMode_ac;
+    ASN_SEQUENCE_ADD(&sec_profile02_01 -> authorizationMethod.list, auth02_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_01 -> energyTransferMode.list, mode02_01_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_01 -> energyTransferMode.list, mode02_01_02);
+    
+    /* and (TLS12_server with EIM & PNC_2 with dc & ac) */
+    SecurityProfileTuple_t *sec_profile02_02 = (SecurityProfileTuple_t *)calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile02_02 -> securityProfile = SecurityProfile_tls12_server;
+    AuthorizationMethod_t *auth02_02_01 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth02_02_01 = AuthorizationMethod_eim;
+    AuthorizationMethod_t *auth02_02_02 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth02_02_02 = AuthorizationMethod_pnc_2;
+    EnergyTransferMode_t *mode02_02_01 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_02_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode02_02_02 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode02_02_02 = EnergyTransferMode_ac;
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> authorizationMethod.list, auth02_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> authorizationMethod.list, auth02_02_02);
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> energyTransferMode.list, mode02_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile02_02 -> energyTransferMode.list, mode02_02_02);  
+    ASN_SEQUENCE_ADD(&hlc_tuple02 -> securityProfileTuple.list, sec_profile02_01);
+    ASN_SEQUENCE_ADD(&hlc_tuple02 -> securityProfileTuple.list, sec_profile02_02);
+    ASN_SEQUENCE_ADD(&hlc -> list, hlc_tuple02);
+
+    /* Third HLC Tuple - For ISO 15118-20:2022 (TCP with EIM with dc & dc-bpt & ac & ac-bpt) */
+    HighLevelCommunicationTuple_t *hlc_tuple03 = (HighLevelCommunicationTuple_t *)calloc(1, sizeof(HighLevelCommunicationTuple_t));
+    hlc_tuple03 -> hlcProtocol = HLCProtocol_iso_15118_20_2022;
+    SecurityProfileTuple_t *sec_profile03_01 = (SecurityProfileTuple_t *)calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile03_01 -> securityProfile = SecurityProfile_tcpOnly;
+    AuthorizationMethod_t *auth03_01 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_01 = AuthorizationMethod_eim;
+    EnergyTransferMode_t *mode03_01_01 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode03_01_02 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_02 = EnergyTransferMode_dc_bpt;    
+    EnergyTransferMode_t *mode03_01_03 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_03 = EnergyTransferMode_ac;
+    EnergyTransferMode_t *mode03_01_04 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_01_04 = EnergyTransferMode_ac_bpt;    
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> authorizationMethod.list, auth03_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_03);
+    ASN_SEQUENCE_ADD(&sec_profile03_01 -> energyTransferMode.list, mode03_01_04);
+
+    /* and (TLS12_server with EIM & PNC_2 with dc & dc-bpt & ac & ac-bpt) */
+    SecurityProfileTuple_t *sec_profile03_02 = (SecurityProfileTuple_t *)calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile03_02 -> securityProfile = SecurityProfile_tls12_server;
+    AuthorizationMethod_t *auth03_02_01 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_02_01 = AuthorizationMethod_eim;
+    AuthorizationMethod_t *auth03_02_02 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_02_02 = AuthorizationMethod_pnc_2;
+    EnergyTransferMode_t *mode03_02_01 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode03_02_02 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_02 = EnergyTransferMode_dc_bpt;    
+    EnergyTransferMode_t *mode03_02_03 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_03 = EnergyTransferMode_ac;
+    EnergyTransferMode_t *mode03_02_04 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_02_04 = EnergyTransferMode_ac_bpt;
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> authorizationMethod.list, auth03_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> authorizationMethod.list, auth03_02_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_03);
+    ASN_SEQUENCE_ADD(&sec_profile03_02 -> energyTransferMode.list, mode03_02_04);
+    
+    /* and (TLS13_mutual with EIM & PNC_2 & PNC_20 with dc & dc-bpt & ac & ac-bpt) */
+    SecurityProfileTuple_t *sec_profile03_03 = (SecurityProfileTuple_t *)calloc(1, sizeof(SecurityProfileTuple_t));
+    sec_profile03_03 -> securityProfile = SecurityProfile_tls13_mutual;
+    AuthorizationMethod_t *auth03_03_01 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_03_01 = AuthorizationMethod_eim;
+    AuthorizationMethod_t *auth03_03_02 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_03_02 = AuthorizationMethod_pnc_2;
+    AuthorizationMethod_t *auth03_03_03 = (AuthorizationMethod_t *)calloc(1, sizeof(AuthorizationMethod_t));
+    *auth03_03_03 = AuthorizationMethod_pnc_20;    
+    EnergyTransferMode_t *mode03_03_01 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_01 = EnergyTransferMode_dc;
+    EnergyTransferMode_t *mode03_03_02 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_02 = EnergyTransferMode_dc_bpt;    
+    EnergyTransferMode_t *mode03_03_03 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_03 = EnergyTransferMode_ac;
+    EnergyTransferMode_t *mode03_03_04 = (EnergyTransferMode_t *)calloc(1, sizeof(EnergyTransferMode_t));
+    *mode03_03_04 = EnergyTransferMode_ac_bpt;
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> authorizationMethod.list, auth03_03_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> authorizationMethod.list, auth03_03_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> authorizationMethod.list, auth03_03_03);    
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_01);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_02);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_03);
+    ASN_SEQUENCE_ADD(&sec_profile03_03 -> energyTransferMode.list, mode03_03_04);
+    ASN_SEQUENCE_ADD(&hlc_tuple03 -> securityProfileTuple.list, sec_profile03_01);
+    ASN_SEQUENCE_ADD(&hlc_tuple03 -> securityProfileTuple.list, sec_profile03_02);
+    ASN_SEQUENCE_ADD(&hlc_tuple03 -> securityProfileTuple.list, sec_profile03_03);
+    ASN_SEQUENCE_ADD(&hlc -> list, hlc_tuple03);
+    
+    /* Add hlc sequence of hlc_tuples to extensions -> extensionValue and standardized extension */
+    uint8_t *hlc_buffer = (uint8_t *)calloc(256, sizeof(uint8_t));
+    asn_enc_rval_t hlc_enc_rval = der_encode_to_buffer(&asn_DEF_HighLevelCommunication, hlc, hlc_buffer, 256);
+    //dlog(DLOG_LEVEL_INFO, "HLC data encoded: %zu bytes\n", hlc_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&hlc_ext -> extensionValue, (char *)hlc_buffer, hlc_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, hlc_ext);
+    free(hlc_buffer);
+
+    /* ExtensionID 5 - EMSP identifiers extension */
+    /* Using placeholder EMSP values for now */
+    /* Be sure to order EMSPIdentifiers list based on priority per [V2G200-542-3] in ISO/PAS CD 15118-200:2024(E) - STANDARD NOT YET PUBLISHED */
+    StandardizedExtension_t *emsp_ids_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    emsp_ids_ext -> extensionID = 5;
+    EMSPIdentifiers_t *emsp_ids = (EMSPIdentifiers_t *)calloc(1, sizeof(EMSPIdentifiers_t));
+    EMSPIdentifier_t *emsp_id01 = (EMSPIdentifier_t *)calloc(1, sizeof(EMSPIdentifier_t));
+    OCTET_STRING_fromBuf(emsp_id01, "EMSP_1", strlen("EMSP_1"));
+    ASN_SEQUENCE_ADD(&emsp_ids -> list, emsp_id01);
+    EMSPIdentifier_t *emsp_id02 = (EMSPIdentifier_t *)calloc(1, sizeof(EMSPIdentifier_t));
+    OCTET_STRING_fromBuf(emsp_id02, "EMSP_2", strlen("EMSP_2"));
+    ASN_SEQUENCE_ADD(&emsp_ids -> list, emsp_id02);
+    uint8_t *emsp_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t emsp_enc_rval = der_encode_to_buffer(&asn_DEF_EMSPIdentifiers, emsp_ids, emsp_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "EMSP Identifiers data encoded: %zu bytes\n", emsp_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&emsp_ids_ext -> extensionValue, (char *)emsp_buffer, emsp_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, emsp_ids_ext);
+    free(emsp_buffer);
+
+    /* ExtensionID 6 - DC charging limits extension */
+    /* Using placeholder values for Maximum and Minimum voltage limits */
+    StandardizedExtension_t *dc_limits_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    dc_limits_ext -> extensionID = 6;
+    DCChargingLimits_t *dc_limits = (DCChargingLimits_t *)calloc(1, sizeof(DCChargingLimits_t));
+    dc_limits -> maximumVoltage = 1000;
+    dc_limits -> minimumVoltage = 250;
+    uint8_t *dc_limits_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t dc_limits_enc_rval = der_encode_to_buffer(&asn_DEF_DCChargingLimits, dc_limits, dc_limits_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "DC Charging Limits data encoded: %zu bytes\n", dc_limits_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&dc_limits_ext -> extensionValue, (char *)dc_limits_buffer, dc_limits_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, dc_limits_ext);
+    free(dc_limits_buffer);
+
+    /* ExtensionID 7 - Conductive Charging Interface Limitations extension */
+    /* Using placeholder values for Maximum contactor temperature */
+    StandardizedExtension_t *chrg_int_limits_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    chrg_int_limits_ext -> extensionID = 7;
+    ConductiveChargingInterfaceLimitations_t *chrg_int_limits = (ConductiveChargingInterfaceLimitations_t *)calloc(1, sizeof(ConductiveChargingInterfaceLimitations_t));
+    chrg_int_limits -> maximumContactorTemperature = 80;
+    uint8_t *chrg_int_limits_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t chrg_int_limits_enc_rval = der_encode_to_buffer(&asn_DEF_ConductiveChargingInterfaceLimitations,
+                    chrg_int_limits, chrg_int_limits_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "Conductive Charging Interface Limits data encoded: %zu bytes\n", chrg_int_limits_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&chrg_int_limits_ext -> extensionValue, (char *)chrg_int_limits_buffer,
+                    chrg_int_limits_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, chrg_int_limits_ext);
+    free(chrg_int_limits_buffer);
+
+    /* ExtensionID 8 - EV Characteristics extension */
+    StandardizedExtension_t *evChar_ext = (StandardizedExtension_t *)calloc(1, sizeof(StandardizedExtension_t));
+    evChar_ext -> extensionID = 8;
+    EVCharacteristics_t *evChar = (EVCharacteristics_t *)calloc(1, sizeof(EVCharacteristics_t));
+    evChar -> vehicleIdentificationNumber = (OCTET_STRING_t *)calloc(1, sizeof(OCTET_STRING_t));
+    evChar -> evccSoftwareVersion = (UTF8String_t *)calloc(1, sizeof(UTF8String_t));
+    const uint8_t vin[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00};
+    const unsigned char evcc_sw[] = "v2.5.6_20241031";
+    OCTET_STRING_fromBuf(evChar -> vehicleIdentificationNumber, (char *)vin, sizeof(vin));
+    OCTET_STRING_fromBuf(evChar -> evccSoftwareVersion, (char *)evcc_sw, sizeof(evcc_sw));
+    uint8_t *evChar_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t evChar_enc_rval = der_encode_to_buffer(&asn_DEF_EVCharacteristics, evChar, evChar_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "EV Characteristics data encoded: %zu bytes\n", evChar_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&evChar_ext -> extensionValue, (char *)evChar_buffer, evChar_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, evChar_ext);
+    free(evChar_buffer);
+
+    /* ExtensionID 9 - Charging Station Characteristics extension */
+    /* Using placeholder values for evseID and EVSE Software version */
+    StandardizedExtension_t *evseChar_ext = (StandardizedExtension_t *)calloc(1,sizeof(StandardizedExtension_t));
+    evseChar_ext -> extensionID = 9;
+    ChargingStationCharacteristics_t *evseChar = (ChargingStationCharacteristics_t *)calloc(1, sizeof(ChargingStationCharacteristics_t));
+    evseChar -> evseID = (OCTET_STRING_t *)calloc(1, sizeof(OCTET_STRING_t));
+    evseChar -> seccSoftwareVersion = (UTF8String_t *)calloc(1, sizeof(UTF8String_t));
+    const uint8_t evseID[] = {0x08, 0x00, 0x27, 0x0F, 0x1D, 0x55};
+    const char evse_sw[] = "vXX.XX.XX";
+    OCTET_STRING_fromBuf(evseChar -> evseID, (char *)evseID, sizeof(evseID));
+    OCTET_STRING_fromBuf(evseChar -> seccSoftwareVersion, evse_sw, sizeof(evse_sw));
+    uint8_t *evseChar_buffer = (uint8_t *)calloc(128, sizeof(uint8_t));
+    asn_enc_rval_t evseChar_enc_rval = der_encode_to_buffer(&asn_DEF_ChargingStationCharacteristics, evseChar, evseChar_buffer, 128);
+    //dlog(DLOG_LEVEL_INFO, "EVSE Characteristics data encoded: %zu bytes\n", evseChar_enc_rval.encoded);
+    OCTET_STRING_fromBuf(&evseChar_ext -> extensionValue, (char *)evseChar_buffer, evseChar_enc_rval.encoded);
+    ASN_SEQUENCE_ADD(&extensions -> standardized, evseChar_ext);
+    free(evseChar_buffer);
+
+    /* The following commented code block can be used for debugging asn1 encode output */
+    //xer_fprint(stdout, &asn_DEF_Extensions, extensions);
+    /* dlog(DLOG_LEVEL_INFO, "Number of standardized extensions: %ld", extensions->standardized.list.count);
+    for (int p = 0; p < extensions -> standardized.list.count; p++) {
+        StandardizedExtension_t *temp = extensions -> standardized.list.array[p];
+        dlog(DLOG_LEVEL_INFO, "Extension ID: %ld, Value Size: %ld", temp -> extensionID, temp -> extensionValue.size);
+    } */
+
+    asn_enc_rval_t ec = der_encode_to_buffer(&asn_DEF_Extensions, extensions, buffer_esdp + offset, MAX_ESDP_RESPONSE_PAYLOAD_LEN);
+    if (ec.encoded <= 0) {
+        dlog(DLOG_LEVEL_ERROR, "Failed to encode ESDP Extensions to ESDP buffer. encoded: %ld", ec.encoded);
+        dlog(DLOG_LEVEL_ERROR, "DER encoding failed at type: %s", ec.failed_type -> name);
+        return -1;
+    } else {
+        dlog(DLOG_LEVEL_INFO, "ESDP extensions data encoded: %zu bytes", ec.encoded);
+        offset += ec.encoded;
+    }
+
+    return offset;
+}
+
+/* Create response packet for ESDP */
+int esdp_create_response(uint8_t* buffer_esdp, struct sockaddr_in6* addr, enum sdp_security security,
+                        enum sdp_transport_protocol proto) {
+    int offset = SDP_HEADER_LEN; // Header length is same for both SDP and ESDP
+    int encode_return;
+    
+    // Write ESDP Version
+    buffer_esdp[offset++] = (ESDP_VERSION >> 8) & 0xff;
+    buffer_esdp[offset++] = ESDP_VERSION & 0xff;
+    
+    // Write Max V2GTP Payload Size
+    buffer_esdp[offset++] = (ESDP_MAX_V2GTP_PAYLOAD_SIZE >> 8) & 0xff;
+    buffer_esdp[offset++] = ESDP_MAX_V2GTP_PAYLOAD_SIZE & 0xff;
+
+    /* Now fill in the rest of the buffer with ESDP Extensions payload */
+    encode_return = encode_ESDPRes_Extensions(buffer_esdp, offset, addr, security);
+    if (encode_return > 0) {
+        offset = encode_return;
+    }
+
+    /* now fill in the header with payload length */
+    sdp_write_header(buffer_esdp, ESDP_RESPONSE_TYPE, offset - SDP_HEADER_LEN);
+
+    return offset;
+}
+
 /*
  * Sends a SDP response packet
  */
@@ -204,8 +613,415 @@ int sdp_send_response(int sdp_socket, struct sdp_query* sdp_query) {
     return rv;
 }
 
+/*
+ * Sends a response packet for ESDP
+ */
+int esdp_send_response(int esdp_socket, struct sdp_query* sdp_query) {
+    uint8_t buffer_esdp[SDP_HEADER_LEN + MAX_ESDP_RESPONSE_PAYLOAD_LEN];
+    int rv = 0;
+    int esdp_response_size;
+
+    /* at the moment we only understand TCP protocol */
+    if (sdp_query->proto_requested != SDP_TRANSPORT_PROTOCOL_TCP) {
+        dlog(DLOG_LEVEL_ERROR, "ESDP requested unsupported protocol 0x%02x, announcing nothing",
+             sdp_query->proto_requested);
+        return 1;
+    }
+
+    switch (sdp_query->security_requested) {
+    case SDP_SECURITY_TLS:
+        if (sdp_query->v2g_ctx->local_tls_addr) {
+            dlog(DLOG_LEVEL_INFO, "ESDP requested TLS, announcing TLS");
+            esdp_response_size = esdp_create_response(buffer_esdp, sdp_query->v2g_ctx->local_tls_addr, SDP_SECURITY_TLS,
+                                SDP_TRANSPORT_PROTOCOL_TCP);
+            break;
+        }
+        if (sdp_query->v2g_ctx->local_tcp_addr) {
+            dlog(DLOG_LEVEL_INFO, "ESDP requested TLS, announcing NO-TLS");
+            esdp_response_size = esdp_create_response(buffer_esdp, sdp_query->v2g_ctx->local_tcp_addr, SDP_SECURITY_NONE,
+                                SDP_TRANSPORT_PROTOCOL_TCP);
+            break;
+        }
+        dlog(DLOG_LEVEL_ERROR, "ESDP requested TLS, announcing nothing");
+        return 1;
+
+    case SDP_SECURITY_NONE:
+        if (sdp_query->v2g_ctx->local_tcp_addr) {
+            dlog(DLOG_LEVEL_INFO, "ESDP requested NO-TLS, announcing NO-TLS");
+            esdp_response_size = esdp_create_response(buffer_esdp, sdp_query->v2g_ctx->local_tcp_addr, SDP_SECURITY_NONE,
+                                SDP_TRANSPORT_PROTOCOL_TCP);
+            break;
+        }
+        if (sdp_query->v2g_ctx->local_tls_addr) {
+            dlog(DLOG_LEVEL_INFO, "ESDP requested NO-TLS, announcing TLS");
+            esdp_response_size = esdp_create_response(buffer_esdp, sdp_query->v2g_ctx->local_tls_addr, SDP_SECURITY_TLS,
+                                SDP_TRANSPORT_PROTOCOL_TCP);
+            break;
+        }
+        dlog(DLOG_LEVEL_ERROR, "ESDP requested NO-TLS, announcing nothing");
+        return 1;
+
+    default:
+        dlog(DLOG_LEVEL_ERROR, "ESDP requested unsupported security 0x%02x, announcing nothing",
+             sdp_query->security_requested);
+        return 1;
+    }
+
+    int return_status = sendto(esdp_socket, buffer_esdp, esdp_response_size, 0, (struct sockaddr*)&sdp_query->remote_addr,
+        sizeof(struct sockaddr_in6));
+
+    if (return_status != esdp_response_size) {
+        rv = -1;
+    }
+    if (DEBUG) {
+        char addrbuf[INET6_ADDRSTRLEN] = {0};
+        const char* addr;
+        int saved_errno = errno;
+
+        addr = inet_ntop(AF_INET6, &sdp_query->remote_addr.sin6_addr, addrbuf, sizeof(addrbuf));
+        if (rv == 0) {
+            dlog(DLOG_LEVEL_INFO, "sendto([%s]:%" PRIu16 ") succeeded for ESDP", addr, ntohs(sdp_query->remote_addr.sin6_port));
+        } else {
+            dlog(DLOG_LEVEL_ERROR, "sendto([%s]:%" PRIu16 ") failed: %s for ESDP", addr, ntohs(sdp_query->remote_addr.sin6_port),
+                 strerror(saved_errno));
+        }
+    }
+    
+    dlog(DLOG_LEVEL_INFO, "Size of ESDPRes message sent: %zu bytes", return_status);
+
+    return rv;
+}
+
+// Function to decode the Standardized ESDP extensions
+int decode_standardized_extensions(const StandardizedExtensions_t *extensions, struct sdp_query* sdp_query) {
+    /* Returns 1 if unable to decode Standardized ESDP extensions and 0 otherwise */
+    /* Requested Security and Transport must be updated in the "sdp_query" struct with the values decoded in HLC Extension (ID 4).
+        Currently these are hardcoded to No-TLS and TCP respectively in "sdp_listen" under esdp */
+    if (!extensions) {
+        dlog(DLOG_LEVEL_ERROR, "No Standardized ESDP extensions to decode");
+        return 1;
+    }
+
+    for (int i = 0; i < extensions -> list.count; i++) {
+        StandardizedExtension_t *ext = extensions -> list.array[i];
+        if (ext) {
+            //dlog(DLOG_LEVEL_INFO, "Extension ID: %ld", ext -> extensionID);
+
+            uint8_t *extensionVal_buf = ext -> extensionValue.buf;
+            ssize_t extensionVal_size = ext -> extensionValue.size;
+
+            switch(ext -> extensionID) {
+                case 1: {
+                    ChargingInterface_t *ev_chrg_int = NULL;
+                    asn_dec_rval_t rval_chrg_int = ber_decode(NULL, &asn_DEF_ChargingInterface, (void **)&ev_chrg_int, 
+                        extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_chrg_int.code == RC_OK) {
+                        dlog(DLOG_LEVEL_INFO, "Successfully decoded Charging Interface extension");
+                        /* Placeholder switch block for future code expansion */
+                        switch(*ev_chrg_int) {
+                            case ChargingInterface_nacs:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: NACS");
+                                break;
+                            case ChargingInterface_ccs1:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: CCS1");
+                                break;
+                            case ChargingInterface_ccs2:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: CCS2");
+                                break;
+                            case ChargingInterface_chademo:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: CHAdeMO");
+                                break;
+                            case ChargingInterface_chaoji:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: Chaoji");
+                                break;
+                            case ChargingInterface_type_1:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: Type-1");
+                                break;
+                            case ChargingInterface_type_2:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: Type-2");
+                                break;
+                            case ChargingInterface_mcs:
+                                dlog(DLOG_LEVEL_INFO, "     Charging Interface: MCS");
+                                break;
+                            default:
+                                dlog(DLOG_LEVEL_ERROR, "    Unknown Charging Interface");
+                                break;
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_ChargingInterface, ev_chrg_int);
+                    } else {
+                        dlog(DLOG_LEVEL_ERROR, "Failed to decode Charging Interface extension");
+                    }
+                    break;
+                }
+                case 2: {
+                    BasicSignaling_t *ev_bsc_sgnlng = NULL;
+                    asn_dec_rval_t rval_bsc_sgnlng = ber_decode(NULL, &asn_DEF_BasicSignaling, (void **)&ev_bsc_sgnlng,
+                                    extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_bsc_sgnlng.code == RC_OK) {
+                        dlog(DLOG_LEVEL_INFO, "Successfully decoded Basic Signaling Protocol extension");
+                        for (int k = 0; k < ev_bsc_sgnlng -> list.count; k++) {
+                            /* Placeholder switch block for future code expansion */
+                            switch(*ev_bsc_sgnlng -> list.array[k]) {
+                                case BasicSignalingProtocol_iec61851_1_ED2:
+                                    dlog(DLOG_LEVEL_INFO, "     Basic Signaling Protocol[%ld]: IEC 61851-01 Ed-02", k+1);
+                                    break;
+                                case BasicSignalingProtocol_iec61851_1_ED3:
+                                    dlog(DLOG_LEVEL_INFO, "     Basic Signaling Protocol[%ld]: IEC 61851-01 Ed-03", k+1);
+                                    break;
+                                case BasicSignalingProtocol_iec61851_23_ED1:
+                                    dlog(DLOG_LEVEL_INFO, "     Basic Signaling Protocol[%ld]: IEC 61851-23 Ed-01", k+1);
+                                    break;
+                                case BasicSignalingProtocol_iec61851_23_ED2:
+                                    dlog(DLOG_LEVEL_INFO, "     Basic Signaling Protocol[%ld]: IEC 61851-23 Ed-02", k+1);
+                                    break;
+                                default:
+                                    dlog(DLOG_LEVEL_ERROR, "    Unknown Basic Signaling Protocol");
+                                    break;
+                            }
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_BasicSignaling, ev_bsc_sgnlng);
+                    } else {
+                        dlog(DLOG_LEVEL_ERROR, "Failed to decode Basic Signaling extension");
+                    }
+                    break;
+                }
+                case 3: {
+                    IPv6Socket_t *ev_ip_socket = NULL;
+                    asn_dec_rval_t rval_ip_socket = ber_decode(NULL, &asn_DEF_IPv6Socket, (void **)&ev_ip_socket,
+                        extensionVal_buf, extensionVal_size);
+                    
+                    dlog(DLOG_LEVEL_WARNING, "ESDPReq payload includes IPv6 Socket extension");
+                    break;
+                }
+                case 4: {
+                    HighLevelCommunication_t *ev_hlc = NULL;
+                    asn_dec_rval_t rval_hlc = ber_decode(NULL, &asn_DEF_HighLevelCommunication, (void **)&ev_hlc,
+                        extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_hlc.code == RC_OK) {
+                        dlog(DLOG_LEVEL_INFO, "Successfully decoded HLC Extension");
+                        /* Placeholder switch block for future code expansion */
+                        for (int ii = 0; ii < ev_hlc -> list.count; ii++) {
+                            HighLevelCommunicationTuple_t *tuple = ev_hlc -> list.array[ii];
+                            switch (tuple -> hlcProtocol) {
+                                case HLCProtocol_din_spec_70121_2014:
+                                    break;
+                                case HLCProtocol_iso_15118_2_2014:
+                                    break;
+                                case HLCProtocol_iso_15118_20_2022:
+                                    break;
+                                default:
+                                    dlog(DLOG_LEVEL_ERROR, "    Unknown HLC Protocol (%ld)", tuple -> hlcProtocol);
+                                    break;
+                            }
+                            for (int jj = 0; jj < tuple -> securityProfileTuple.list.count; jj++) {
+                                SecurityProfileTuple_t *sp_tuple = tuple -> securityProfileTuple.list.array[jj];
+                                switch(sp_tuple -> securityProfile) {
+                                    case SecurityProfile_tcpOnly:
+                                        //sdp_query->security_requested = SDP_SECURITY_NONE;
+                                        break;
+                                    case SecurityProfile_tls12_server:
+                                        //sdp_query->security_requested = SDP_SECURITY_TLS;
+                                        break;
+                                    case SecurityProfile_tls13_mutual:
+                                        break;
+                                    default:
+                                        dlog(DLOG_LEVEL_ERROR, "    Unknown Security Profile (%ld)", sp_tuple -> securityProfile);
+                                        break;
+                                }
+                                for (int kk = 0; kk < sp_tuple -> authorizationMethod.list.count; kk++) {
+                                    AuthorizationMethod_t *auth_method = sp_tuple -> authorizationMethod.list.array[kk];
+                                    switch(*auth_method) {
+                                        case AuthorizationMethod_eim:
+                                            break;
+                                        case AuthorizationMethod_pnc_2:
+                                            break;
+                                        case AuthorizationMethod_pnc_20:
+                                            break;
+                                        default:
+                                            dlog(DLOG_LEVEL_ERROR, "    Unknown Authorization Method (%ld)", *auth_method);
+                                            break;
+                                    }
+                                }
+                                for (int kk = 0; kk < sp_tuple -> energyTransferMode.list.count; kk++) {
+                                    EnergyTransferMode_t *energy_mode = sp_tuple -> energyTransferMode.list.array[kk];
+                                    switch(*energy_mode) {
+                                        case EnergyTransferMode_dc:
+                                            break;
+                                        case EnergyTransferMode_dc_bpt:
+                                            break;
+                                        case EnergyTransferMode_ac:
+                                            break;
+                                        case EnergyTransferMode_ac_bpt:
+                                            break;
+                                        default:
+                                            dlog(DLOG_LEVEL_ERROR, "    Unknown Energy Transfer Mode (%ld)", *energy_mode);
+                                            break;
+                                    }
+                                }
+                            }
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_HighLevelCommunication, ev_hlc);
+                    } else {
+                        dlog(DLOG_LEVEL_ERROR, "Failed to decode HLC extension");
+                    }
+                    break;
+                }
+                case 5: {
+                    EMSPIdentifiers_t *ev_emsp = NULL;
+                    asn_dec_rval_t rval_emsp = ber_decode(NULL, &asn_DEF_EMSPIdentifiers, (void **)&ev_emsp,
+                        extensionVal_buf, extensionVal_size);
+                    
+                    /* if (rval_emsp.code == RC_OK) {
+                        dlog(DLOG_LEVEL_INFO, "Successfully decoded EMSP Identifiers extension");
+                        for (int k = 0; k < ev_emsp -> list.count; k++) {
+                            dlog(DLOG_LEVEL_INFO, "EMSP Identifier[%d]: %s\n", k+1, ev_emsp -> list.array[k] -> buf);
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_EMSPIdentifiers, ev_emsp);
+                    } else {
+                        dlog(DLOG_LEVEL_ERROR, "Failed to decode EMSP Identifiers extension");
+                    } */
+                    dlog(DLOG_LEVEL_WARNING, "ESDPReq payload includes EMSP Identifiers extension");
+                    break;
+                }
+                case 6: {
+                    DCChargingLimits_t *ev_limits = NULL;
+                    asn_dec_rval_t rval_limits = ber_decode(NULL, &asn_DEF_DCChargingLimits, (void **)&ev_limits,
+                                    extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_limits.code == RC_OK) {
+                        dlog(DLOG_LEVEL_INFO, "Successfully decoded DC Charging Limits extension");
+                        dlog(DLOG_LEVEL_INFO, "     Maximum Voltage: %ld [V]\n", ev_limits -> maximumVoltage);
+                        dlog(DLOG_LEVEL_INFO, "     Minimum Voltage: %ld [V]\n", ev_limits -> minimumVoltage);
+                        ASN_STRUCT_FREE(asn_DEF_DCChargingLimits, ev_limits);
+                    } else {
+                        dlog(DLOG_LEVEL_ERROR,"Failed to decode DC Charging Limits extension");
+                    }
+                    break;
+                }
+                case 7: {
+                    ConductiveChargingInterfaceLimitations_t *ev_interface_limits = NULL;
+                    asn_dec_rval_t rval_int_limits = ber_decode(NULL, &asn_DEF_ConductiveChargingInterfaceLimitations,
+                                    (void **)&ev_interface_limits, extensionVal_buf, extensionVal_size);
+                    
+                    if (rval_int_limits.code == RC_OK) {
+                        dlog(DLOG_LEVEL_INFO, "Successfully decoded Conductive Charging Interface Limitations extension");
+                        dlog(DLOG_LEVEL_INFO, "     Maximum Contactor Temp: %ld [C]\n", ev_interface_limits -> maximumContactorTemperature);
+                        ASN_STRUCT_FREE(asn_DEF_ConductiveChargingInterfaceLimitations, ev_interface_limits);
+                    } else {
+                        dlog(DLOG_LEVEL_ERROR, "Failed to decode Conductive Charging Interface Limitations extension");
+                    }
+                    break;
+                }
+                case 8: {
+                    EVCharacteristics_t *evChar = NULL;
+                    asn_dec_rval_t rval_evChar = ber_decode(NULL, &asn_DEF_EVCharacteristics, (void **)&evChar,
+                                    extensionVal_buf, extensionVal_size);
+
+                    if(rval_evChar.code == RC_OK) {
+                        dlog(DLOG_LEVEL_INFO, "Successfully decoded EV Characteristics extension");
+                        if (evChar -> vehicleIdentificationNumber -> size > 0) {
+                            dlog(DLOG_LEVEL_INFO, "     VIN (in Hex format): %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X",
+                                evChar->vehicleIdentificationNumber -> buf[0], evChar->vehicleIdentificationNumber -> buf[1],
+                                evChar -> vehicleIdentificationNumber -> buf[2], evChar -> vehicleIdentificationNumber -> buf[3],
+                                evChar -> vehicleIdentificationNumber -> buf[4], evChar -> vehicleIdentificationNumber -> buf[5],
+                                evChar -> vehicleIdentificationNumber -> buf[6], evChar -> vehicleIdentificationNumber -> buf[7],
+                                evChar -> vehicleIdentificationNumber -> buf[8], evChar -> vehicleIdentificationNumber -> buf[9],
+                                evChar -> vehicleIdentificationNumber -> buf[10], evChar -> vehicleIdentificationNumber -> buf[11],
+                                evChar -> vehicleIdentificationNumber -> buf[12], evChar -> vehicleIdentificationNumber -> buf[13],
+                                evChar -> vehicleIdentificationNumber -> buf[14], evChar -> vehicleIdentificationNumber -> buf[15],
+                                evChar -> vehicleIdentificationNumber -> buf[16]);
+                            for (size_t i = 0; i < evChar -> vehicleIdentificationNumber -> size; i++) {
+                                //printf("%02X", evChar -> vehicleIdentificationNumber -> buf[i]);
+                            }
+                        } else {
+                            dlog(DLOG_LEVEL_WARNING, "Vehicle Identification Number was NOT communicated");
+                        }
+                        if (evChar -> evccSoftwareVersion -> size > 0) {
+                            dlog(DLOG_LEVEL_INFO, "     EVCC Software Version: %.*s\n", (int)evChar -> evccSoftwareVersion -> size,
+                                evChar -> evccSoftwareVersion -> buf);
+                        } else {
+                            dlog(DLOG_LEVEL_WARNING, "EVCC Software version was NOT communicated");
+                        }
+                        ASN_STRUCT_FREE(asn_DEF_EVCharacteristics, evChar);
+                    } else {
+                        dlog(DLOG_LEVEL_ERROR, "Failed to decode EV Characteristics extension");
+                    }
+                    break;
+                }
+                case 9: {
+                    dlog(DLOG_LEVEL_WARNING, "ESDPReq payload includes Charging Station Characteristics extension");
+                    break;
+                }
+                default:
+                    dlog(DLOG_LEVEL_WARNING, "Unknown Extension ID: %ld", ext -> extensionID);
+                    break;
+            }
+        }
+    }
+
+    /* Since Transport protocol is not included in HLC Extension under ESDP Standardized extensions,
+        this is currently being hardcoded*/
+    sdp_query->proto_requested = SDP_TRANSPORT_PROTOCOL_TCP;
+    
+    /* Currently hardcoding security to No-TLS. This line can be removed when this value starts getting 
+        set from decoded HLC Extension */
+    sdp_query->security_requested = SDP_SECURITY_NONE;
+
+    return 0;
+}
+
+// Function to decode ESDP extensions in V2GTP payload in ESDPReq message
+int decode_esdp_payload(uint8_t* buffer, struct sdp_query* sdp_query, ssize_t recv_len) {
+    /* Returns 1 if unable to decode esdp extensions and 0 otherwise*/
+
+    int dec_std_ext_return;
+    ssize_t asn1_payload_size = recv_len - SDP_HEADER_LEN - 4;
+
+    // Create a new buffer which only contains the ASN1 encoded ESDP extensions
+    uint8_t *buffer_esdp = (uint8_t *)calloc(asn1_payload_size, sizeof(uint8_t)); // "4" Since ESDPVersion, max payload size, require 2 bytes each.
+
+    // Copy ESDP Extensions from received message buffer to the new buffer.
+    memcpy(buffer_esdp, buffer + SDP_HEADER_LEN + 4, asn1_payload_size);
+
+    /* Decode the buffer into "extensions" object*/
+    Extensions_t *extensions = (Extensions_t *)calloc(1, sizeof(Extensions_t));
+
+    asn_dec_rval_t rval = asn_decode(NULL, ATS_DER, &asn_DEF_Extensions, (void **)&extensions, buffer_esdp, asn1_payload_size);
+    if (rval.code != RC_OK) {
+        dlog(DLOG_LEVEL_ERROR, "Decoding failed at byte %ld", rval.consumed);
+        ASN_STRUCT_FREE(asn_DEF_Extensions, extensions);
+        return 1;
+    } else {
+        dlog(DLOG_LEVEL_INFO, "Successully decoded ESDPReq payload");
+    }
+
+    /* Decode Standardized Extensions*/
+    dec_std_ext_return = decode_standardized_extensions(&extensions -> standardized, sdp_query);
+    
+    if (dec_std_ext_return) {
+        dlog(DLOG_LEVEL_ERROR, "Failed to decode Standardized Extensions in ESDPReq payload");
+    } else {
+        dlog(DLOG_LEVEL_INFO, "Successfully decoded Standardized Extensions in ESDPReq payload");
+    }
+    
+    /* Check presence of external extensions per ISO/PAS CD 15118-200:2024(E)*/
+    
+    if (extensions -> external) {
+        dlog(DLOG_LEVEL_INFO, "External ESDP Extensions present in the received ESDPReq message");
+        // Define a function to decode external extensions and call it here.
+    } else {
+        dlog(DLOG_LEVEL_INFO, "External ESDP Extensions NOT present in the received ESDPReq message");
+    }
+
+    return 0;
+}
+
 int sdp_init(struct v2g_context* v2g_ctx) {
     struct sockaddr_in6 sdp_addr = {AF_INET6, htons(SDP_SRV_PORT)};
+    struct sockaddr_in6 esdp_addr = {AF_INET6, htons(ESDP_SRV_PORT)}; // For ESDP
     struct ipv6_mreq mreq = {{IN6ADDR_ALLNODES}, 0};
     int enable = 1;
 
@@ -221,22 +1037,45 @@ int sdp_init(struct v2g_context* v2g_ctx) {
         dlog(DLOG_LEVEL_ERROR, "socket() failed: %s", strerror(errno));
         return -1;
     }
+    
+    /* create receiving esdp socket for ESDP*/
+    v2g_ctx->esdp_socket = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+    if (v2g_ctx->esdp_socket == -1) {
+        dlog(DLOG_LEVEL_ERROR, "socket() failed for ESDP: %s", strerror(errno));
+        return -1;
+    }    
 
     if (setsockopt(v2g_ctx->sdp_socket, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) == -1) {
         dlog(DLOG_LEVEL_ERROR, "setsockopt(SO_REUSEPORT) failed: %s", strerror(errno));
         close(v2g_ctx->sdp_socket);
         return -1;
     }
-
+    
+    /* enable the Option "SO_REUSEPORT" for ESDP socket */
+    if (setsockopt(v2g_ctx->esdp_socket, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) == -1) {
+        dlog(DLOG_LEVEL_ERROR, "setsockopt(SO_REUSEPORT) failed for ESDP: %s", strerror(errno));
+        close(v2g_ctx->esdp_socket);
+        return -1;
+    }
+    
     sdp_addr.sin6_addr = in6addr_any;
+    esdp_addr.sin6_addr = in6addr_any; // For ESDP
 
     if (bind(v2g_ctx->sdp_socket, (struct sockaddr*)&sdp_addr, sizeof(sdp_addr)) == -1) {
         dlog(DLOG_LEVEL_ERROR, "bind() failed: %s", strerror(errno));
         close(v2g_ctx->sdp_socket);
         return -1;
     }
-
+    
+    /* bind esdp_socket to esdp_addr for ESDP */
+    if (bind(v2g_ctx->esdp_socket, (struct sockaddr*)&esdp_addr, sizeof(esdp_addr)) == -1) {
+        dlog(DLOG_LEVEL_ERROR, "bind() failed for ESDP socket: %s", strerror(errno));
+        close(v2g_ctx->esdp_socket);
+        return -1;
+    }
+    
     dlog(DLOG_LEVEL_INFO, "SDP socket setup succeeded");
+    dlog(DLOG_LEVEL_INFO, "ESDP socket setup succeeded"); // For ESDP
 
     /* bind only to specified device */
     if (setsockopt(v2g_ctx->sdp_socket, SOL_SOCKET, SO_BINDTODEVICE, v2g_ctx->if_name, strlen(v2g_ctx->if_name)) ==
@@ -246,7 +1085,16 @@ int sdp_init(struct v2g_context* v2g_ctx) {
         return -1;
     }
 
+    /* bind ESDP socket only to specified device for ESDP */
+    if (setsockopt(v2g_ctx->esdp_socket, SOL_SOCKET, SO_BINDTODEVICE, v2g_ctx->if_name, strlen(v2g_ctx->if_name)) ==
+        -1) {
+        dlog(DLOG_LEVEL_ERROR, "setsockopt(SO_BINDTODEVICE) failed for ESDP: %s", strerror(errno));
+        close(v2g_ctx->esdp_socket);
+        return -1;
+    }
+
     dlog(DLOG_LEVEL_TRACE, "bind only to specified device");
+    dlog(DLOG_LEVEL_TRACE, "bind only to specified device for ESDP");
 
     /* join multicast group */
     if (setsockopt(v2g_ctx->sdp_socket, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) == -1) {
@@ -255,7 +1103,15 @@ int sdp_init(struct v2g_context* v2g_ctx) {
         return -1;
     }
 
+    /* join multicast group for ESDP socket */
+    if (setsockopt(v2g_ctx->esdp_socket, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) == -1) {
+        dlog(DLOG_LEVEL_ERROR, "setsockopt(IPV6_JOIN_GROUP) failed for ESDP: %s", strerror(errno));
+        close(v2g_ctx->esdp_socket);
+        return -1;
+    }
+
     dlog(DLOG_LEVEL_TRACE, "joined multicast group");
+    dlog(DLOG_LEVEL_TRACE, "joined multicast group for ESDP");
 
     return 0;
 }
@@ -264,14 +1120,21 @@ int sdp_listen(struct v2g_context* v2g_ctx) {
     /* Init pollfd struct */
     struct pollfd pollfd = {v2g_ctx->sdp_socket, POLLIN, 0};
 
+    /* Init pollfd struct for ESDP socket */
+    struct pollfd pollfd_esdp = {v2g_ctx->esdp_socket, POLLIN, 0};
+
     while (!v2g_ctx->shutdown) {
         uint8_t buffer[SDP_HEADER_LEN + SDP_REQUEST_PAYLOAD_LEN];
+        uint8_t buffer_esdp[SDP_HEADER_LEN + MAX_ESDP_REQUEST_PAYLOAD_LEN]; // For ESDP
+        memset(buffer_esdp, 0, sizeof(buffer_esdp)); // For ESDP
         char addrbuf[INET6_ADDRSTRLEN] = {0};
         const char* addr = addrbuf;
         struct sdp_query sdp_query = {
             .v2g_ctx = v2g_ctx,
         };
         socklen_t addrlen = sizeof(sdp_query.remote_addr);
+        int func_return;
+        int decode_return;
 
         /* Check if data was received on socket */
         signed status = poll(&pollfd, 1, POLL_TIMEOUT);
@@ -316,11 +1179,79 @@ int sdp_listen(struct v2g_context* v2g_ctx) {
 
             sdp_send_response(v2g_ctx->sdp_socket, &sdp_query);
         }
+        
+        /* Check if data was received on esdp socket for ESDP */
+        signed status_esdp = poll(&pollfd_esdp, 1, POLL_TIMEOUT);
+        
+        // If the call did not succeed because it was interrupted for ESDP
+        if (status_esdp == -1) {
+            if (errno == EINTR) {
+                continue;
+            } else {
+                dlog(DLOG_LEVEL_ERROR, "poll() failed for ESDP: %s", strerror(errno));
+                continue;
+            }
+        }
+        /* If new data was received, handle esdp request for ESDP */
+        if (status_esdp > 0) {
+            ssize_t len = recvfrom(v2g_ctx->esdp_socket, buffer_esdp, sizeof(buffer_esdp), 0,
+                                   (struct sockaddr*)&sdp_query.remote_addr, &addrlen);
+            
+            uint32_t reported_len;  // Payload size/length reported in V2GTP Header  
+            reported_len = (buffer_esdp[4] << 24) + (buffer_esdp[5] << 16) + (buffer_esdp[6] << 8) + buffer_esdp[7];
+            uint16_t max_v2gtp_payload_size;    // Maximum payload size in bytes that EVCC can receive. Per [V2G200-52-3] in ISO/PAS CD 15118-200:2024(E) - STANDARD NOT YET PUBLISHED
+
+            if (len == -1) {
+                if (errno != EINTR)
+                    dlog(DLOG_LEVEL_ERROR, "recvfrom() failed for ESDP: %s", strerror(errno));
+                continue;
+            } else {
+                dlog(DLOG_LEVEL_INFO, "Recieved ESDP packet. Reported payload length is %" PRIu32 " bytes while received payload length is %zu bytes",
+                     reported_len ,len - SDP_HEADER_LEN);
+            }
+
+            addr = inet_ntop(AF_INET6, &sdp_query.remote_addr.sin6_addr, addrbuf, sizeof(addrbuf));
+
+            func_return = esdp_validate_header(buffer_esdp, ESDP_REQUEST_TYPE, MAX_ESDP_REQUEST_PAYLOAD_LEN, ESDP_VERSION);
+            
+            if (func_return == -1) {
+                dlog(DLOG_LEVEL_WARNING, "Packet with invalid ESDP header received from [%s]:%" PRIu16, addr,
+                     ntohs(sdp_query.remote_addr.sin6_port));
+                continue;
+            } else if (func_return == 1) {
+            	continue;
+            }
+            
+            max_v2gtp_payload_size = (buffer_esdp[SDP_HEADER_LEN + 2] << 8) + buffer_esdp[SDP_HEADER_LEN + 3];
+            if (max_v2gtp_payload_size > 0) {
+                dlog(DLOG_LEVEL_INFO, "EVCC's reported Max V2GTP Payload size: %" PRIu16 " bytes", max_v2gtp_payload_size);
+            } else {
+                dlog(DLOG_LEVEL_ERROR, "Invalid Max V2GTP Payload size");
+            }
+            
+            // Decode ESDP payload here 
+            decode_return = decode_esdp_payload(buffer_esdp, &sdp_query, len);
+
+            if (decode_return) {
+                dlog(DLOG_LEVEL_WARNING, "Unable to decode ESDP Extensions from ESDPReq message. Discarded ESDP packet received from [%s]:%" PRIu16,
+                 ntohs(sdp_query.remote_addr.sin6_port));
+                continue;
+            }
+
+            dlog(DLOG_LEVEL_INFO, "Received ESDP packet from [%s]:%" PRIu16 " with security 0x%02x and protocol 0x%02x",
+                 addr, ntohs(sdp_query.remote_addr.sin6_port), sdp_query.security_requested, sdp_query.proto_requested);
+
+            esdp_send_response(v2g_ctx->esdp_socket, &sdp_query);
+        }
     }
 
     if (close(v2g_ctx->sdp_socket) == -1) {
         dlog(DLOG_LEVEL_ERROR, "close() failed: %s", strerror(errno));
     }
 
+    if (close(v2g_ctx->esdp_socket) == -1) {
+        dlog(DLOG_LEVEL_ERROR, "close() failed for ESDP socket: %s", strerror(errno));
+    }
+
     return 0;
 }
diff --git /ext/source/modules/EVSE/EvseV2G/tests/CMakeLists.txt /ext/source/modules/EVSE/EvseV2G/tests/CMakeLists.txt
index e0bd49ac1..d032671a2 100644
--- /ext/source/modules/EVSE/EvseV2G/tests/CMakeLists.txt
+++ /ext/source/modules/EVSE/EvseV2G/tests/CMakeLists.txt
@@ -164,6 +164,7 @@ target_link_libraries(${SDP_NAME}
         cbv2g::tp
         everest::framework
         everest::tls
+        asn1_modules
 )
 
 add_test(${SDP_NAME} ${SDP_NAME})
diff --git /ext/source/modules/EVSE/EvseV2G/v2g.hpp /ext/source/modules/EVSE/EvseV2G/v2g.hpp
index dd656c413..4985cd2e1 100644
--- /ext/source/modules/EVSE/EvseV2G/v2g.hpp
+++ /ext/source/modules/EVSE/EvseV2G/v2g.hpp
@@ -211,6 +211,7 @@ struct v2g_context {
     enum tls_security_level tls_security;
 
     int sdp_socket;
+    int esdp_socket; // Added for ESDP.
     int tcp_socket;
 
     int udp_port;
diff --git /ext/source/modules/EVSE/EvseV2G/v2g_ctx.cpp /ext/source/modules/EVSE/EvseV2G/v2g_ctx.cpp
index 94cde60ca..d8d0457e1 100644
--- /ext/source/modules/EVSE/EvseV2G/v2g_ctx.cpp
+++ /ext/source/modules/EVSE/EvseV2G/v2g_ctx.cpp
@@ -305,6 +305,7 @@ struct v2g_context* v2g_ctx_create(ISO15118_chargerImplBase* p_chargerImplBase,
     ctx->network_read_timeout_tls = 5000;
 
     ctx->sdp_socket = -1;
+    ctx->esdp_socket = -1; // Added for ESDP
     ctx->tcp_socket = -1;
     ctx->tls_socket.fd = -1;
     ctx->tls_key_logging = false;