--- ext-switchev-iso15118/iso15118/evcc/controller/interface.py
+++ source/build/dist/libexec/everest/3rd_party/josev/iso15118/evcc/controller/interface.py
@@ -109,6 +109,15 @@
         raise NotImplementedError
 
     @abstractmethod
+    async def get_selected_auth_option(
+        self, protocol: Protocol
+    ) -> AuthEnum:
+        """
+        Gets the auth transfer mode requested for the current charging session.
+        """
+        raise NotImplementedError
+
+    @abstractmethod
     async def get_energy_transfer_mode(
         self, protocol: Protocol
     ) -> EnergyTransferModeEnum:
--- ext-switchev-iso15118/iso15118/evcc/controller/simulator.py
+++ source/build/dist/libexec/everest/3rd_party/josev/iso15118/evcc/controller/simulator.py
@@ -53,6 +53,7 @@
     SAScheduleTupleEntry as SAScheduleTupleEntryDINSPEC,
 )
 from iso15118.shared.messages.enums import (
+    AuthEnum,
     ControlMode,
     DCEVErrorCode,
     EnergyTransferModeEnum,
@@ -233,11 +234,18 @@
             logger.error(f"Invalid protocol '{protocol}', can't determine EVCCID")
             raise InvalidProtocolError
 
+    async def get_selected_auth_option(
+        self, protocol: Protocol
+    ) -> AuthEnum:
+        """Overrides EVControllerInterface.get_selected_auth_option()."""
+        return AuthEnum(EVEREST_EV_STATE.PaymentOption)
+
     async def get_energy_transfer_mode(
         self, protocol: Protocol
     ) -> EnergyTransferModeEnum:
         """Overrides EVControllerInterface.get_energy_transfer_mode()."""
         return EnergyTransferModeEnum(EVEREST_EV_STATE.EnergyTransferMode)
+
 
     async def get_supported_energy_services(self) -> List[ServiceV20]:
         """Overrides EVControllerInterface.get_energy_transfer_service()."""
--- ext-switchev-iso15118/iso15118/evcc/states/iso15118_2_states.py
+++ source/build/dist/libexec/everest/3rd_party/josev/iso15118/evcc/states/iso15118_2_states.py
@@ -193,8 +193,9 @@
             self.stop_state_machine("ChargeService not offered")
             return
 
-        self.select_auth_mode(service_discovery_res.auth_option_list.auth_options)
+        logger.warn("received auth options list %s" % service_discovery_res.auth_option_list.auth_options)
         await self.select_services(service_discovery_res)
+        await self.select_auth_mode(service_discovery_res.auth_option_list.auth_options)
         await self.select_energy_transfer_mode()
 
         charge_service: ChargeService = service_discovery_res.charge_service
@@ -262,12 +263,13 @@
             self.comm_session.selected_energy_mode.value.startswith("AC")
         )
 
-    def select_auth_mode(self, auth_option_list: List[AuthEnum]):
+    async def select_auth_mode(self, auth_option_list: List[AuthEnum]):
         """
         Check if an authorization mode (aka payment option in ISO 15118-2) was
         saved from a previously paused communication session and reuse for
         resumed session, otherwise request from EV controller.
         """
+        logger.warn("V2G_PAYMENT: in function received auth options list %s" % auth_option_list)
         if evcc_settings.ev_session_context.selected_auth_option:
             logger.debug(
                 "Reusing authorization option "
@@ -279,15 +281,30 @@
             )
             evcc_settings.ev_session_context.selected_auth_option = None
         else:
-            # Choose Plug & Charge (pnc) or External Identification Means (eim)
-            # as the selected authorization option. The car manufacturer might
-            # have a mechanism to determine a user-defined or default
-            # authorization option. This implementation favors pnc, but
-            # feel free to change if need be.
-            if AuthEnum.PNC_V2 in auth_option_list and self.comm_session.is_tls:
-                self.comm_session.selected_auth_option = AuthEnum.PNC_V2
+            logger.warn("V2G_PAYMENT: about to read value from state")
+            self.comm_session.selected_auth_option = (
+                await self.comm_session.ev_controller.get_selected_auth_option(
+                    Protocol.ISO_15118_2
+                )
+            )
+            logger.warn("V2G_PAYMENT: in function read value from state %s" % self.comm_session.selected_auth_option)
+            if self.comm_session.selected_auth_option is not None:
+                logger.debug(
+                        "V2G_PAYMENT: Found Payment Option %s passed in from the PyJoseV module, using it" % self.comm_session.selected_auth_option
+                )
             else:
-                self.comm_session.selected_auth_option = AuthEnum.EIM_V2
+                logger.debug(
+                        "V2G_PAYMENT: No previous paused session, no PaymentOption set, using TLS flag %s to decide auth method" % self.comm_session.is_tls
+                )
+                # Choose Plug & Charge (pnc) or External Identification Means (eim)
+                # as the selected authorization option. The car manufacturer might
+                # have a mechanism to determine a user-defined or default
+                # authorization option. This implementation favors pnc, but
+                # feel free to change if need be.
+                if AuthEnum.PNC_V2 in auth_option_list and self.comm_session.is_tls:
+                    self.comm_session.selected_auth_option = AuthEnum.PNC_V2
+                else:
+                    self.comm_session.selected_auth_option = AuthEnum.EIM_V2
 
     async def select_services(self, service_discovery_res: ServiceDiscoveryRes):
         """
